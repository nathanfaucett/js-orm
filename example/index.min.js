(function(dependencies, global) {
    var cache = [];

    function require(path) {
        var module = cache[path],
            callback, exports;

        if (module === undefined) {
            callback = dependencies[path];
            exports = {};

            cache[path] = module = {
                exports: exports,
                require: require
            };

            callback.call(exports, require, exports, module, global);
        }

        return module.exports;
    }

    require.resolve = function(path) {
        return path;
    };

    if (typeof(define) === "function" && define.amd) {
        define([], function() {
            return require(0);
        });
    } else if (typeof(module) !== "undefined" && module.exports) {
        module.exports = require(0);
    } else {
        
            require(0);
        
    }
}([
function(require, exports, module, global) {

var process = require(1);
global.collection = require(2);


global.User = collection.models.User;
global.Cart = collection.models.Cart;
global.Item = collection.models.Item;

if (!process.browser) {
    var Adapter = require(68),
        adapter = new Adapter({
            database: "test"
        });

    collection.bindAdapter("mongodb", adapter);

    User.adapter = "mongodb";
    Cart.adapter = "mongodb";
}

global.User_test = function(callback) {
    console.time("User.test");
    User.find(function(err, users) {
        console.timeEnd("User.test");
        if (err) {
            callback && callback();
            console.warn(err);
            return;
        }
        callback && callback();
        console.log(users);
    });
};

global.Cart_test = function(callback) {
    console.time("Cart.test");
    Cart.find(function(err, carts) {
        console.timeEnd("Cart.test");
        if (err) {
            callback && callback();
            console.warn(err);
            return;
        }
        callback && callback();
        console.log(carts);
    });
};

global.Item_test = function(callback) {
    console.time("Item.test");
    Item.find(function(err, items) {
        console.timeEnd("Item.test");
        if (err) {
            callback && callback();
            console.warn(err);
            return;
        }
        callback && callback();
        console.log(items);
    });
};

global.seed = function() {
    console.time("seed");
    require(69)(function(err) {
        console.timeEnd("seed");
        if (err) {
            console.log(err);
        }
    });
};


collection.init(function(err) {
    if (err) {
        console.log(err);
        return;
    }

    if (!process.browser) {
        User_test(function() {
            Cart_test(Item_test);
        });
    } else {
        require(69)(function(err) {
            if (err) {
                console.log(err);
                return;
            }

            User_test(function() {
                Cart_test(Item_test);
            });
        });
    }
});


},
function(require, exports, module, global) {

// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};


},
function(require, exports, module, global) {

var orm = require(3);


module.exports = orm({
    schema: {
        timestamps: {
            underscore: false
        }
    },
    defaultAdapter: "memory",
    adapters: {
        "memory": new orm.MemoryAdapter()
    }
})

.bindModels(
    require(65),
    require(66),
    require(67)
);


},
function(require, exports, module, global) {

var Collection = require(4),
    Model = require(38);


function orm(options) {

    return new Collection(options);
}

orm.define = function define(options) {

    return new Model(options);
};


orm.hooks = require(62);
orm.functions = require(26);

orm.MemoryAdapter = require(63);


module.exports = orm;


},
function(require, exports, module, global) {

var process = require(1);
var EventEmitter = require(5),
    isObject = require(13),
    forEach = require(17),
    keys = require(10),

    Schema = require(21),
    Model = require(38);


function Collection(opts) {
    var options = {};

    opts || (opts = {});

    options.schema = opts.schema;
    options.adapters = opts.adapters;
    options.defaultAdapter = opts.defaultAdapter || keys(opts.adapters)[0];

    EventEmitter.call(this);

    this._options = options;
    this._schema = new Schema(options.schema);

    this._adapters = {};
    this._modelHash = {};

    this.models = {};

    if (isObject(options.adapters)) {
        this.bindAdapters(options.adapters);
    }
}
EventEmitter.extend(Collection);

Collection.prototype.init = function(callback) {
    var length = 0,
        called = false;

    function createCallback() {
        length++;

        return function done(err) {
            if (called === true) {
                return;
            }

            if (err || --length === 0) {
                called = true;
                callback(err);
            }
        };
    }

    this._schema.init();

    forEach(this.models, function(model) {
        var callback = createCallback();

        process.nextTick(function() {
            model.init(callback);
        });
    });

    forEach(this._adapters, function(adapter) {
        var callback = createCallback();

        process.nextTick(function() {
            adapter.init(callback);
        });
    });

    return this;
};

Collection.prototype.close = function() {

    forEach(this._adapters, function(adapter) {

        adapter.close();
    });
    return this;
};

Collection.prototype.adapter = function(name) {
    var adapter = this._adapters[name];

    if (!adapter) {
        throw new Error(
            "Collection.adapter(name)\n" +
            "    no adapter bound to collection found with tableName or className " + name
        );
    }

    return adapter;
};

Collection.prototype.bindAdapter = function(name, adapter) {

    Collection_bindAdapter(this, name, adapter);
    return this;
};

Collection.prototype.bindAdapters = function(adapters) {
    var _this = this;

    if (!isObject(adapters)) {
        throw new Error(
            "Collection.bindAdapters(adapters)\n" +
            "    adapters must be a Object ex {'memory': new MemoryAdapter(), 'mysql': new MySQLAdapter()}"
        );
    }

    forEach(adapters, function(adapter, name) {

        Collection_bindAdapter(_this, name, adapter);
    });
    return this;
};

function Collection_bindAdapter(_this, name, adapter) {
    var adapters = _this._adapters;

    if (!adapters[name] && !adapter._collection) {
        adapter._collection = _this;
        adapters[name] = adapter;
    } else {
        throw new Error(
            "Collection.bind(adapter)\n" +
            "    adapter " + adapter._className + " already bound to collection"
        );
    }
}

Collection.prototype.model = function(name) {
    var model = this._modelHash[name];

    if (!model) {
        throw new Error(
            "Collection.model(name)\n" +
            "    no model bound to collection found with tableName or className " + name
        );
    }

    return model;
};

Collection.prototype.bindModel = function(model) {

    Collection_bindModel(this, model);
    return this;
};

Collection.prototype.bindModels = function() {
    var i = arguments.length,
        model;

    while (i--) {
        model = arguments[i];

        if (!(model instanceof Model)) {
            throw new Error(
                "Collection.bind(model [, model..])\n" +
                "    model is not an instance of Model"
            );
        }

        Collection_bindModel(this, model);
    }
    return this;
};

function Collection_bindModel(_this, model) {
    var models = _this.models,
        modelHash = _this._modelHash,

        className = model.className,
        tableName = model.tableName;

    if (!modelHash[tableName] && !modelHash[className] && !model._collection) {
        _this._schema.add(model._schema);

        model._collection = _this;
        models[className] = modelHash[tableName] = modelHash[className] = model;
    } else {
        throw new Error(
            "Collection.bind(model)\n" +
            "    model " + model._className + " already bound to collection"
        );
    }
}


module.exports = Collection;


},
function(require, exports, module, global) {

var isFunction = require(6),
    inherits = require(7),
    fastSlice = require(16),
    keys = require(10);


function EventEmitter(maxListeners) {

    this.__events = {};
    this.__maxListeners = maxListeners != null ? maxListeners : EventEmitter.defaultMaxListeners;
}

EventEmitter.prototype.on = function(name, listener) {
    var events, eventList, maxListeners;

    if (!isFunction(listener)) {
        throw new TypeError("EventEmitter.on(name, listener) listener must be a function");
    }

    events = this.__events || (this.__events = {});
    eventList = (events[name] || (events[name] = []));
    maxListeners = this.__maxListeners || -1;

    eventList[eventList.length] = listener;

    if (maxListeners !== -1 && eventList.length > maxListeners) {
        console.error("EventEmitter.on(type, listener) possible EventEmitter memory leak detected. " + maxListeners + " listeners added");
    }

    return this;
};

EventEmitter.prototype.addListener = EventEmitter.prototype.on;

EventEmitter.prototype.once = function(name, listener) {
    var _this = this;

    function once() {
        var length = arguments.length;

        _this.off(name, once);

        if (length === 0) {
            return listener();
        } else if (length === 1) {
            return listener(arguments[0]);
        } else if (length === 2) {
            return listener(arguments[0], arguments[1]);
        } else if (length === 3) {
            return listener(arguments[0], arguments[1], arguments[2]);
        } else if (length === 4) {
            return listener(arguments[0], arguments[1], arguments[2], arguments[3]);
        } else {
            return listener.apply(null, arguments);
        }
    }

    this.on(name, once);

    return once;
};

EventEmitter.prototype.listenTo = function(obj, name) {
    var _this = this;

    if (!(type.isFunction(obj.on) || type.isFunction(obj.addListener))) {
        throw new TypeError("EventEmitter.listenTo(obj, name) obj must have a on function taking (name, listener[, ctx])");
    }

    function handler() {
        _this.emitArgs(name, arguments);
    }

    obj.on(name, handler);

    return handler;
};

EventEmitter.prototype.off = function(name, listener) {
    var events = this.__events || (this.__events = {}),
        eventList, event, i;

    eventList = events[name];
    if (!eventList) {
        return this;
    }

    if (!listener) {
        i = eventList.length;

        while (i--) {
            this.emit("removeListener", name, eventList[i]);
        }
        eventList.length = 0;
        delete events[name];
    } else {
        i = eventList.length;

        while (i--) {
            event = eventList[i];

            if (event === listener) {
                this.emit("removeListener", name, event);
                eventList.splice(i, 1);
            }
        }

        if (eventList.length === 0) {
            delete events[name];
        }
    }

    return this;
};

EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

EventEmitter.prototype.removeAllListeners = function() {
    var events = this.__events || (this.__events = {}),
        objectKeys = keys(events),
        i = -1,
        il = objectKeys.length - 1,
        key, eventList, j;

    while (i++ < il) {
        key = objectKeys[i];
        eventList = events[key];

        if (eventList) {
            j = eventList.length;

            while (j--) {
                this.emit("removeListener", key, eventList[j]);
                eventList.splice(j, 1);
            }
        }

        delete events[key];
    }

    return this;
};

function emit(eventList, args) {
    var a1, a2, a3, a4,
        length = eventList.length - 1,
        i = -1,
        event;

    switch (args.length) {
        case 0:
            while (i++ < length) {
                (event = eventList[i]) && event();
            }
            break;
        case 1:
            a1 = args[0];
            while (i++ < length) {
                (event = eventList[i]) && event(a1);
            }
            break;
        case 2:
            a1 = args[0];
            a2 = args[1];
            while (i++ < length) {
                (event = eventList[i]) && event(a1, a2);
            }
            break;
        case 3:
            a1 = args[0];
            a2 = args[1];
            a3 = args[2];
            while (i++ < length) {
                (event = eventList[i]) && event(a1, a2, a3);
            }
            break;
        case 4:
            a1 = args[0];
            a2 = args[1];
            a3 = args[2];
            a4 = args[3];
            while (i++ < length) {
                (event = eventList[i]) && event(a1, a2, a3, a4);
            }
            break;
        default:
            while (i++ < length) {
                (event = eventList[i]) && event.apply(null, args);
            }
            break;
    }
}

EventEmitter.prototype.emit = function(name) {
    var eventList = (this.__events || (this.__events = {}))[name];

    if (!eventList || !eventList.length) {
        return this;
    }

    emit(eventList, fastSlice(arguments, 1));

    return this;
};

EventEmitter.prototype.emitArgs = function(name, args) {
    var eventList = (this.__events || (this.__events = {}))[name];

    if (!eventList || !eventList.length) {
        return this;
    }

    emit(eventList, args);

    return this;
};

function emitAsync(eventList, args, callback) {
    var length = eventList.length,
        index = 0,
        called = false;

    function next(err) {
        if (called === true) {
            return;
        }
        if (err || index === length) {
            called = true;
            callback(err);
            return;
        }

        eventList[index++].apply(null, args);
    }

    args[args.length] = next;
    next();
}

EventEmitter.prototype.emitAsync = function(name, args, callback) {
    var eventList = (this.__events || (this.__events = {}))[name];

    args = fastSlice(arguments, 1);
    callback = args.pop();

    if (!isFunction(callback)) {
        throw new TypeError("EventEmitter.emitAsync(name [, ...args], callback) callback must be a function");
    }

    if (!eventList || !eventList.length) {
        callback();
    } else {
        emitAsync(eventList, args, callback);
    }

    return this;
};

EventEmitter.prototype.listeners = function(name) {
    var eventList = (this.__events || (this.__events = {}))[name];

    return eventList ? fastSlice(eventList) : [];
};

EventEmitter.prototype.listenerCount = function(name) {
    var eventList = (this.__events || (this.__events = {}))[name];

    return eventList ? eventList.length : 0;
};

EventEmitter.prototype.setMaxListeners = function(value) {
    if ((value = +value) !== value) {
        throw new TypeError("EventEmitter.setMaxListeners(value) value must be a number");
    }

    this.__maxListeners = value < 0 ? -1 : value;
    return this;
};


EventEmitter.defaultMaxListeners = 10;

EventEmitter.listeners = function(obj, name) {
    var eventList;

    if (obj == null) {
        throw new TypeError("EventEmitter.listeners(obj, name) obj required");
    }
    eventList = obj.__events && obj.__events[name];

    return eventList ? fastSlice(eventList) : [];
};

EventEmitter.listenerCount = function(obj, name) {
    var eventList;

    if (obj == null) {
        throw new TypeError("EventEmitter.listenerCount(obj, name) obj required");
    }
    eventList = obj.__events && obj.__events[name];

    return eventList ? eventList.length : 0;
};

EventEmitter.setMaxListeners = function(value) {
    if ((value = +value) !== value) {
        throw new TypeError("EventEmitter.setMaxListeners(value) value must be a number");
    }

    EventEmitter.defaultMaxListeners = value < 0 ? -1 : value;
    return value;
};

EventEmitter.extend = function(child) {

    inherits(child, this);
    child.extend = this.extend;

    return child;
};


module.exports = EventEmitter;


},
function(require, exports, module, global) {

var objectFunction = "[object Function]",
    toString = Object.prototype.toString,
    isFunction;


if (typeof(/./) === "function" || (typeof(Uint8Array) !== "undefined" && typeof(Uint8Array) !== "function")) {
    isFunction = function isFunction(obj) {
        return toString.call(obj) === objectFunction;
    };
} else {
    isFunction = function isFunction(obj) {
        return typeof(obj) === "function" || false;
    };
}


module.exports = isFunction;


},
function(require, exports, module, global) {

var create = require(8),
    extend = require(9),
    mixin = require(14);


module.exports = function inherits(child, parent) {

    mixin(child, parent);
    child.prototype = extend(create(parent.prototype), child.prototype);
    child.prototype.constructor = child;
    child.__super = parent.prototype;

    return child;
};


},
function(require, exports, module, global) {

module.exports = Object.create || (function() {
    function F() {}
    return function create(object) {
        F.prototype = object;
        return new F();
    };
}());


},
function(require, exports, module, global) {

var keys = require(10);


function baseExtend(a, b) {
    var objectKeys = keys(b),
        i = -1,
        il = objectKeys.length - 1,
        key;

    while (i++ < il) {
        key = objectKeys[i];
        a[key] = b[key];
    }
}

module.exports = function extend(out) {
    var i = 0,
        il = arguments.length - 1;

    while (i++ < il) {
        baseExtend(out, arguments[i]);
    }

    return out;
};


},
function(require, exports, module, global) {

var has = require(11),
    isNative = require(12),
    isObject = require(13);


var nativeKeys = Object.keys;


if (!isNative(nativeKeys)) {
    nativeKeys = function keys(obj) {
        var localHas = has,
            out = [],
            i = 0,
            key;

        for (key in obj) {
            if (localHas(obj, key)) {
                out[i++] = key;
            }
        }

        return out;
    };
}

module.exports = function keys(obj) {
    return nativeKeys(isObject(obj) ? obj : Object(obj));
};


},
function(require, exports, module, global) {

var hasOwnProp = Object.prototype.hasOwnProperty;


module.exports = function has(obj, key) {
    return hasOwnProp.call(obj, key);
};


},
function(require, exports, module, global) {

var isFunction = require(6);


var reHostCtor = /^\[object .+?Constructor\]$/,

    functionToString = Function.prototype.toString,

    reNative = RegExp("^" +
        functionToString.call(toString)
        .replace(/[.*+?^${}()|[\]\/\\]/g, "\\$&")
        .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ),

    isHostObject = (function() {
        try {
            String({
                "toString": 0
            } + "");
        } catch (e) {
            return function isHostObject() {
                return false;
            };
        }

        return function isHostObject(value) {
            return !isFunction(value.toString) && typeof(value + "") === "string";
        };
    }());


module.exports = function isNative(obj) {
    return obj && (
        isFunction(obj) ?
        reNative.test(functionToString.call(obj)) : (
            typeof(obj) === "object" && (
                (isHostObject(obj) ? reNative : reHostCtor).test(obj) || false
            )
        )
    ) || false;
};


},
function(require, exports, module, global) {

module.exports = function isObject(obj) {
    var type = typeof(obj);
    return type === "function" || (obj && type === "object") || false;
};


},
function(require, exports, module, global) {

var keys = require(10),
    isNullOrUndefined = require(15);


function baseMixin(a, b) {
    var objectKeys = keys(b),
        i = -1,
        il = objectKeys.length - 1,
        key;

    while (i++ < il) {
        key = objectKeys[i];

        if (isNullOrUndefined(a[key]) && !isNullOrUndefined((value = b[key]))) {
            a[key] = value;
        }
    }
}

module.exports = function mixin(out) {
    var i = 0,
        il = arguments.length - 1;

    while (i++ < il) {
        baseMixin(out, arguments[i]);
    }

    return out;
};


},
function(require, exports, module, global) {

module.exports = function isNullOrUndefined(obj) {
    return obj === null || obj === void 0;
};


},
function(require, exports, module, global) {

module.exports = function fastSlice(array, offset) {
    var length, i, il, result, j;

    offset = offset || 0;

    length = array.length;
    i = offset - 1;
    il = length - 1;
    result = new Array(length - offset);
    j = 0;

    while (i++ < il) {
        result[j++] = array[i];
    }

    return result;
};


},
function(require, exports, module, global) {

var keys = require(10),
    isNullOrUndefined = require(15),
    fastBindThis = require(18),
    isObjectLike = require(19),
    isLength = require(20);


function forEachArray(array, callback) {
    var i = -1,
        il = array.length - 1;

    while (i++ < il) {
        if (callback(array[i], i) === false) {
            return false;
        }
    }

    return array;
}

function forEachObject(object, callback) {
    var objectKeys = keys(object),
        i = -1,
        il = objectKeys.length - 1,
        key;

    while (i++ < il) {
        key = objectKeys[i];

        if (callback(object[key], key) === false) {
            return false;
        }
    }

    return object;
}

module.exports = function forEach(object, callback, thisArg) {
    callback = isNullOrUndefined(thisArg) ? callback : fastBindThis(callback, thisArg, 2);
    return (isObjectLike(object) && isLength(object.length)) ? forEachArray(object, callback) : forEachObject(object, callback);
};


},
function(require, exports, module, global) {

module.exports = function fastBindThis(callback, thisArg, length) {
    switch (length || callback.length) {
        case 0:
            return function bound() {
                return callback.call(thisArg);
            };
        case 1:
            return function bound(a1) {
                return callback.call(thisArg, a1);
            };
        case 2:
            return function bound(a1, a2) {
                return callback.call(thisArg, a1, a2);
            };
        case 3:
            return function bound(a1, a2, a3) {
                return callback.call(thisArg, a1, a2, a3);
            };
        case 4:
            return function bound(a1, a2, a3, a4) {
                return callback.call(thisArg, a1, a2, a3, a4);
            };
        default:
            return function bound() {
                return callback.apply(thisArg, arguments);
            };
    }
};


},
function(require, exports, module, global) {

module.exports = function isObjectLike(obj) {
    return (obj && typeof(obj) === "object") || false;
};


},
function(require, exports, module, global) {

var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;


module.exports = function isLength(obj) {
    return typeof(obj) === "number" && obj > -1 && obj % 1 === 0 && obj <= MAX_SAFE_INTEGER;
};


},
function(require, exports, module, global) {

var forEach = require(17),
    keys = require(10),

    Table = require(22);


var JSON_REPLACER = /\"(.*?)\"\:/g;


function Schema(opts) {
    var options = {};

    opts || (opts = {});

    options.autoId = (opts.autoId != null) ? opts.autoId : true;
    options.timestamps = (opts.timestamps != null) ? opts.timestamps : true;

    this._options = options;

    this.tables = {};
}

Schema.prototype.init = function() {
    var tables = this.tables;

    forEach(tables, function(table) {
        table.init();
    });
    forEach(tables, function(table) {
        table._keys = keys(table.columns);
    });

    return this;
};

Schema.prototype.table = function(tableName) {
    var table = this.tables[tableName];

    if (table === undefined || table === null) {
        throw new Error(
            "Schema.table(tableName)\n" +
            "    no table defined named " + tableName
        );
    }

    return table;
};

Schema.prototype.has = function(tableName) {

    return !!this.tables[tableName];
};

Schema.prototype.create = function(tableName, options) {
    var tables = this.tables,
        opts = this._options,
        table;

    if (tables[tableName]) {
        throw new Error(
            "Schema.create(tableName, options)\n" +
            "    table already defined named " + tableName
        );
    }
    options || (options = {});

    options.autoId = (options.autoId === true) ? opts.autoId : options.autoId;
    options.timestamps = (options.timestamps === true) ? opts.timestamps : options.timestamps;

    table = new Table(tableName, options);
    table.schema = this;

    return (tables[tableName] = table);
};

Schema.prototype.add = function(table) {
    var tables = this.tables,
        opts = this._options,
        options = table._options,
        tableName;

    if (!(table instanceof Table)) {
        throw new Error(
            "Schema.add(table)\n" +
            "    table must be an instance of Table"
        );
    }

    tableName = table.tableName;

    if (tables[tableName]) {
        throw new Error(
            "Schema.add(table)\n" +
            "    table already defined named " + tableName
        );
    }

    options.autoId = (options.autoId === true) ? opts.autoId : options.autoId;
    options.timestamps = (options.timestamps === true) ? opts.timestamps : options.timestamps;

    table.schema = this;

    return (tables[tableName] = table);
};

Schema.prototype.toJSON = function() {
    var json = {};

    forEach(this.tables, function(table, tableName) {
        json[tableName] = table.toJSON();
    });

    return json;
};

Schema.prototype.fromJSON = function(json) {
    var _this = this,
        options = this._options;

    forEach(json, function(columns, tableName) {
        var opts = options[tableName];

        if (opts) {
            delete options[tableName];
        } else {
            opts = options;
        }

        _this.create(tableName, opts).addColumns(columns);
    });

    return this;
};

Schema.prototype.toExports = function(numOfSpacesPerTab) {

    return "module.exports = " + JSON.stringify(this.toJSON(), null, +numOfSpacesPerTab || 4).replace(JSON_REPLACER, function(match, key) {
        return key + ":";
    }) + ";\n";
};


module.exports = Schema;


},
function(require, exports, module, global) {

var isString = require(23),
    forEach = require(17),
    keys = require(10),
    extend = require(9),
    indexOf = require(24),
    has = require(11),

    functions = require(26);


var types = [
        "string",
        "integer",
        "float",
        "datetime",
        "json",
        "boolean"
    ],
    allowed = [
        "primaryKey",
        "foreignKey",
        "autoIncrement",
        "index",
        "unique"
    ];

function coerceType(value) {
    value = (value + "").toLowerCase();

    return (
        (value === "integer" || value === "int") ? "integer" :
        (value === "float" || value === "double" || value === "decimal" || value === "dec") ? "float" :
        (value === "boolean" || value === "bool") ? "boolean" :
        (value === "datetime" || value === "date" || value === "time") ? "datetime" :
        (value === "json" || value === "object" || value === "array") ? "json" :
        "string"
    );
}

function coerceValue(attributes, value) {
    var type = attributes.type,
        defaults = attributes.defaults;

    if (value == null && defaults != null) {
        value = defaults;
    }
    if (value == null) {
        return null;
    }

    if (type === "string") {
        return typeof(value.toString) !== "undefined" ? value.toString() : value + "";
    } else if (type === "integer" || type === "float") {
        return +value;
    } else if (type === "json") {
        return JSON.stringify(value);
    } else if (type === "boolean") {
        return !!value;
    } else if (type === "datetime") {
        return value instanceof Date ? value.toJSON() : (new Date(value)).toJSON();
    }

    return value;
}


function Table(tableName, opts) {
    var options = {};

    opts || (opts = {});

    options.autoId = (opts.autoId != null) ? opts.autoId : true;
    options.timestamps = (opts.timestamps != null) ? opts.timestamps : true;
    options.functions = extend(opts.functions || {}, functions);

    this._options = options;
    this._keys = null;
    this._functions = {};
    this._defines = {};

    this.schema = null;
    this.tableName = tableName;

    this.columns = {};

    if (opts.columns) {
        this.addColumns(opts.columns);
    }
}

Table.coerceType = coerceType;
Table.coerceValue = coerceValue;
Table.types = types;
Table.allowed = allowed;

Table.prototype.init = function() {
    var _this = this,
        options = this._options,
        schema = this.schema,
        columns = this.columns;

    if (options.autoId) {
        this.add("autoId", options.autoId);
    }
    if (options.timestamps) {
        this.add("timestamps", options.timestamps);
    }

    forEach(this._defines, function(column, columnName) {
        columns[columnName] = extend({}, column);
    });
    forEach(this._functions, function(opts, functionName) {
        options.functions[functionName](schema, _this, opts);
    });

    return this;
};

Table.prototype.table = function(tableName) {

    return this.schema.table(tableName);
};

Table.prototype.column = function(columnName) {
    var column = this.columns[columnName];

    if (column === undefined || column === null) {
        throw new Error(
            "Table.column(columnName)\n" +
            "    " + this.tableName + " has no column defined named " + columnName
        );
    }

    return column;
};

Table.prototype.has = function(columnName) {

    return !!this.columns[columnName];
};

Table.prototype.addColumns = function(columns) {
    var _this = this;

    forEach(columns, function(attributes, columnName) {

        _this.add(columnName, attributes);
    });
    return this;
};

Table.prototype.add = function(columnName, attributes) {
    var defines;

    if (has(this._options.functions, columnName)) {
        Table_parseFunction(this, columnName, attributes);
    } else {
        defines = this._defines;
        Table_parseColumn(this, columnName, attributes, defines[columnName] || (defines[columnName] = {}));
    }

    return this;
};

Table.prototype.functionAdd = function(columnName, attributes) {
    var columns = this.columns,
        column = columns[columnName] || (columns[columnName] = {});

    Table_parseColumn(this, columnName, attributes, column);
    return this;
};

Table.prototype.filter = function(values, accessible) {
    var filtered = {},
        columns = this.columns,
        keys = this._keys || [],
        i = keys.length,
        key, value, newValue;

    while (i--) {
        key = keys[i];
        value = values[key];
        newValue = coerceValue(columns[key], value);

        if (newValue != null && (accessible ? accessible[key] : true)) {
            filtered[key] = newValue;
        }
    }

    return filtered;
};

Table.prototype.coerce = function(values) {
    var columns = this.columns,
        keys = this._keys || [],
        i = keys.length,
        key;

    while (i--) {
        key = keys[i];
        values[key] = coerceValue(columns[key], values[key]);
    }

    return values;
};

Table.prototype.toJSON = function() {
    var json = {};

    forEach(this._defines, function(column, columnName) {
        var objectKeys = keys(column),
            i = objectKeys.length,
            jsonColumn, key;

        if (i === 1) {
            key = objectKeys[0];
            json[columnName] = column[key];
        } else {
            jsonColumn = json[columnName] = {};

            while (i--) {
                key = objectKeys[i];
                jsonColumn[key] = column[key];
            }
        }
    });
    forEach(this._functions, function(options, functionName) {

        json[functionName] = options;
    });

    return json;
};

function Table_parseFunction(_this, columnName, attributes) {

    _this._functions[columnName] = attributes != null ? attributes : true;
}

function Table_parseColumn(_this, columnName, attributes, column) {
    if (isString(attributes)) {
        attributes = {
            type: attributes
        };
    }

    forEach(attributes, function(value, key) {
        var coerced;

        if (key === "type") {
            coerced = coerceType(value);

            if (indexOf(types, coerced) === -1) {
                throw new Error(
                    "Table parseColumn(columnName, attributes, column)\n" +
                    "    table " + _this.tableName + " was passed a column named " + columnName + " with a value of " + value + "\n" +
                    "    interpreted as type which must be on of\n" +
                    "    " + types.join(", ")
                );
            }

            column[key] = coerced;
        } else if (key === "defaults") {
            column[key] = value;
        } else {
            if (indexOf(allowed, key) === -1) {
                throw new Error(
                    "Table parseColumn(columnName, attributes, column)\n" +
                    "    table " + _this.tableName + " column " + columnName + " passed " + value + " allowed attributes are,\n" +
                    "    type, " + allowed.join(", ")
                );
            }

            column[key] = true;
        }
    });
}


module.exports = Table;


},
function(require, exports, module, global) {

module.exports = function isString(obj) {
    return typeof(obj) === "string" || false;
};


},
function(require, exports, module, global) {

var isArray = require(25);


function arrayIndexOf(array, value, fromIndex) {
    var i = fromIndex - 1,
        il = array.length - 1;

    while (i++ < il) {
        if (array[i] === value) {
            return i;
        }
    }

    return -1;
}

module.exports = function indexOf(array, value, fromIndex) {
    return isArray(array) ? arrayIndexOf(array, value, fromIndex || 0) : -1;
};


},
function(require, exports, module, global) {

var isLength = require(20),
    isObjectLike = require(19);


var objectArray = "[object Array]",
    toString = Object.prototype.toString;


module.exports = Array.isArray || function isArray(obj) {
    return isObjectLike(obj) && isLength(obj.length) && toString.call(obj) === objectArray;
};


},
function(require, exports, module, global) {

var isObject = require(13),
    isArray = require(25),
    forEach = require(17),

    foreignKey = require(27),
    singularize = require(33),
    pluralize = require(37);


var functions = module.exports;


functions.autoId = function(schema, table, options) {
    var value = {};

    options = isObject(options) ? options : {};

    value.type = options.type || "integer";
    if (options.primaryKey !== false) {
        value.primaryKey = true;
    }
    if (options.autoIncrement !== false) {
        value.autoIncrement = true;
    }

    table.functionAdd(options.key || "id", value);
};

functions.timestamps = function(schema, table, options) {
    var createdAt = "createdAt",
        updatedAt = "updatedAt";

    if (isObject(options)) {
        if (options.underscore === true || options.camelcase === false) {
            createdAt = "created_at";
            updatedAt = "updated_at";
        }
    }

    table.functionAdd(createdAt, "datetime");
    table.functionAdd(updatedAt, "datetime");
};

functions.hasMany = function(schema, table, options) {
    var model, columnName;

    if (isArray(options)) {
        forEach(options, function(value) {
            functions.hasMany(schema, table, value);
        });
        return;
    }

    options = isObject(options) ? options : {
        collection: options + ""
    };

    model = schema.table(options.collection);

    columnName = foreignKey(
        singularize(table.tableName, options.locale),
        options.key || "id",
        options.underscore === false || options.camelcase === true || true,
        options.lowFirstLetter != null ? !!options.lowFirstLetter : true
    );

    model.functionAdd(columnName, {
        type: options.type || "integer",
        foreignKey: true
    });
};

functions.hasOne = function(schema, table, options) {
    var model, columnName;

    if (isArray(options)) {
        forEach(options, function(value) {
            functions.hasOne(schema, table, value);
        });
        return;
    }

    options = isObject(options) ? options : {
        model: options + ""
    };

    model = schema.table(pluralize(options.model, options.locale));

    columnName = foreignKey(
        singularize(table.tableName, options.locale),
        options.key || "id",
        options.underscore === false || options.camelcase === true || true,
        options.lowFirstLetter != null ? !!options.lowFirstLetter : true
    );

    model.functionAdd(columnName, {
        type: options.type || "integer",
        unique: true,
        foreignKey: true
    });
};

functions.belongsTo = function(schema, table, options) {
    var model, columnName;

    if (isArray(options)) {
        forEach(options, function(value) {
            functions.belongsTo(schema, table, value);
        });
        return;
    }

    options = isObject(options) ? options : {
        model: options + ""
    };

    model = schema.table(pluralize(options.model, options.locale));

    columnName = foreignKey(
        options.model,
        options.key || "id",
        options.underscore === false || options.camelcase === true || true,
        options.lowFirstLetter != null ? !!options.lowFirstLetter : true
    );

    table.functionAdd(columnName, {
        type: options.type || "integer",
        foreignKey: true
    });
};


},
function(require, exports, module, global) {

var isString = require(23),
    isBoolean = require(28),
    camelize = require(29),
    underscore = require(32);


module.exports = function foreignKey(string, key, camelized, lowFirstLetter) {
    if (isBoolean(key)) {
        lowFirstLetter = camelized;
        camelized = key;
        key = "id";
    }

    key = isString(key) ? key : "id";

    if (camelized !== false) {
        return camelize(string + "_" + key, lowFirstLetter);
    } else {
        return underscore(string + "_" + key);
    }
};


},
function(require, exports, module, global) {

module.exports = function isBoolean(obj) {
    return typeof(obj) === "boolean" || false;
};


},
function(require, exports, module, global) {

var reInflect = require(30),
    capitalizeString = require(31);


module.exports = function camelize(string, lowFirstLetter) {
    var parts = string.match(reInflect),
        i = parts.length;

    while (i--) {
        parts[i] = capitalizeString(parts[i]);
    }
    string = parts.join("");

    return lowFirstLetter !== false ? string.charAt(0).toLowerCase() + string.slice(1) : string;
};


},
function(require, exports, module, global) {

module.exports = /[^A-Z-_ \.]+|[A-Z][^A-Z-_ \.]+|[^a-z-_ \.]+/g;


},
function(require, exports, module, global) {

module.exports = function capitalizeString(string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
};


},
function(require, exports, module, global) {

var reInflect = require(30);


module.exports = function underscore(string) {
    return string.match(reInflect).join("_").toLowerCase();
};


},
function(require, exports, module, global) {

var inflections = require(34);


module.exports = function singularize(string, locale) {
    return inflections(locale).singularize(string);
};


},
function(require, exports, module, global) {

var Inflector = require(35),
    defineProperty = require(36);


var locales = global.__INFLECTORS__,
    defaultLocale = global.__DEFAULT_LOCALE__;


if (!locales) {
    locales = {};
    defineProperty(global, "__INFLECTORS__", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: locales
    });
}

if (!defaultLocale) {
    defaultLocale = "en";
    defineProperty(global, "__DEFAULT_LOCALE__", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: defaultLocale
    });
}


module.exports = inflections;


function inflections(locale) {
    locale = locale || defaultLocale;
    return locales[locale] || (locales[locale] = Inflector.create());
}

inflections.setDefaultLocale = function(locale) {
    global.__DEFAULT_LOCALE__ = defaultLocale = locale;
};


},
function(require, exports, module, global) {

var indexOf = require(24);


module.exports = Inflector;


function Inflector() {
    this.plurals = [];
    this.singulars = [];
    this.uncountables = [];
}

Inflector.create = function() {
    return new Inflector();
};

Inflector.prototype.clear = function() {

    this.plurals.length = 0;
    this.singulars.length = 0;
    this.uncountables.length = 0;

    return this;
};

Inflector.prototype.uncountable = function() {
    var uncountables = this.uncountables,
        i = -1,
        il = arguments.length - 1;

    while (i++ < il) {
        uncountables[uncountables.length] = arguments[i].toLowerCase();
    }
    return this;
};

Inflector.prototype.plural = function(rule, replacement) {
    var plurals = this.plurals;

    plurals[plurals.length] = [rule, replacement];
    return this;
};

Inflector.prototype.singular = function(rule, replacement) {
    var singulars = this.singulars;

    singulars[singulars.length] = [rule, replacement];
    return this;
};

Inflector.prototype.irregular = function(singular, plural) {

    singular = singular.toLowerCase();
    plural = plural.toLowerCase();

    this.plural(new RegExp("\\b" + singular + "\\b", "i"), plural);
    this.singular(new RegExp("\\b" + plural + "\\b", "i"), singular);

    return this;
};

Inflector.prototype.pluralize = function(word) {
    var plurals = this.plurals,
        result = word,
        i = plurals.length,
        pattern;

    if (indexOf(this.uncountables, word.toLowerCase()) !== -1) {
        return word;
    }

    while (i--) {
        pattern = plurals[i];

        if ((result = replace(word, pattern[0], pattern[1]))) {
            return result;
        }
    }

    return word;
};

Inflector.prototype.isPlural = function(word) {

    return this.singularize(word) !== word;
};

Inflector.prototype.is_plural = Inflector.prototype.isPlural;

Inflector.prototype.singularize = function(word) {
    var singulars = this.singulars,
        result = word,
        i = singulars.length,
        pattern;

    if (indexOf(this.uncountables, word.toLowerCase()) !== -1) {
        return word;
    }

    while (i--) {
        pattern = singulars[i];

        if ((result = replace(word, pattern[0], pattern[1]))) {
            return result;
        }
    }

    return word;
};

Inflector.prototype.isSingular = function(word) {

    return this.pluralize(word) !== word;
};

Inflector.prototype.is_singular = Inflector.prototype.isSingular;

function replace(word, rule, replacement) {
    if (rule.test(word)) {
        return word.replace(rule, replacement);
    } else {
        return false;
    }
}


},
function(require, exports, module, global) {

var isFunction = require(6),
    isObjectLike = require(19),
    isNative = require(12);


var defineProperty;


if (!isNative(Object.defineProperty)) {
    defineProperty = function defineProperty(object, name, value) {
        if (!isObjectLike(object)) {
            throw new TypeError("defineProperty called on non-object");
        }
        object[name] = isObjectLike(value) ? (isFunction(value.get) ? value.get : value.value) : value;
    };
} else {
    defineProperty = Object.defineProperty;
}

module.exports = defineProperty;


},
function(require, exports, module, global) {

var inflections = require(34);


module.exports = function pluralize(string, locale) {
    return inflections(locale).pluralize(string);
};


},
function(require, exports, module, global) {

var EventEmitter = require(5),
    forEach = require(17),
    isString = require(23),
    isFunction = require(6),
    isObject = require(13),
    isArray = require(25),
    tableize = require(39),
    underscore = require(32),
    PromisePolyfill = require(40),
    validator = require(43),

    Query = require(61),
    Table = require(22),
    hooks = require(62);


var slice = Array.prototype.slice;


function Model(opts) {
    var options = {};

    opts || (opts = {});

    if (!isString(opts.name) && !isString(opts.className)) {
        throw new Error(
            "Model(options)\n" +
            "    options.name or options.className required as string ex {name: 'User'}"
        );
    }

    options.columns = opts.columns || opts.schema;
    options.functions = opts.functions;

    options.className = opts.name || opts.className;
    options.tableName = isString(opts.tableName) ? opts.tableName : tableize(options.className);

    options.autoId = (opts.autoId != null) ? opts.autoId : true;
    options.timestamps = (opts.timestamps != null) ? opts.timestamps : true;

    EventEmitter.call(this);

    this._options = options;

    this._init = false;
    this._collection = null;

    this._accessible = {};
    this._validations = {};
    this._wrappers = {};

    this._schema = new Table(options.tableName, options);

    this.Class = null;

    this.adapter = opts.adapter;

    this.className = options.className;
    this.tableName = options.tableName;

    this.prototype = {};
}
EventEmitter.extend(Model);

Model.prototype.init = function(callback) {
    var _this = this,
        adapter = this.adapter || this._collection._options.defaultAdapter,
        schema = this._schema;

    forEach(schema._functions, function(options, name) {
        var hookFunc = hooks[name],
            hook;

        if (!isFunction(hookFunc)) {
            return;
        }

        hook = hookFunc(isObject(options) ? options : {});

        forEach(hook.events, function(event, eventType) {
            if (isArray(event)) {
                forEach(event, function(e) {
                    _this.on(eventType, e);
                });
            } else if (isFunction(event)) {
                _this.on(eventType, event);
            }
        });
    });

    forEach(schema.columns, function(column, name) {

        _this.validates(name)[column.type]();
    });

    if (isString(adapter)) {
        this.adapter = this._collection.adapter(adapter);
    } else {
        this.adapter = adapter;
    }

    this.generateClass();
    this._wrappers = {};

    this.emitAsync("init", callback);

    return this;
};

Model.prototype.build = function(attributes) {
    var instance = new this.Class(),
        schema, columns, columnType, keys, key, attribute, i;

    if (isObject(attributes)) {
        schema = this._schema;
        columns = schema.columns;
        keys = schema._keys;
        i = keys.length;

        while (i--) {
            key = keys[i];
            attribute = attributes[key];
            columnType = columns[key].type;

            if (attribute != null) {
                if (columnType === "datetime") {
                    instance[key] = (new Date(attribute)).toJSON();
                } else if (columnType === "json" && isString(attribute)) {
                    try {
                        instance[key] = JSON.parse(attribute);
                    } catch (e) {
                        instance[key] = null;
                    }
                } else {
                    instance[key] = attribute;
                }
            }
        }
    }

    return instance;
};

Model.prototype["new"] = Model.prototype.build;

Model.prototype.create = function(attributes, callback) {
    var _this = this,
        isPromise = !isFunction(callback),
        model = this.build(attributes),
        defer;

    if (isPromise) {
        defer = PromisePolyfill.defer();
    }

    function resolve(row) {
        return isPromise ? defer.resolve(row) : callback(undefined, row);
    }

    function reject(err) {
        return isPromise ? defer.reject(err) : callback(err);
    }

    function beforeValidate(err) {
        var errors;

        if (err) {
            reject(err);
            return;
        }
        if ((errors = _this.validate(model))) {
            reject(errors);
            return;
        }

        _this.emitAsync("validate", model, validate);
    }

    function validate(err) {
        if (err) {
            reject(err);
            return;
        }
        _this.emitAsync("beforeCreate", model, beforeCreate);
    }

    function beforeCreate(err) {
        if (err) {
            reject(err);
            return;
        }
        _this.adapter.save(_this.tableName, model, function(err, row) {
            if (err) {
                reject(err);
                return;
            }

            row = _this.build(row);
            _this.emitAsync("create", row, function(err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(row);
            });
        });
    }

    this._schema.coerce(model);
    this.emitAsync("beforeValidate", model, beforeValidate);

    return defer ? defer.promise : undefined;
};

Model.prototype.save = function(model, callback) {
    var _this = this,
        isPromise = !isFunction(callback),
        defer;

    if (isPromise) {
        defer = PromisePolyfill.defer();
    }

    function resolve(row) {
        return isPromise ? defer.resolve(row) : callback(undefined, row);
    }

    function reject(err) {
        return isPromise ? defer.reject(err) : callback(err);
    }

    function beforeValidate(err) {
        var errors;

        if (err) {
            reject(err);
            return;
        }
        if ((errors = _this.validate(model))) {
            reject(errors);
            return;
        }

        _this.emitAsync("validate", model, validate);
    }

    function validate(err) {
        if (err) {
            reject(err);
            return;
        }
        _this.emitAsync("beforeSave", model, beforeSave);
    }

    function beforeSave(err) {
        if (err) {
            reject(err);
            return;
        }
        _this.adapter.save(_this.tableName, model, function(err, row) {
            if (err) {
                reject(err);
                return;
            }

            row = _this.build(row);
            _this.emitAsync("save", row, function(err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(row);
            });
        });
    }

    this._schema.coerce(model);
    this.emitAsync("beforeValidate", model, beforeValidate);

    return defer ? defer.promise : undefined;
};

Model.prototype.update = function(id, model, callback) {
    var _this = this,
        isPromise = !isFunction(callback),
        defer;

    if (isPromise) {
        defer = PromisePolyfill.defer();
    }

    function resolve(row) {
        return isPromise ? defer.resolve(row) : callback(undefined, row);
    }

    function reject(err) {
        return isPromise ? defer.reject(err) : callback(err);
    }

    function beforeValidate(err) {
        var errors;

        if (err) {
            reject(err);
            return;
        }
        if ((errors = _this.validate(model))) {
            reject(errors);
            return;
        }

        _this.emitAsync("validate", model, validate);
    }

    function validate(err) {
        if (err) {
            reject(err);
            return;
        }
        _this.emitAsync("beforeUpdate", model, beforeUpdate);
    }

    function beforeUpdate(err) {
        if (err) {
            reject(err);
            return;
        }
        _this.adapter.update(_this.tableName, id, model, function(err, row) {
            if (err) {
                reject(err);
                return;
            }

            row = _this.build(row);
            _this.emitAsync("update", row, function(err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(row);
            });
        });
    }

    model = this._schema.filter(model, this._accessible);
    this.emitAsync("beforeValidate", model, beforeValidate);

    return defer ? defer.promise : undefined;
};

Model.prototype.find = function(query, callback) {
    var _this = this;

    if (isFunction(query)) {
        callback = query;
        query = {};
    }

    if (isFunction(callback)) {
        if (!isObject(query)) {
            query = {};
        }

        if (query.where === undefined || query.where === null) {
            query.where = {};
        }

        this.adapter.find(this.tableName, query, function(err, rows) {
            if (err) {
                callback(err);
                return;
            }

            callback(undefined, Model_toModels(_this, rows));
        });
        return undefined;
    }

    return new Query(this, "find", query);
};

Model.prototype.findOne = function(query, callback) {
    var _this = this;

    if (isFunction(query)) {
        callback = query;
        query = {};
    }

    if (isFunction(callback)) {
        if (!isObject(query)) {
            query = {};
        }

        if (query.where === undefined || query.where === null) {
            query.where = {};
        }

        this.adapter.findOne(this.tableName, query, function(err, row) {
            if (err) {
                callback(err);
                return;
            }

            callback(undefined, _this.build(row));
        });
        return undefined;
    }

    return new Query(this, "findOne", query);
};

Model.prototype.destroy = function(query, callback) {
    var _this = this,
        beforeDestroy;

    if (isFunction(query)) {
        callback = query;
        query = {};
    }

    if (isFunction(callback)) {
        beforeDestroy = function beforeDestroy(err) {
            if (err) {
                callback(err);
                return;
            }

            if (!isObject(query)) {
                query = {};
            }

            if (query.where === undefined || query.where === null) {
                query.where = {};
            }

            _this.adapter.destroy(_this.tableName, query, function(err, rows) {
                if (err) {
                    callback(err);
                    return;
                }

                rows = Model_toModels(_this, rows);
                _this.emitAsync("destroy", rows, function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback(undefined, rows);
                });
            });
        };

        this.emitAsync("beforeDestroy", query, beforeDestroy);
        return undefined;
    }

    return new Query(this, "destroy", query);
};

Model.prototype.accessible = function() {
    var accessible = this._accessible,
        i = arguments.length,
        columnName;

    while (i--) {
        if ((columnName = arguments[i])) {
            accessible[columnName] = true;
        }
    }
    return this;
};

Model.prototype.validates = function(columnName) {
    var validations = this._validations,
        wrappers = this._wrappers,
        validation = validations[columnName] || (validations[columnName] = {}),
        wrapper = wrappers[columnName];

    if (!wrapper) {
        wrapper = wrappers[columnName] = {};

        forEach(validator.rules, function(rule, ruleName) {
            wrapper[ruleName] = function() {
                validation[underscore(ruleName)] = arguments.length > 0 ? slice.call(arguments) : true;
                return wrapper;
            };
        });
    }

    return wrapper;
};

function ValidationError(tableName, columnName, value, rule, args) {

    this.tableName = tableName;
    this.columnName = columnName;
    this.value = value;
    this.rule = rule;
    this.args = args;
}

Model.prototype.validate = function(values, method) {
    var match = validator.match,
        validations = this._validations,
        keys = this._schema._keys,
        i = keys.length,
        key, validation, value, rule, args, error, errors;

    while (i--) {
        key = keys[i];
        value = values[key];
        validation = validations[key];

        if (
            (value === undefined || value === null) &&
            (!validation || !validation.required || method === "update")
        ) {
            continue;
        }

        for (rule in validation) {
            args = validation[rule];

            if (typeof(args) === "boolean") {
                error = match(rule, value);
            } else {
                error = match(rule, value, args);
            }

            if (error) {
                (errors || (errors = [])).push(new ValidationError(this.tableName, key, value, rule, args));
            }
        }
    }

    return errors;
};

Model.prototype.generateClass = function() {
    var model = this,
        Class;

    try {
        eval([
            "function " + this.className + "() {",
            Model_generateClassAttributes(this),
            "}",
            "Class = " + this.className + ";"
        ].join("\n"));
    } catch (e) {
        throw new Error("Model.generateClass() failed to generate model for " + this.className + " with error " + e.message);
    }

    Class.prototype = model.prototype;
    Class.prototype.constructor = Class;

    Class.prototype.save = function(callback) {

        return model.save(this, callback);
    };

    Class.prototype.update = function(callback) {

        return model.update(this.id, this, callback);
    };

    Class.prototype.destroy = function(callback) {
        return model.destroy({
            where: {
                id: this.id
            }
        }, callback);
    };

    this.Class = Class;

    return this;
};

function Model_toModels(_this, array) {
    var i = array.length;

    while (i--) {
        array[i] = _this.build(array[i]);
    }
    return array;
}

function Model_generateClassAttributes(_this) {
    var out = [];

    forEach(_this._schema.columns, function(_, key) {
        out.push("\tthis." + key + " = null;");
    });

    return out.join("\n");
}


module.exports = Model;


},
function(require, exports, module, global) {

var isString = require(23),
    camelize = require(29),
    underscore = require(32),
    pluralize = require(37);


module.exports = function tableize(string, camelcase, locale) {
    if (isString(camelcase)) {
        locale = camelcase;
        camelcase = true;
    }

    return camelcase !== false ? camelize(pluralize(string, locale)) : underscore(pluralize(string, locale));
};


},
function(require, exports, module, global) {

var process = require(1);
var isArray = require(25),
    isObject = require(13),
    isFunction = require(6),
    createStore = require(41),
    fastSlice = require(16);


var PromisePolyfill, PrivatePromise;


if (typeof(Promise) !== "undefined") {
    PromisePolyfill = Promise;
} else {
    PrivatePromise = (function() {

        function PrivatePromise(resolver) {
            var _this = this;

            this.handlers = [];
            this.state = null;
            this.value = null;

            handleResolve(
                resolver,
                function resolve(newValue) {
                    resolveValue(_this, newValue);
                },
                function reject(newValue) {
                    rejectValue(_this, newValue);
                }
            );
        }

        PrivatePromise.store = createStore();

        PrivatePromise.handle = function(_this, onFulfilled, onRejected, resolve, reject) {
            handle(_this, new Handler(onFulfilled, onRejected, resolve, reject));
        };

        function Handler(onFulfilled, onRejected, resolve, reject) {
            this.onFulfilled = isFunction(onFulfilled) ? onFulfilled : null;
            this.onRejected = isFunction(onRejected) ? onRejected : null;
            this.resolve = resolve;
            this.reject = reject;
        }

        function handleResolve(resolver, onFulfilled, onRejected) {
            var done = false;

            try {
                resolver(
                    function(value) {
                        if (done) {
                            return;
                        }
                        done = true;
                        onFulfilled(value);
                    },
                    function(reason) {
                        if (done) {
                            return;
                        }
                        done = true;
                        onRejected(reason);
                    }
                );
            } catch (err) {
                if (done) {
                    return;
                }
                done = true;
                onRejected(err);
            }
        }

        function resolveValue(_this, newValue) {
            try {
                if (newValue === _this) {
                    throw new TypeError("A promise cannot be resolved with itself");
                }

                if (newValue && (isObject(newValue) || isFunction(newValue))) {
                    if (isFunction(newValue.then)) {
                        handleResolve(
                            function resolver(resolve, reject) {
                                newValue.then(resolve, reject);
                            },
                            function resolve(newValue) {
                                resolveValue(_this, newValue);
                            },
                            function reject(newValue) {
                                rejectValue(_this, newValue);
                            }
                        );
                        return;
                    }
                }
                _this.state = true;
                _this.value = newValue;
                finale(_this);
            } catch (err) {
                rejectValue(_this, err);
            }
        }

        function rejectValue(_this, newValue) {
            _this.state = false;
            _this.value = newValue;
            finale(_this);
        }

        function finale(_this) {
            var handlers = _this.handlers,
                i = -1,
                il = handlers.length - 1;

            while (i++ < il) {
                handle(_this, handlers[i]);
            }

            handlers.length = 0;
        }

        function handle(_this, handler) {
            var state = _this.state;

            if (_this.state === null) {
                _this.handlers.push(handler);
                return;
            }

            process.nextTick(function nextTick() {
                var callback = state ? handler.onFulfilled : handler.onRejected,
                    value = _this.value,
                    out;

                if (callback === null) {
                    (state ? handler.resolve : handler.reject)(value);
                    return;
                }

                try {
                    out = callback(value);
                } catch (err) {
                    handler.reject(err);
                    return;
                }

                handler.resolve(out);
            });
        }

        return PrivatePromise;
    }());

    PromisePolyfill = function Promise(resolver) {

        if (!(this instanceof PromisePolyfill)) {
            throw new TypeError("Promise(resolver) \"this\" must be an instance of of Promise");
        }
        if (!isFunction(resolver)) {
            throw new TypeError("Promise(resolver) You must pass a resolver function as the first argument to the promise constructor");
        }

        PrivatePromise.store.set(this, new PrivatePromise(resolver));
    };

    PromisePolyfill.prototype.then = function(onFulfilled, onRejected) {
        var _this = PrivatePromise.store.get(this);

        return new PromisePolyfill(function resolver(resolve, reject) {
            PrivatePromise.handle(_this, onFulfilled, onRejected, resolve, reject);
        });
    };
}


if (!isFunction(PromisePolyfill.prototype["catch"])) {
    PromisePolyfill.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
    };
}

if (!isFunction(PromisePolyfill.resolve)) {
    PromisePolyfill.resolve = function(value) {
        if (value instanceof PromisePolyfill) {
            return value;
        }

        return new PromisePolyfill(function resolver(resolve) {
            resolve(value);
        });
    };
}

if (!isFunction(PromisePolyfill.reject)) {
    PromisePolyfill.reject = function(value) {
        return new PromisePolyfill(function resolver(resolve, reject) {
            reject(value);
        });
    };
}

if (!isFunction(PromisePolyfill.defer)) {
    PromisePolyfill.defer = function() {
        var deferred = {};

        deferred.promise = new PromisePolyfill(function resolver(resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });

        return deferred;
    };
}

if (!isFunction(PromisePolyfill.all)) {
    PromisePolyfill.all = function(value) {
        var args = (arguments.length === 1 && isArray(value)) ? value : fastSlice(arguments);

        return new PromisePolyfill(function resolver(resolve, reject) {
            var length = args.length,
                i = -1,
                il = length - 1;

            if (length === 0) {
                resolve([]);
                return;
            }

            function resolveValue(index, value) {
                try {
                    if (value && (isObject(value) || isFunction(value)) && isFunction(value.then)) {
                        value.then(function(v) {
                            resolveValue(index, v);
                        }, reject);
                        return;
                    }
                    if (--length === 0) {
                        resolve(args);
                    }
                } catch (e) {
                    reject(e);
                }
            }

            while (i++ < il) {
                resolveValue(i, args[i]);
            }
        });
    };
}

if (!isFunction(PromisePolyfill.race)) {
    PromisePolyfill.race = function(values) {
        return new PromisePolyfill(function resolver(resolve, reject) {
            var i = -1,
                il = values.length - 1,
                value;

            while (i++ < il) {
                value = values[i];

                if (value && (isObject(value) || isFunction(value)) && isFunction(value.then)) {
                    value.then(resolve, reject);
                }
            }
        });
    };
}


module.exports = PromisePolyfill;


},
function(require, exports, module, global) {

var has = require(11),
    defineProperty = require(36),
    isPrimitive = require(42);


var emptyObject = {};


module.exports = createStore;


function privateStore(key, privateKey) {
    var store = {
            identity: privateKey
        },
        valueOf = key.valueOf;

    defineProperty(key, "valueOf", {
        value: function(value) {
            return value !== privateKey ? valueOf.apply(this, arguments) : store;
        },
        writable: true
    });

    return store;
}

function createStore() {
    var privateKey = {};

    function get(key) {
        if (isPrimitive(key)) {
            throw new TypeError("Invalid value used as key");
        }

        return key.valueOf(privateKey) || emptyObject;
    }

    function set(key) {
        var store;

        if (isPrimitive(key)) {
            throw new TypeError("Invalid value used as key");
        }

        store = key.valueOf(privateKey);

        if (!store || store.identity !== privateKey) {
            store = privateStore(key, privateKey);
        }

        return store;
    }

    return {
        get: function(key) {
            return get(key).value;
        },
        set: function(key, value) {
            set(key).value = value;
        },
        has: function(key) {
            return has(get(key), "value");
        },
        remove: function(key) {
            var store = get(key);
            return store === emptyObject ? false : delete store.value;
        },
        clear: function() {
            privateKey = {};
        }
    };
}


},
function(require, exports, module, global) {

var isNullOrUndefined = require(15);


module.exports = function isPrimitive(obj) {
    var typeStr;
    return isNullOrUndefined(obj) || ((typeStr = typeof(obj)) !== "object" && typeStr !== "function") || false;
};


},
function(require, exports, module, global) {

var isArray = require(25),
    rules = require(44),
    validations = require(55);


var validator = module.exports,
    slice = Array.prototype.slice;


validator.rules = rules;
validator.validations = validations;


validator.match = function(ruleName, data, args) {
    var rule = rules[ruleName],
        value, length;

    if (!rule) throw new Error("validator.match(ruleName, data, args) no ruled defined named " + ruleName);

    if (arguments.length > 2) {
        if (isArray(args)) {
            args = args.slice();
            args.unshift(data);
        } else {
            args = slice.call(arguments, 1);
        }
        length = args.length;

        if (length === 2) {
            value = rule.call(rules, args[0], args[1]);
        } else if (length === 3) {
            value = rule.call(rules, args[0], args[1], args[2]);
        } else if (length === 4) {
            value = rule.call(rules, args[0], args[1], args[2], args[3]);
        } else {
            value = rule.apply(rules, args);
        }
    } else {
        value = rules[ruleName](data);
    }

    if (!value) {
        return {
            rule: ruleName,
            data: data,
            args: args ? args.slice(1) : null
        };
    }

    return null;
};


},
function(require, exports, module, global) {

var Buffer = require(45).Buffer;
var isEmpty = require(49),
    isArray = require(25),
    isUndefined = require(51),
    isObject = require(13),
    isFunction = require(6),
    isString = require(23),
    isNumber = require(52),
    isFinitePolyfill = require(53),
    isNull = require(54),
    isBoolean = require(28),
    validations = require(55);


var rules = module.exports;


rules.type = function(str, typeStr) {
    var rule = rules[typeStr];
    return rule && isFunction(rule) ? rule(str) : false;
};

rules.empty = isEmpty;

rules.not_empty = rules.notempty = rules.notEmpty = function(obj) {
    if (!obj && obj !== 0) {
        obj = "";
    } else if (typeof(obj.toString) !== "undefined") {
        obj = obj.toString();
    } else {
        obj = "" + obj;
    }

    return !validations.isNull(obj);
};

rules.required = function(obj) {
    if (!obj && obj !== 0) {
        obj = "";
    } else if (typeof(obj.toString) !== "undefined") {
        obj = obj.toString();
    } else {
        obj = "" + obj;
    }

    return !validations.isNull(obj);
};

rules["undefined"] = isUndefined;

rules.object = isObject;

rules.json = function(obj) {
    if (obj === undefined || obj === null) return false;
    try {
        JSON.stringify(obj);
    } catch (e) {
        return false;
    }
    return true;
};

rules.text = isString;

rules.string = isString;

rules.alpha = validations.isAlpha;

rules.alpha_dashed = rules.alphadashed = rules.alphaDashed = validations.isAlphaDashed;

rules.numeric = validations.isNumeric;

rules.alpha_numeric = rules.alphanumeric = rules.alphaNumeric = validations.isAlphaNumeric;

rules.alpha_numeric_dashed = rules.alphanumericdashed = rules.alphaNumericDashed = validations.isAlphaNumericDashed;

rules.email = validations.isEmail;

rules.url = validations.isURL;

rules.urlish = validations.isURLish;

rules.ip = validations.isIP;

rules.ipv4 = validations.isIPv4;

rules.ipv6 = validations.isIPv6;

rules.credit_card = rules.creditcard = rules.creditCard = validations.isCreditCard;

rules.uuid = validations.isUUID;

rules.uuidv3 = function(obj) {
    return validations.isUUID(obj, 3);
};

rules.uuidv4 = function(obj) {
    return validations.isUUID(obj, 4);
};

rules["int"] = validations.isInt;

rules.integer = validations.isInt;

rules.number = isNumber;

rules.finite = isFinitePolyfill;

rules.decimal = validations.isFloat;

rules["float"] = validations.isFloat;

rules.falsey = function(obj) {
    return !obj;
};

rules.truthy = function(obj) {
    return !!obj;
};

rules["null"] = isNull;

rules.not_null = rules.notnull = rules.notNull = function(obj) {
    return !validations.isNull(obj);
};

rules.bool = rules["boolean"] = isBoolean;

rules.array = isArray;

rules.binary = function(obj) {
    return Buffer.isBuffer(obj) || isString(obj);
};

rules.date = validations.isDate;

rules.date_time = rules.datetime = validations.isDate;

rules.hexa_decimal = rules.hexadecimal = validations.isHexadecimal;

rules.hex_color = rules.hexcolor = validations.isHexColor;

rules.lowercase = validations.isLowercase;

rules.uppercase = validations.isUppercase;

rules.after = validations.isAfter;

rules.before = validations.isBefore;

rules.equals = validations.equals;

rules.contains = validations.contains;

rules.not_contains = rules.notcontains = rules.notContains = function(obj, str) {
    return !validations.contains(obj, str);
};

rules.length = rules.len = function(obj, min, max) {
    obj = validations.toString(obj);
    return obj.length >= min && (max != null ? obj.length <= max : true);
};

rules["in"] = validations.isIn;

rules.not_in = rules.notIn = function(str, options) {
    return !validations.isIn(str, options);
};

rules.max = function(str, num) {
    var number = parseFloat(str);
    return isNaN(number) || number <= num;
};

rules.min = function(str, num) {
    var number = parseFloat(str);
    return isNaN(number) || number >= num;
};

rules.greater_than = rules.greaterthan = rules.greaterThan = function(str, num) {
    var number = parseFloat(str);
    return isNaN(number) || number > num;
};

rules.less_than = rules.lessthan = rules.lessThan = function(str, num) {
    var number = parseFloat(str);
    return isNaN(number) || number < num;
};

rules.max_length = rules.maxlength = rules.maxLength = function(str, max) {
    return validations.isLength(str, 0, max);
};

rules.min_length = rules.minlength = rules.minLength = function(str, min) {
    return validations.isLength(str, min);
};

rules.regex = function(str, regex) {
    return validations.matches(str, regex);
};

rules.not_regex = rules.notregex = rules.notRegex = function(str, regex) {
    return !validations.matches(str, regex);
};


},
function(require, exports, module, global) {

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require(46)
var ieee754 = require(47)
var isArray = require(48)

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}


},
function(require, exports, module, global) {

var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))


},
function(require, exports, module, global) {

exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};


},
function(require, exports, module, global) {


/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};


},
function(require, exports, module, global) {

var isString = require(23),
    has = require(11),
    isArrayLike = require(50);


function isObjectEmpty(object) {
    var localHas = has,
        key;

    for (key in object) {
        if (localHas(object, key)) {
            return false;
        }
    }

    return true;
}

module.exports = function isEmpty(obj) {
    return (
        obj == null ? true : (
            isString(obj) || isArrayLike(obj) ? obj.length === 0 : isObjectEmpty(obj)
        )
    );
};


},
function(require, exports, module, global) {

var isLength = require(20),
    isObjectLike = require(19);


var objectToString = Object.prototype.toString,
    objectArrayBufferString = "[object ArrayBuffer]",
    arrayLikeStrings = {
        "[object Array]": true,
        "[object Arguments]": true,
        "[object Float32Array]": true,
        "[object Float64Array]": true,
        "[object Int8Array]": true,
        "[object Int16Array]": true,
        "[object Int32Array]": true,
        "[object Uint8Array]": true,
        "[object Uint8ClampedArray]": true,
        "[object Uint16Array]": true,
        "[object Uint32Array]": true
    };


arrayLikeStrings[objectArrayBufferString] = true;


module.exports = function isArrayLike(obj) {
    var isObject = isObjectLike(obj),
        objectString = isObject && objectToString.call(obj);

    return isObject && (
        objectString !== objectArrayBufferString ? (
            isLength(obj.length) && arrayLikeStrings[objectString]
        ) : true
    ) || false;
};


},
function(require, exports, module, global) {

module.exports = function isUndefined(obj) {
    return obj === void 0;
};


},
function(require, exports, module, global) {

module.exports = function isNumber(obj) {
    return typeof(obj) === "number" || false;
};


},
function(require, exports, module, global) {

module.exports = Number.isFinite || function isFinite(obj) {
    return !(
        typeof(obj) !== "number" ||
        (obj !== obj || obj === Infinity || obj === -Infinity) ||
        false
    );
};


},
function(require, exports, module, global) {

module.exports = function isNull(obj) {
    return obj === null;
};


},
function(require, exports, module, global) {

var mixin = require(14),
    isArray = require(25),
    isNaNPolyfill = require(56),
    isDate = require(57),
    isBoolean = require(28),
    isInteger = require(58),
    isDecimal = require(59),
    isRegExp = require(60),
    isNumber = require(52);


var validations = module.exports,

    EMAIL = /^((([a-z]|\d|[!#\$%&"\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&"\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
    URLISH = /^\s([^\/]+\.)+.+\s*$/g,

    CREDIT_CARD = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,

    ISBN_10_MAYBE = /^(?:[0-9]{9}X|[0-9]{10})$/,
    ISBN_13_MAYBE = /^(?:[0-9]{13})$/,

    IPv4_MAYBE = /^(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)$/,
    IPv6 = /^::|^::1|^([a-fA-F0-9]{1,4}::?){1,7}([a-fA-F0-9]{1,4})$/,

    ALPHA = /^[a-zA-Z]+$/,
    ALPHA_DASHED = /^[a-zA-Z-_]*$/,
    ALPHA_NUMERIC = /^[a-zA-Z0-9]+$/,
    ALPHA_NUMERIC_DASHED = /^[a-zA-Z0-9-_]*$/,
    NUMERIC = /^-?[0-9]+$/,
    INT = /^(?:-?(?:0|[1-9][0-9]*))$/,
    FLOAT = /^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/,
    HEXADECIMAL = /^[0-9a-fA-F]+$/,
    HEX_COLOR = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/,

    UUID = {
        "3": /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        "4": /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        "5": /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    },

    ASCII = /^[\x00-\x7F]+$/,
    MULTIBYTE = /[^\x00-\x7F]/,
    FULLWIDTH = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/,
    HALFWIDTH = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/,

    SURROGATE_PAIR = /[\uD800-\uDBFF][\uDC00-\uDFFF]/,
    SURROGATE_PAIRS = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,

    BASE_64 = /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/,

    SPACES = /[\s-]+/g,
    NOT_NUMBERS = /[^0-9]+/g;

validations.toString = function(obj) {
    if (typeof(obj) === "object" && obj !== null && obj.toString) {
        obj = obj.toString();
    } else if (obj === null || typeof(obj) === "undefined" || (isNaNPolyfill(obj) && !obj.length)) {
        obj = "";
    } else if (typeof(obj) !== "string") {
        obj += "";
    }

    return obj;
};

validations.toDate = function(date) {
    if (isDate(date)) return data;
    if (isNumber(date)) return new Date(date);
    date = Date.parse(date);
    return !isNaNPolyfill(date) ? new Date(date) : null;
};

validations.toFloat = function(str) {
    return typeof(str) === "number" ? str : parseFloat(str);
};

validations.toInt = function(str, radix) {
    return typeof(str) === "number" ? str : parseInt(str, radix || 10);
};

validations.toBoolean = function(str, strict) {
    if (isBoolean(str)) return !!str;
    if (strict) return str === "1" || str === "true";
    return str !== "0" && str !== "false" && str !== "";
};

validations.equals = function(str, comparison) {
    str = validations.toString(str);

    return str === validations.toString(comparison);
};

validations.contains = function(str, elem) {
    str = validations.toString(str);

    return str.indexOf(validations.toString(elem)) >= 0;
};

validations.matches = function(str, pattern, modifiers) {
    str = validations.toString(str);

    if (!isRegExp(pattern)) {
        pattern = new RegExp(pattern, modifiers);
    }
    return pattern.test(str);
};

validations.isEmail = function(str) {
    str = validations.toString(str);

    return EMAIL.test(str);
};

var defaultURLOptions = {
    protocols: ["http", "https", "ftp"],
    requireTLD: true,
    requireProtocol: false,
    allowUnderscores: false
};
validations.isURL = function(str, options) {
    str = validations.toString(str);

    if (!str || str.length >= 2083) {
        return false;
    }
    options = mixin(options || {}, defaultURLOptions);
    var separators = "-?-?" + (options.allowUnderscores ? "_?" : ""),
        url = new RegExp("^(?!mailto:)(?:(?:" + options.protocols.join("|") + ")://)" + (options.requireProtocol ? "" : "?") + "(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:www.)?)?(?:(?:[a-z\\u00a1-\\uffff0-9]+" + separators + ")*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+" + separators + ")*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" + (options.requireTLD ? "" : "?") + ")|localhost)(?::(\\d{1,5}))?(?:(?:/|\\?|#)[^\\s]*)?$", "i"),
        match = str.match(url),
        port = match ? match[1] : 0;

    return !!(match && (!port || (port > 0 && port <= 65535)));
};

validations.isURLish = function(str) {
    str = validations.toString(str);

    return URLISH.test(str);
};

validations.isIP = function(str, version) {
    str = validations.toString(str);

    version = validations.toString(version);
    var parts;

    if (!version) {
        return validations.isIP(str, 4) || validations.isIP(str, 6);
    } else if (version === "4") {
        if (!IPv4_MAYBE.test(str)) return false;
        parts = str.split(".").sort();
        return parts[3] <= 255;
    }

    return version === "6" && IPv6.test(str);
};

validations.isIPv4 = function(str) {
    return validations.isIP(str, 4);
};

validations.isIPv6 = function(str) {
    return validations.isIP(str, 6);
};

validations.isAlpha = function(str) {
    str = validations.toString(str);

    return ALPHA.test(str);
};

validations.isAlphaDashed = function(str) {
    str = validations.toString(str);

    return ALPHA_DASHED.test(str);
};

validations.isAlphaNumeric = function(str) {
    str = validations.toString(str);

    return ALPHA_NUMERIC.test(str);
};

validations.isAlphaNumericDashed = function(str) {
    str = validations.toString(str);

    return ALPHA_NUMERIC_DASHED.test(str);
};

validations.isNumeric = function(str) {
    str = validations.toString(str);

    return NUMERIC.test(str);
};

validations.isHexadecimal = function(str) {
    str = validations.toString(str);

    return HEXADECIMAL.test(str);
};

validations.isHexColor = function(str) {
    str = validations.toString(str);

    return HEX_COLOR.test(str);
};

validations.isLowercase = function(str) {

    return str === str.toLowerCase();
};

validations.isUppercase = function(str) {

    return str === str.toUpperCase();
};

validations.isInt = function(str) {

    return isInteger(str) || INT.test(validations.toString(str));
};

validations.isFloat = function(str) {

    return isDecimal(str) || FLOAT.test(validations.toString(str));
};

validations.isDivisibleBy = function(str, num) {
    if (isString(str)) {
        str = validations.toFloat(str);
    }

    return str % validations.toInt(num) === 0;
};

validations.isNull = function(str) {

    return validations.toString(str).length === 0;
};

validations.isLength = function(str, min, max) {
    str = validations.toString(str);
    var surrogatePairs = str.match(SURROGATE_PAIRS) || [],
        len = str.length - surrogatePairs.length;

    return len >= min && (typeof(max) === "undefined" || len <= max);
};

validations.isByteLength = function(str, min, max) {
    str = validations.toString(str);

    return str.length >= min && (typeof(max) === "undefined" || str.length <= max);
};

validations.isUUID = function(str, version) {
    var pattern = UUID[version ? version : "all"];

    return pattern && pattern.test(validations.toString(str));
};

validations.isDate = function(str) {
    str = validations.toString(str);

    return !isNaNPolyfill(Date.parse(str));
};

validations.isAfter = function(str, date) {
    var comparison = validations.toDate(date || new Date()),
        original = validations.toDate(validations.toString(str));

    return !!(original && comparison && original > comparison);
};

validations.isBefore = function(str, date) {
    var comparison = validations.toDate(date || new Date()),
        original = validations.toDate(validations.toString(str));

    return original && comparison && original < comparison;
};

validations.isIn = function(str, options) {
    var i, array = options;

    if (!options || typeof(options.indexOf) !== "function") {
        return false;
    }
    if (isArray(options)) {
        i = options.length;
        array = [];

        while (i--) array.push(options[i]);
    }

    return array.indexOf(validations.toString(str)) !== -1;
};

validations.isCreditCard = function(str) {
    str = validations.toString(str);
    var sanitized = str.replace(NOT_NUMBERS, ""),
        sum = 0,
        digit, tmpNum, shouldDouble,
        i;

    if (!CREDIT_CARD.test(sanitized)) return false;

    for (i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, (i + 1));
        tmpNum = parseInt(digit, 10);

        if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
                sum += ((tmpNum % 10) + 1);
            } else {
                sum += tmpNum;
            }
        } else {
            sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
    }
    return !!((sum % 10) === 0 ? sanitized : false);
};

validations.isISBN = function(str, version) {
    str = validations.toString(str);

    version = validations.toString(version);
    if (!version) return validations.isISBN(str, 10) || validations.isISBN(str, 13);

    var sanitized = str.replace(SPACES, ""),
        checksum = 0,
        i, factor;

    if (version === "10") {
        if (!ISBN_10_MAYBE.test(sanitized)) {
            return false;
        }
        for (i = 0; i < 9; i++) {
            checksum += (i + 1) * sanitized[i];
        }
        if (sanitized[9] === "X") {
            checksum += 10 * 10;
        } else {
            checksum += 10 * sanitized[9];
        }
        if ((checksum % 11) === 0) {
            return !!sanitized;
        }
    } else if (version === "13") {
        if (!ISBN_13_MAYBE.test(sanitized)) {
            return false;
        }
        factor = [1, 3];
        for (i = 0; i < 12; i++) {
            checksum += factor[i % 2] * sanitized[i];
        }
        if (sanitized[12] - ((10 - (checksum % 10)) % 10) === 0) {
            return !!sanitized;
        }
    }
    return false;
};

validations.isJSON = function(str) {
    str = validations.toString(str);

    try {
        JSON.parse(str);
    } catch (e) {
        return false;
    }
    return true;
};

validations.isMultibyte = function(str) {
    str = validations.toString(str);

    return MULTIBYTE.test(str);
};

validations.isAscii = function(str) {
    str = validations.toString(str);

    return ASCII.test(str);
};

validations.isFullWidth = function(str) {
    str = validations.toString(str);

    return FULLWIDTH.test(str);
};

validations.isHalfWidth = function(str) {
    str = validations.toString(str);

    return HALFWIDTH.test(str);
};

validations.isVariableWidth = function(str) {
    str = validations.toString(str);

    return FULLWIDTH.test(str) && HALFWIDTH.test(str);
};

validations.isSurrogatePair = function(str) {
    str = validations.toString(str);

    return SURROGATE_PAIR.test(str);
};

validations.isBase64 = function(str) {
    str = validations.toString(str);

    return BASE_64.test(str);
};


},
function(require, exports, module, global) {

var isNumber = require(52);


module.exports = Number.isNaN || function isNaN(obj) {
    return isNumber(obj) && obj !== obj;
};


},
function(require, exports, module, global) {

var isObjectLike = require(19);


var objectDateStr = "[object Date]",
    objectToString = Object.prototype.toString;


module.exports = function isDate(obj) {
    return (isObjectLike(obj) && objectToString.call(obj) === objectDateStr) || false;
};


},
function(require, exports, module, global) {

var isNumber = require(52);


module.exports = function isInteger(obj) {
    return isNumber(obj) && obj % 1 === 0;
};


},
function(require, exports, module, global) {

var isNumber = require(52);


module.exports = function isDecimal(obj) {
    return isNumber(obj) && obj % 1 !== 0;
};


},
function(require, exports, module, global) {

var isObjectLike = require(19);


var objectRegExpStr = "[object RegExp]",
    objectToString = Object.prototype.toString;


module.exports = function isRegExp(obj) {
    return (isObjectLike(obj) && objectToString.call(obj) === objectRegExpStr) || false;
};


},
function(require, exports, module, global) {

var PromisePolyfill = require(40),
    extend = require(9);


function Query(model, action, conditions) {

    this._model = model;
    this._action = action;

    this._currentKey = false;

    this._conditions = extend({}, conditions.where);

    delete conditions.where;
    this._params = conditions;
}

Query.prototype.where = function(key, value) {

    if (value === undefined) {
        this._currentKey = key;
    } else {
        this._conditions[key] = value;
        this._currentKey = false;
    }

    return this;
};

Query.prototype.range = function(key, from, to) {
    var currentKey = this._currentKey,
        conditions = this._conditions,
        condition;

    if (currentKey === false && to === undefined) {
        throw new Error("Query.range(from, to) no key is currently selected");
    }

    if (to === undefined) {
        if (currentKey !== false) {
            to = from;
            from = key;
            condition = conditions[currentKey] || (conditions[currentKey] = {});

            condition.gt = from;
            condition.lt = to;
        }
    } else {
        this._currentKey = false;

        condition = conditions[key] || (conditions[key] = {});

        condition.gt = from;
        condition.lt = to;
    }
    return this;
};

Query.prototype.between = Query.prototype.range;

["gt", "gte", "lt", "lte", "in", "inq", "ne", "neq", "nin"].forEach(function(method) {
    Query.prototype[method] = function(key, value) {
        var conditions = this._conditions,
            currentKey = this._currentKey;

        if (currentKey === false && value === undefined) {
            throw new Error("Query." + method + "(value) no key is currently selected");
        }

        if (value === undefined) {
            if (currentKey !== false) {
                (conditions[currentKey] || (conditions[currentKey] = {}))[method] = key;
            }
        } else {
            (conditions[key] || (conditions[key] = {}))[method] = value;
            this._currentKey = false;
        }

        return this;
    };
});

var NEGATIVE = /^-/;
Query.prototype.order = function(key, value) {
    var params = this._params,
        param;

    this._currentKey = false;

    if (key === undefined && value === undefined) {
        throw new Error("Query.order(key, value) key and value, or key required");
    }

    if (value === undefined) {
        param = params.order || (params.order = []);

        if (NEGATIVE.test(key)) {
            param[0] = key.replace(NEGATIVE, "");
            param[1] = "DESC";
        } else {
            param[0] = key;
            param[1] = "ASC";
        }
    } else {
        param = params.order || (params.order = []);
        param[0] = key;
        param[1] = value.toUpperCase();
    }
    return this;
};
Query.prototype.sort = Query.prototype.order;

["skip", "limit"].forEach(function(method) {
    Query.prototype[method] = function(value) {
        this._currentKey = false;

        if (value === undefined) {
            throw new Error("Query." + method + "(value) value required");
        }

        this._params[method] = value;
        return this;
    };
});

Query.prototype.asc = function(value) {
    var params = this._params,
        param = params.order || (params.order = []);

    this._currentKey = false;
    param[0] = value;
    param[1] = "ASC";

    return this;
};

Query.prototype.desc = function(value) {
    var params = this._params,
        param = params.order || (params.order = []);

    this._currentKey = false;
    param[0] = value;
    param[1] = "DESC";

    return this;
};

Query.prototype.exec = function(callback) {
    var query = extend({
        where: extend({}, this._conditions)
    }, this._params);

    this._model[this._action](query, callback);
};

Query.prototype.run = Query.prototype.exec;

Query.prototype.then = function(onFulfill, onReject) {
    var defer = PromisePolyfill.defer(),
        query = extend({
            where: extend({}, this._conditions)
        }, this._params);

    this._model[this._action](query, function(err, result) {
        if (err) {
            defer.reject(err);
            return;
        }

        defer.resolve(result);
    });

    return defer.promise.then(onFulfill, onReject);
};


module.exports = Query;


},
function(require, exports, module, global) {

var hooks = module.exports;


hooks.timestamps = function(options) {
    var underscore = options.underscore === true || options.camelcase === false;

    return {
        events: {
            beforeCreate: function(values, next) {
                if (underscore) {
                    values.created_at = new Date();
                    values.updated_at = new Date();
                } else {
                    values.createdAt = new Date();
                    values.updatedAt = new Date();
                }
                next();
            },
            beforeSave: function(values, next) {
                if (underscore) {
                    if (values.created_at == null) {
                        values.created_at = new Date();
                    }
                    if (values.updated_at == null) {
                        values.updated_at = new Date();
                    }
                } else {
                    if (values.createdAt == null) {
                        values.createdAt = new Date();
                    }
                    if (values.updatedAt == null) {
                        values.updatedAt = new Date();
                    }
                }
                next();
            },
            beforeUpdate: function(values, next) {
                if (underscore) {
                    values.updated_at = new Date();
                } else {
                    values.updatedAt = new Date();
                }
                next();
            }
        }
    };
};


},
function(require, exports, module, global) {

var process = require(1);
var keys = require(10),
    indexOf = require(24),
    extend = require(9),
    isDate = require(57),
    isObject = require(13),
    forEach = require(17),
    map = require(64);


function buildSort(columns, key, order) {
    var typeStr = columns[key].type;

    if (typeStr === "float" || typeStr === "integer") {
        return (
            order === "ASC" ?
            function sortNumber(a, b) {
                return a[key] - b[key];
            } :
            function sortNumber(a, b) {
                return b[key] - a[key];
            }
        );
    } else if (typeStr === "string") {
        return (
            order === "ASC" ?
            function sortString(a, b) {
                return a[key] < b[key] ? -1 : 1;
            } :
            function sortString(a, b) {
                return a[key] < b[key] ? 1 : -1;
            }
        );
    } else if (typeStr === "datetime") {
        return (
            order === "ASC" ?
            function sortDate(a, b) {
                return Date.parse(a[key]) < Date.parse(b[key]) ? -1 : 1;
            } :
            function sortDate(a, b) {
                return Date.parse(a[key]) < Date.parse(b[key]) ? 1 : -1;
            }
        );
    } else {
        return false;
    }
}

function queryAll(columns, array, query) {
    var i = (query.skip || 0) - 1,
        il = array.length,

        where = query.where,
        objectKeys = keys(where),
        length = objectKeys.length,

        results = [],
        k = 0,

        limit = +query.limit,
        order = query.order,

        item, pass, j, key, sortFn;

    while (++i < il) {
        item = array[i];
        pass = true;

        j = length;
        while (j-- && pass) {
            key = objectKeys[j];
            pass = compare(columns[key], item[key], where[key]);
        }

        if (pass) {
            results[k++] = item;
            if (limit > -1 && k >= limit) {
                break;
            }
        }
    }

    if (order) {
        sortFn = buildSort(columns, order[0], order[1]);

        if (sortFn) {
            results.sort(sortFn);
        }
    }

    return results;
}

function queryOne(columns, array, query) {
    var i = (query.skip || 0) - 1,
        il = array.length,

        where = query.where,
        objectKeys = keys(where),
        length = objectKeys.length,

        item, pass, j, key;

    while (++i < il) {
        item = array[i];
        pass = true;

        j = length;
        while (j-- && pass) {
            key = objectKeys[j];
            pass = compare(columns[key], item[key], where[key]);
        }

        if (pass) {
            return item;
        }
    }

    return null;
}

function isUnique(array, key, value, id) {
    var i = array.length,
        row;

    while (i--) {
        row = array[i];
        if (row[key] === value && (id ? row.id !== id : true)) {
            return false;
        }
    }
    return true;
}

function compare(column, value, whereValue) {
    var columnType = column.type,
        key;

    if (isObject(whereValue)) {
        var pass = true;

        for (key in whereValue) {
            if (columnType === "datetime") {
                pass = conditions[key](Date.parse(value), Date.parse(whereValue[key]));
            } else {
                pass = conditions[key](value, whereValue[key]);
            }
        }

        return pass;
    }

    return value === whereValue;
}

var conditions = {
    gt: function(a, b) {
        return a > b;
    },
    gte: function(a, b) {
        return a >= b;
    },
    lt: function(a, b) {
        return a < b;
    },
    lte: function(a, b) {
        return a <= b;
    },
    "in": function(a, b) {
        return indexOf(b, a) !== -1;
    },
    inq: function(a, b) {
        return indexOf(b, a) !== -1;
    },
    ne: function(a, b) {
        return a !== b;
    },
    neq: function(a, b) {
        return a !== b;
    },
    nin: function(a, b) {
        return indexOf(b, a) === -1;
    }
};


function MemoryAdapter() {

    this._collection = null;
    this._tables = {};
}

MemoryAdapter.prototype.init = function(callback) {
    var tables = this._tables,
        collection = this._collection,
        schema = collection && collection._schema;

    process.nextTick(function() {
        if (schema) {
            forEach(schema.tables, function(tableSchema, tableName) {
                var counters = {},
                    uniques = {};

                forEach(tableSchema.columns, function(column, columnName) {
                    forEach(column, function(value, key) {
                        if (key === "autoIncrement") {
                            counters[columnName] = 1;
                        } else if (key === "unique") {
                            uniques[columnName] = true;
                        }
                    });
                });

                tables[tableName] = {
                    counters: counters,
                    uniques: uniques,
                    schema: tableSchema,
                    rows: []
                };
            });
        }

        callback();
    });
    return this;
};

MemoryAdapter.prototype.close = function() {

    return this;
};

MemoryAdapter.prototype.save = function(tableName, params, callback) {
    var table = this._tables[tableName],
        columns = table.schema.columns;

    process.nextTick(function() {
        var counters = table.counters,
            rows = table.rows,
            row = {},
            err;

        forEach(table.uniques, function(_, key) {
            if (isUnique(rows, key, params[key]) === false) {
                err = new Error(
                    "MemoryAdapter save(tableName, params, callback) table " + tableName + " already has a row where " + key + " = " + params[key]
                );
                return false;
            }
            return true;
        });

        if (err) {
            callback(err);
            return;
        }

        forEach(counters, function(counter, key) {
            params[key] = counters[key] ++;
        });

        forEach(table.schema._keys, function(key) {
            var value = params[key],
                columnType = columns[key].type;

            if (value == null) {
                row[key] = null;
            } else {
                if (columnType === "datetime") {
                    row[key] = isDate(value) ? value.toJSON() : (new Date(value).toJSON());
                } else {
                    row[key] = value;
                }
            }
        });

        rows.push(row);
        callback(undefined, row);
    });
    return this;
};

MemoryAdapter.prototype.update = function(tableName, id, params, callback) {
    var table = this._tables[tableName],
        columns = table.schema.columns;

    process.nextTick(function() {
        var rows = table.rows,
            row = queryOne(columns, rows, {
                where: {
                    id: id
                }
            }),
            err;

        if (!row) {
            callback(new Error("MemoryAdapter update(tableName, id, params, callback) no row found where id=" + id));
            return;
        }

        forEach(table.uniques, function(_, key) {
            if (isUnique(rows, key, params[key], id) === false) {
                err = new Error(
                    "MemoryAdapter update(tableName, id, params, callback) table " + tableName + " already has a row where " + key + " = " + params[key]
                );
                return false;
            }
            return true;
        });

        if (err) {
            callback(err);
            return;
        }

        forEach(table.schema._keys, function(key) {
            var value = params[key];

            if (value != null) {
                if (columns[key].type === "datetime") {
                    row[key] = isDate(value) ? value.toJSON() : (new Date(value).toJSON());
                } else {
                    row[key] = value;
                }
            }
        });

        callback(undefined, extend({}, row));
    });
    return this;
};

MemoryAdapter.prototype.find = function(tableName, query, callback) {
    var table = this._tables[tableName];

    process.nextTick(function() {
        var rows = queryAll(table.schema.columns, table.rows, query);

        callback(undefined, map(rows, function(row) {
            return extend({}, row);
        }));
    });
    return this;
};

MemoryAdapter.prototype.findOne = function(tableName, query, callback) {
    var table = this._tables[tableName];

    process.nextTick(function() {
        var row = queryOne(table.schema.columns, table.rows, query);

        callback(undefined, extend({}, row));
    });
    return this;
};

MemoryAdapter.prototype.destroy = function(tableName, query, callback) {
    var table = this._tables[tableName];

    process.nextTick(function() {
        var rows = table.rows,
            results = queryAll(table.schema.columns, rows, query),
            i = results.length,
            out, row;

        if (!i) {
            callback(new Error("MemoryAdapter destroy(tableName, query, callback) no rows found with query " + JSON.stringify(query)));
            return;
        }

        out = [];

        while (i--) {
            row = results[i];
            rows.splice(indexOf(rows, row), 1);

            out.push(extend({}, row));
        }

        callback(undefined, out);
    });
    return this;
};

MemoryAdapter.prototype.createTable = function(tableName, columns, options, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.renameTable = function(tableName, newTableName, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.removeTable = function(tableName, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.addColumn = function(tableName, columnName, column, options, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.renameColumn = function(tableName, columnName, newColumnName, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.removeColumn = function(tableName, columnName, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.createIndex = function(tableName, columnName, options, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.removeIndex = function(tableName, columnName, options, callback) {

    process.nextTick(callback);
    return this;
};

MemoryAdapter.prototype.removeDatabase = function(callback) {

    process.nextTick(callback);
    return this;
};


module.exports = MemoryAdapter;


},
function(require, exports, module, global) {

var keys = require(10),
    isNullOrUndefined = require(15),
    fastBindThis = require(18),
    isObjectLike = require(19),
    isLength = require(20);


function mapArray(array, callback) {
    var length = array.length,
        i = -1,
        il = length - 1,
        result = new Array(length);

    while (i++ < il) {
        result[i] = callback(array[i], i);
    }

    return result;
}

function mapObject(object, callback) {
    var objectKeys = keys(object),
        i = -1,
        il = objectKeys.length - 1,
        result = {},
        key;

    while (i++ < il) {
        key = objectKeys[i];
        result[key] = callback(object[key], key);
    }

    return result;
}

module.exports = function map(object, callback, thisArg) {
    callback = isNullOrUndefined(thisArg) ? callback : fastBindThis(callback, thisArg, 2);
    return (isObjectLike(object) && isLength(object.length)) ? mapArray(object, callback) : mapObject(object, callback);
};


},
function(require, exports, module, global) {

var orm = require(3);


var SPLITER = /[\s ]+/;


var User = new orm.define({
    name: "User",

    schema: {
        firstName: "string",
        lastName: "string",
        age: "integer",
        email: {
            type: "string",
            unique: true
        },
        password: "string"
    }
});

User.accessible(
    "firstName",
    "lastName",
    "age",
    "email"
);

Object.defineProperty(User.prototype, "fullName", {
    get: function() {
        return this.firstName + " " + this.lastName;
    },
    set: function(value) {
        var split = (value || "").split(SPLITER);

        this.firstName = split[0] || this.firstName;
        this.lastName = split[1] || this.lastName;
    }
});

User.validates("email")
    .required()
    .email();

User.validates("password")
    .required()
    .minLength(6);

User.on("init", function(next) {
    var Cart = require(66);

    function encryptPassword(model, next) {
        model.password = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        next();
    }

    User.on("beforeCreate", encryptPassword);
    User.on("beforeSave", encryptPassword);

    User.on("destroy", function(users, next) {
        users.forEach(function(user) {
            Cart.destroy({
                where: {
                    userId: user.id
                }
            }, function(err) {
                if (err) {
                    next(err);
                    return;
                }
            });
        });
    });

    next();
});


module.exports = User;


},
function(require, exports, module, global) {

var orm = require(3);


var Cart = new orm.define({
    name: "Cart",

    schema: {
        title: "string",
        content: "string",
        belongsTo: "user"
    }
});

Cart.accessible(
    "title",
    "content",
    "userId"
);


module.exports = Cart;


},
function(require, exports, module, global) {

var orm = require(3);


var Item = new orm.define({
    name: "Item",

    schema: {
        title: "string",
        content: "string",
        json: "json",
        belongsTo: ["user", "cart"]
    }
});

Item.accessible(
    "title",
    "content",
    "json"
);


module.exports = Item;


},
function(require, exports, module, global) {




},
function(require, exports, module, global) {

module.exports = function seed(callback) {
    var collection = require(2),

        User = collection.models.User,
        Cart = collection.models.Cart,
        Item = collection.models.Item,

        length = 0,
        done = false;

    function createCallback() {
        length++;

        return function doneCallback(err) {
            if (done === true) {
                return;
            }
            if (err || --length <= 0) {
                done = true;
                callback(err);
                console.timeEnd("seed");
            }
        };
    }

    User.create({
        firstName: "Bob",
        lastName: "Smile",
        age: 64,
        password: "bobsmile",
        email: "bobsmile@bob.com"
    }, createCallback());

    User.create({
        firstName: "Nathan",
        lastName: "Faucett",
        age: 21,
        password: "nathanfaucett",
        email: "nathanfaucett@gmail.com"
    }, createCallback());

    User.create({
        firstName: "Sue",
        lastName: "Frank",
        age: 36,
        password: "suefrank",
        email: "suefrank@yahoo.com"
    }, createCallback());


    Cart.create({
        userId: 1,
        title: "Fun cart",
        content: "nothing like this"
    }, createCallback());

    Cart.create({
        userId: 1,
        title: "Other Fun cart",
        content: "there is something like this"
    }, createCallback());


    Cart.create({
        userId: 2,
        title: "My cart",
        content: "its alright"
    }, createCallback());

    Cart.create({
        userId: 2,
        title: "This Cart is Great!",
        content: "Maybe?"
    }, createCallback());


    Cart.create({
        userId: 3,
        title: "Cart",
        content: "big stuff"
    }, createCallback());

    Cart.create({
        userId: 3,
        title: "Cart of Great",
        content: "has many good times"
    }, createCallback());


    Item.create({
        cartId: 1,
        userId: 2,
        title: "My item",
        content: "its alright",
        json: {
            name: "bob"
        }
    }, createCallback());

    Item.create({
        cartId: 1,
        userId: 2,
        title: "This Item is Great!",
        content: "Maybe?",
        json: {
            name: "bob"
        }
    }, createCallback());
};


}], (new Function("return this;"))()));
