(function(dependencies, global) {
    var cache = [];

    function require(path) {
        var module = cache[path],
            callback, exports;

        if (module === undefined) {
            callback = dependencies[path];
            exports = {};

            cache[path] = module = {
                exports: exports,
                require: require
            };

            callback.call(exports, require, exports, module, global);
        }

        return module.exports;
    }

    require.resolve = function(path) {
        return path;
    };

    if (typeof(define) === "function" && define.amd) {
        define([], function() {
            return require(0);
        });
    } else if (typeof(module) !== "undefined" && module.exports) {
        module.exports = require(0);
    } else {

        require(0);

    }
}([
    function(require, exports, module, global) {

        var process = require(1);
        global.collection = require(2);


        global.User = collection.models.User;
        global.Cart = collection.models.Cart;
        global.Item = collection.models.Item;

        if (!process.browser) {
            var Adapter = require(68),
                adapter = new Adapter({
                    database: "test"
                });

            collection.bindAdapter("mongodb", adapter);

            User.adapter = "mongodb";
            Cart.adapter = "mongodb";
        }

        global.User_test = function(callback) {
            console.time("User.test");
            User.find(function(err, users) {
                console.timeEnd("User.test");
                if (err) {
                    callback && callback();
                    console.warn(err);
                    return;
                }
                callback && callback();
                console.log(users);
            });
        };

        global.Cart_test = function(callback) {
            console.time("Cart.test");
            Cart.find(function(err, carts) {
                console.timeEnd("Cart.test");
                if (err) {
                    callback && callback();
                    console.warn(err);
                    return;
                }
                callback && callback();
                console.log(carts);
            });
        };

        global.Item_test = function(callback) {
            console.time("Item.test");
            Item.find(function(err, items) {
                console.timeEnd("Item.test");
                if (err) {
                    callback && callback();
                    console.warn(err);
                    return;
                }
                callback && callback();
                console.log(items);
            });
        };

        global.seed = function() {
            console.time("seed");
            require(89)(function(err) {
                console.timeEnd("seed");
                if (err) {
                    console.log(err);
                }
            });
        };


        collection.init(function(err) {
            if (err) {
                console.log(err);
                return;
            }

            if (!process.browser) {
                User_test(function() {
                    Cart_test(Item_test);
                });
            } else {
                require(89)(function(err) {
                    if (err) {
                        console.log(err);
                        return;
                    }

                    User_test(function() {
                        Cart_test(Item_test);
                    });
                });
            }
        });


    },
    function(require, exports, module, global) {

        // shim for using process in browser

        var process = module.exports = {};

        process.nextTick = (function() {
            var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
            var canMutationObserver = typeof window !== 'undefined' && window.MutationObserver;
            var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;

            if (canSetImmediate) {
                return function(f) {
                    return window.setImmediate(f)
                };
            }

            var queue = [];

            if (canMutationObserver) {
                var hiddenDiv = document.createElement("div");
                var observer = new MutationObserver(function() {
                    var queueList = queue.slice();
                    queue.length = 0;
                    queueList.forEach(function(fn) {
                        fn();
                    });
                });

                observer.observe(hiddenDiv, {
                    attributes: true
                });

                return function nextTick(fn) {
                    if (!queue.length) {
                        hiddenDiv.setAttribute('yes', 'no');
                    }
                    queue.push(fn);
                };
            }

            if (canPost) {
                window.addEventListener('message', function(ev) {
                    var source = ev.source;
                    if ((source === window || source === null) && ev.data === 'process-tick') {
                        ev.stopPropagation();
                        if (queue.length > 0) {
                            var fn = queue.shift();
                            fn();
                        }
                    }
                }, true);

                return function nextTick(fn) {
                    queue.push(fn);
                    window.postMessage('process-tick', '*');
                };
            }

            return function nextTick(fn) {
                setTimeout(fn, 0);
            };
        })();

        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;

        process.binding = function(name) {
            throw new Error('process.binding is not supported');
        };

        // TODO(shtylman)
        process.cwd = function() {
            return '/'
        };
        process.chdir = function(dir) {
            throw new Error('process.chdir is not supported');
        };


    },
    function(require, exports, module, global) {

        var orm = require(3);


        module.exports = orm({
            schema: {
                timestamps: {
                    underscore: false
                }
            },
            defaultAdapter: "memory",
            adapters: {
                "memory": new orm.MemoryAdapter()
            }
        })

        .bindModels(
            require(65),
            require(66),
            require(67)
        );


    },
    function(require, exports, module, global) {

        var Collection = require(4),
            Model = require(38);


        function orm(options) {

            return new Collection(options);
        }

        orm.define = function define(options) {

            return new Model(options);
        };


        orm.hooks = require(62);
        orm.functions = require(26);

        orm.MemoryAdapter = require(63);


        module.exports = orm;


    },
    function(require, exports, module, global) {

        var process = require(1);
        var EventEmitter = require(5),
            isObject = require(13),
            forEach = require(17),
            keys = require(10),

            Schema = require(21),
            Model = require(38);


        function Collection(opts) {
            var options = {};

            opts || (opts = {});

            options.schema = opts.schema;
            options.adapters = opts.adapters;
            options.defaultAdapter = opts.defaultAdapter || keys(opts.adapters)[0];

            EventEmitter.call(this);

            this._options = options;
            this._schema = new Schema(options.schema);

            this._adapters = {};
            this._modelHash = {};

            this.models = {};

            if (isObject(options.adapters)) {
                this.bindAdapters(options.adapters);
            }
        }
        EventEmitter.extend(Collection);

        Collection.prototype.init = function(callback) {
            var length = 0,
                called = false;

            function createCallback() {
                length++;

                return function done(err) {
                    if (called === true) {
                        return;
                    }

                    if (err || --length === 0) {
                        called = true;
                        callback(err);
                    }
                };
            }

            this._schema.init();

            forEach(this.models, function(model) {
                var callback = createCallback();

                process.nextTick(function() {
                    model.init(callback);
                });
            });

            forEach(this._adapters, function(adapter) {
                var callback = createCallback();

                process.nextTick(function() {
                    adapter.init(callback);
                });
            });

            return this;
        };

        Collection.prototype.close = function() {

            forEach(this._adapters, function(adapter) {

                adapter.close();
            });
            return this;
        };

        Collection.prototype.adapter = function(name) {
            var adapter = this._adapters[name];

            if (!adapter) {
                throw new Error(
                    "Collection.adapter(name)\n" +
                    "    no adapter bound to collection found with tableName or className " + name
                );
            }

            return adapter;
        };

        Collection.prototype.bindAdapter = function(name, adapter) {

            Collection_bindAdapter(this, name, adapter);
            return this;
        };

        Collection.prototype.bindAdapters = function(adapters) {
            var _this = this;

            if (!isObject(adapters)) {
                throw new Error(
                    "Collection.bindAdapters(adapters)\n" +
                    "    adapters must be a Object ex {'memory': new MemoryAdapter(), 'mysql': new MySQLAdapter()}"
                );
            }

            forEach(adapters, function(adapter, name) {

                Collection_bindAdapter(_this, name, adapter);
            });
            return this;
        };

        function Collection_bindAdapter(_this, name, adapter) {
            var adapters = _this._adapters;

            if (!adapters[name] && !adapter._collection) {
                adapter._collection = _this;
                adapters[name] = adapter;
            } else {
                throw new Error(
                    "Collection.bind(adapter)\n" +
                    "    adapter " + adapter._className + " already bound to collection"
                );
            }
        }

        Collection.prototype.model = function(name) {
            var model = this._modelHash[name];

            if (!model) {
                throw new Error(
                    "Collection.model(name)\n" +
                    "    no model bound to collection found with tableName or className " + name
                );
            }

            return model;
        };

        Collection.prototype.bindModel = function(model) {

            Collection_bindModel(this, model);
            return this;
        };

        Collection.prototype.bindModels = function() {
            var i = arguments.length,
                model;

            while (i--) {
                model = arguments[i];

                if (!(model instanceof Model)) {
                    throw new Error(
                        "Collection.bind(model [, model..])\n" +
                        "    model is not an instance of Model"
                    );
                }

                Collection_bindModel(this, model);
            }
            return this;
        };

        function Collection_bindModel(_this, model) {
            var models = _this.models,
                modelHash = _this._modelHash,

                className = model.className,
                tableName = model.tableName;

            if (!modelHash[tableName] && !modelHash[className] && !model._collection) {
                _this._schema.add(model._schema);

                model._collection = _this;
                models[className] = modelHash[tableName] = modelHash[className] = model;
            } else {
                throw new Error(
                    "Collection.bind(model)\n" +
                    "    model " + model._className + " already bound to collection"
                );
            }
        }


        module.exports = Collection;


    },
    function(require, exports, module, global) {

        var isFunction = require(6),
            inherits = require(7),
            fastSlice = require(16),
            keys = require(10);


        function EventEmitter(maxListeners) {

            this.__events = {};
            this.__maxListeners = maxListeners != null ? maxListeners : EventEmitter.defaultMaxListeners;
        }

        EventEmitter.prototype.on = function(name, listener) {
            var events, eventList, maxListeners;

            if (!isFunction(listener)) {
                throw new TypeError("EventEmitter.on(name, listener) listener must be a function");
            }

            events = this.__events || (this.__events = {});
            eventList = (events[name] || (events[name] = []));
            maxListeners = this.__maxListeners || -1;

            eventList[eventList.length] = listener;

            if (maxListeners !== -1 && eventList.length > maxListeners) {
                console.error("EventEmitter.on(type, listener) possible EventEmitter memory leak detected. " + maxListeners + " listeners added");
            }

            return this;
        };

        EventEmitter.prototype.addListener = EventEmitter.prototype.on;

        EventEmitter.prototype.once = function(name, listener) {
            var _this = this;

            function once() {
                var length = arguments.length;

                _this.off(name, once);

                if (length === 0) {
                    return listener();
                } else if (length === 1) {
                    return listener(arguments[0]);
                } else if (length === 2) {
                    return listener(arguments[0], arguments[1]);
                } else if (length === 3) {
                    return listener(arguments[0], arguments[1], arguments[2]);
                } else if (length === 4) {
                    return listener(arguments[0], arguments[1], arguments[2], arguments[3]);
                } else {
                    return listener.apply(null, arguments);
                }
            }

            this.on(name, once);

            return once;
        };

        EventEmitter.prototype.listenTo = function(obj, name) {
            var _this = this;

            if (!(type.isFunction(obj.on) || type.isFunction(obj.addListener))) {
                throw new TypeError("EventEmitter.listenTo(obj, name) obj must have a on function taking (name, listener[, ctx])");
            }

            function handler() {
                _this.emitArgs(name, arguments);
            }

            obj.on(name, handler);

            return handler;
        };

        EventEmitter.prototype.off = function(name, listener) {
            var events = this.__events || (this.__events = {}),
                eventList, event, i;

            eventList = events[name];
            if (!eventList) {
                return this;
            }

            if (!listener) {
                i = eventList.length;

                while (i--) {
                    this.emit("removeListener", name, eventList[i]);
                }
                eventList.length = 0;
                delete events[name];
            } else {
                i = eventList.length;

                while (i--) {
                    event = eventList[i];

                    if (event === listener) {
                        this.emit("removeListener", name, event);
                        eventList.splice(i, 1);
                    }
                }

                if (eventList.length === 0) {
                    delete events[name];
                }
            }

            return this;
        };

        EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

        EventEmitter.prototype.removeAllListeners = function() {
            var events = this.__events || (this.__events = {}),
                objectKeys = keys(events),
                i = -1,
                il = objectKeys.length - 1,
                key, eventList, j;

            while (i++ < il) {
                key = objectKeys[i];
                eventList = events[key];

                if (eventList) {
                    j = eventList.length;

                    while (j--) {
                        this.emit("removeListener", key, eventList[j]);
                        eventList.splice(j, 1);
                    }
                }

                delete events[key];
            }

            return this;
        };

        function emit(eventList, args) {
            var a1, a2, a3, a4,
                length = eventList.length - 1,
                i = -1,
                event;

            switch (args.length) {
                case 0:
                    while (i++ < length) {
                        (event = eventList[i]) && event();
                    }
                    break;
                case 1:
                    a1 = args[0];
                    while (i++ < length) {
                        (event = eventList[i]) && event(a1);
                    }
                    break;
                case 2:
                    a1 = args[0];
                    a2 = args[1];
                    while (i++ < length) {
                        (event = eventList[i]) && event(a1, a2);
                    }
                    break;
                case 3:
                    a1 = args[0];
                    a2 = args[1];
                    a3 = args[2];
                    while (i++ < length) {
                        (event = eventList[i]) && event(a1, a2, a3);
                    }
                    break;
                case 4:
                    a1 = args[0];
                    a2 = args[1];
                    a3 = args[2];
                    a4 = args[3];
                    while (i++ < length) {
                        (event = eventList[i]) && event(a1, a2, a3, a4);
                    }
                    break;
                default:
                    while (i++ < length) {
                        (event = eventList[i]) && event.apply(null, args);
                    }
                    break;
            }
        }

        EventEmitter.prototype.emit = function(name) {
            var eventList = (this.__events || (this.__events = {}))[name];

            if (!eventList || !eventList.length) {
                return this;
            }

            emit(eventList, fastSlice(arguments, 1));

            return this;
        };

        EventEmitter.prototype.emitArgs = function(name, args) {
            var eventList = (this.__events || (this.__events = {}))[name];

            if (!eventList || !eventList.length) {
                return this;
            }

            emit(eventList, args);

            return this;
        };

        function emitAsync(eventList, args, callback) {
            var length = eventList.length,
                index = 0,
                called = false;

            function next(err) {
                if (called === true) {
                    return;
                }
                if (err || index === length) {
                    called = true;
                    callback(err);
                    return;
                }

                eventList[index++].apply(null, args);
            }

            args[args.length] = next;
            next();
        }

        EventEmitter.prototype.emitAsync = function(name, args, callback) {
            var eventList = (this.__events || (this.__events = {}))[name];

            args = fastSlice(arguments, 1);
            callback = args.pop();

            if (!isFunction(callback)) {
                throw new TypeError("EventEmitter.emitAsync(name [, ...args], callback) callback must be a function");
            }

            if (!eventList || !eventList.length) {
                callback();
            } else {
                emitAsync(eventList, args, callback);
            }

            return this;
        };

        EventEmitter.prototype.listeners = function(name) {
            var eventList = (this.__events || (this.__events = {}))[name];

            return eventList ? fastSlice(eventList) : [];
        };

        EventEmitter.prototype.listenerCount = function(name) {
            var eventList = (this.__events || (this.__events = {}))[name];

            return eventList ? eventList.length : 0;
        };

        EventEmitter.prototype.setMaxListeners = function(value) {
            if ((value = +value) !== value) {
                throw new TypeError("EventEmitter.setMaxListeners(value) value must be a number");
            }

            this.__maxListeners = value < 0 ? -1 : value;
            return this;
        };


        EventEmitter.defaultMaxListeners = 10;

        EventEmitter.listeners = function(obj, name) {
            var eventList;

            if (obj == null) {
                throw new TypeError("EventEmitter.listeners(obj, name) obj required");
            }
            eventList = obj.__events && obj.__events[name];

            return eventList ? fastSlice(eventList) : [];
        };

        EventEmitter.listenerCount = function(obj, name) {
            var eventList;

            if (obj == null) {
                throw new TypeError("EventEmitter.listenerCount(obj, name) obj required");
            }
            eventList = obj.__events && obj.__events[name];

            return eventList ? eventList.length : 0;
        };

        EventEmitter.setMaxListeners = function(value) {
            if ((value = +value) !== value) {
                throw new TypeError("EventEmitter.setMaxListeners(value) value must be a number");
            }

            EventEmitter.defaultMaxListeners = value < 0 ? -1 : value;
            return value;
        };

        EventEmitter.extend = function(child) {

            inherits(child, this);
            child.extend = this.extend;

            return child;
        };


        module.exports = EventEmitter;


    },
    function(require, exports, module, global) {

        var objectFunction = "[object Function]",
            toString = Object.prototype.toString,
            isFunction;


        if (typeof(/./) === "function" || (typeof(Uint8Array) !== "undefined" && typeof(Uint8Array) !== "function")) {
            isFunction = function isFunction(obj) {
                return toString.call(obj) === objectFunction;
            };
        } else {
            isFunction = function isFunction(obj) {
                return typeof(obj) === "function" || false;
            };
        }


        module.exports = isFunction;


    },
    function(require, exports, module, global) {

        var create = require(8),
            extend = require(9),
            mixin = require(14);


        module.exports = function inherits(child, parent) {

            mixin(child, parent);
            child.prototype = extend(create(parent.prototype), child.prototype);
            child.prototype.constructor = child;
            child.__super = parent.prototype;

            return child;
        };


    },
    function(require, exports, module, global) {

        module.exports = Object.create || (function() {
            function F() {}
            return function create(object) {
                F.prototype = object;
                return new F();
            };
        }());


    },
    function(require, exports, module, global) {

        var keys = require(10);


        function baseExtend(a, b) {
            var objectKeys = keys(b),
                i = -1,
                il = objectKeys.length - 1,
                key;

            while (i++ < il) {
                key = objectKeys[i];
                a[key] = b[key];
            }
        }

        module.exports = function extend(out) {
            var i = 0,
                il = arguments.length - 1;

            while (i++ < il) {
                baseExtend(out, arguments[i]);
            }

            return out;
        };


    },
    function(require, exports, module, global) {

        var has = require(11),
            isNative = require(12),
            isObject = require(13);


        var nativeKeys = Object.keys;


        if (!isNative(nativeKeys)) {
            nativeKeys = function keys(obj) {
                var localHas = has,
                    out = [],
                    i = 0,
                    key;

                for (key in obj) {
                    if (localHas(obj, key)) {
                        out[i++] = key;
                    }
                }

                return out;
            };
        }

        module.exports = function keys(obj) {
            return nativeKeys(isObject(obj) ? obj : Object(obj));
        };


    },
    function(require, exports, module, global) {

        var hasOwnProp = Object.prototype.hasOwnProperty;


        module.exports = function has(obj, key) {
            return hasOwnProp.call(obj, key);
        };


    },
    function(require, exports, module, global) {

        var isFunction = require(6);


        var reHostCtor = /^\[object .+?Constructor\]$/,

            functionToString = Function.prototype.toString,

            reNative = RegExp("^" +
                functionToString.call(toString)
                .replace(/[.*+?^${}()|[\]\/\\]/g, "\\$&")
                .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
            ),

            isHostObject = (function() {
                try {
                    String({
                        "toString": 0
                    } + "");
                } catch (e) {
                    return function isHostObject() {
                        return false;
                    };
                }

                return function isHostObject(value) {
                    return !isFunction(value.toString) && typeof(value + "") === "string";
                };
            }());


        module.exports = function isNative(obj) {
            return obj && (
                isFunction(obj) ?
                reNative.test(functionToString.call(obj)) : (
                    typeof(obj) === "object" && (
                        (isHostObject(obj) ? reNative : reHostCtor).test(obj) || false
                    )
                )
            ) || false;
        };


    },
    function(require, exports, module, global) {

        module.exports = function isObject(obj) {
            var type = typeof(obj);
            return type === "function" || (obj && type === "object") || false;
        };


    },
    function(require, exports, module, global) {

        var keys = require(10),
            isNullOrUndefined = require(15);


        function baseMixin(a, b) {
            var objectKeys = keys(b),
                i = -1,
                il = objectKeys.length - 1,
                key;

            while (i++ < il) {
                key = objectKeys[i];

                if (isNullOrUndefined(a[key]) && !isNullOrUndefined((value = b[key]))) {
                    a[key] = value;
                }
            }
        }

        module.exports = function mixin(out) {
            var i = 0,
                il = arguments.length - 1;

            while (i++ < il) {
                baseMixin(out, arguments[i]);
            }

            return out;
        };


    },
    function(require, exports, module, global) {

        module.exports = function isNullOrUndefined(obj) {
            return obj === null || obj === void 0;
        };


    },
    function(require, exports, module, global) {

        module.exports = function fastSlice(array, offset) {
            var length, i, il, result, j;

            offset = offset || 0;

            length = array.length;
            i = offset - 1;
            il = length - 1;
            result = new Array(length - offset);
            j = 0;

            while (i++ < il) {
                result[j++] = array[i];
            }

            return result;
        };


    },
    function(require, exports, module, global) {

        var keys = require(10),
            isNullOrUndefined = require(15),
            fastBindThis = require(18),
            isObjectLike = require(19),
            isLength = require(20);


        function forEachArray(array, callback) {
            var i = -1,
                il = array.length - 1;

            while (i++ < il) {
                if (callback(array[i], i) === false) {
                    return false;
                }
            }

            return array;
        }

        function forEachObject(object, callback) {
            var objectKeys = keys(object),
                i = -1,
                il = objectKeys.length - 1,
                key;

            while (i++ < il) {
                key = objectKeys[i];

                if (callback(object[key], key) === false) {
                    return false;
                }
            }

            return object;
        }

        module.exports = function forEach(object, callback, thisArg) {
            callback = isNullOrUndefined(thisArg) ? callback : fastBindThis(callback, thisArg, 2);
            return (isObjectLike(object) && isLength(object.length)) ? forEachArray(object, callback) : forEachObject(object, callback);
        };


    },
    function(require, exports, module, global) {

        module.exports = function fastBindThis(callback, thisArg, length) {
            switch (length || callback.length) {
                case 0:
                    return function bound() {
                        return callback.call(thisArg);
                    };
                case 1:
                    return function bound(a1) {
                        return callback.call(thisArg, a1);
                    };
                case 2:
                    return function bound(a1, a2) {
                        return callback.call(thisArg, a1, a2);
                    };
                case 3:
                    return function bound(a1, a2, a3) {
                        return callback.call(thisArg, a1, a2, a3);
                    };
                case 4:
                    return function bound(a1, a2, a3, a4) {
                        return callback.call(thisArg, a1, a2, a3, a4);
                    };
                default:
                    return function bound() {
                        return callback.apply(thisArg, arguments);
                    };
            }
        };


    },
    function(require, exports, module, global) {

        module.exports = function isObjectLike(obj) {
            return (obj && typeof(obj) === "object") || false;
        };


    },
    function(require, exports, module, global) {

        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;


        module.exports = function isLength(obj) {
            return typeof(obj) === "number" && obj > -1 && obj % 1 === 0 && obj <= MAX_SAFE_INTEGER;
        };


    },
    function(require, exports, module, global) {

        var forEach = require(17),
            keys = require(10),

            Table = require(22);


        var JSON_REPLACER = /\"(.*?)\"\:/g;


        function Schema(opts) {
            var options = {};

            opts || (opts = {});

            options.autoId = (opts.autoId != null) ? opts.autoId : true;
            options.timestamps = (opts.timestamps != null) ? opts.timestamps : true;

            this._options = options;

            this.tables = {};
        }

        Schema.prototype.init = function() {
            var tables = this.tables;

            forEach(tables, function(table) {
                table.init();
            });
            forEach(tables, function(table) {
                table._keys = keys(table.columns);
            });

            return this;
        };

        Schema.prototype.table = function(tableName) {
            var table = this.tables[tableName];

            if (table === undefined || table === null) {
                throw new Error(
                    "Schema.table(tableName)\n" +
                    "    no table defined named " + tableName
                );
            }

            return table;
        };

        Schema.prototype.has = function(tableName) {

            return !!this.tables[tableName];
        };

        Schema.prototype.create = function(tableName, options) {
            var tables = this.tables,
                opts = this._options,
                table;

            if (tables[tableName]) {
                throw new Error(
                    "Schema.create(tableName, options)\n" +
                    "    table already defined named " + tableName
                );
            }
            options || (options = {});

            options.autoId = (options.autoId === true) ? opts.autoId : options.autoId;
            options.timestamps = (options.timestamps === true) ? opts.timestamps : options.timestamps;

            table = new Table(tableName, options);
            table.schema = this;

            return (tables[tableName] = table);
        };

        Schema.prototype.add = function(table) {
            var tables = this.tables,
                opts = this._options,
                options = table._options,
                tableName;

            if (!(table instanceof Table)) {
                throw new Error(
                    "Schema.add(table)\n" +
                    "    table must be an instance of Table"
                );
            }

            tableName = table.tableName;

            if (tables[tableName]) {
                throw new Error(
                    "Schema.add(table)\n" +
                    "    table already defined named " + tableName
                );
            }

            options.autoId = (options.autoId === true) ? opts.autoId : options.autoId;
            options.timestamps = (options.timestamps === true) ? opts.timestamps : options.timestamps;

            table.schema = this;

            return (tables[tableName] = table);
        };

        Schema.prototype.toJSON = function() {
            var json = {};

            forEach(this.tables, function(table, tableName) {
                json[tableName] = table.toJSON();
            });

            return json;
        };

        Schema.prototype.fromJSON = function(json) {
            var _this = this,
                options = this._options;

            forEach(json, function(columns, tableName) {
                var opts = options[tableName];

                if (opts) {
                    delete options[tableName];
                } else {
                    opts = options;
                }

                _this.create(tableName, opts).addColumns(columns);
            });

            return this;
        };

        Schema.prototype.toExports = function(numOfSpacesPerTab) {

            return "module.exports = " + JSON.stringify(this.toJSON(), null, +numOfSpacesPerTab || 4).replace(JSON_REPLACER, function(match, key) {
                return key + ":";
            }) + ";\n";
        };


        module.exports = Schema;


    },
    function(require, exports, module, global) {

        var isString = require(23),
            forEach = require(17),
            keys = require(10),
            extend = require(9),
            indexOf = require(24),
            has = require(11),

            functions = require(26);


        var types = [
                "string",
                "integer",
                "float",
                "datetime",
                "json",
                "boolean"
            ],
            allowed = [
                "primaryKey",
                "foreignKey",
                "autoIncrement",
                "index",
                "unique"
            ];

        function coerceType(value) {
            value = (value + "").toLowerCase();

            return (
                (value === "integer" || value === "int") ? "integer" :
                (value === "float" || value === "double" || value === "decimal" || value === "dec") ? "float" :
                (value === "boolean" || value === "bool") ? "boolean" :
                (value === "datetime" || value === "date" || value === "time") ? "datetime" :
                (value === "json" || value === "object" || value === "array") ? "json" :
                "string"
            );
        }

        function coerceValue(attributes, value) {
            var type = attributes.type,
                defaults = attributes.defaults;

            if (value == null && defaults != null) {
                value = defaults;
            }
            if (value == null) {
                return null;
            }

            if (type === "string") {
                return typeof(value.toString) !== "undefined" ? value.toString() : value + "";
            } else if (type === "integer" || type === "float") {
                return +value;
            } else if (type === "json") {
                return JSON.stringify(value);
            } else if (type === "boolean") {
                return !!value;
            } else if (type === "datetime") {
                return value instanceof Date ? value.toJSON() : (new Date(value)).toJSON();
            }

            return value;
        }


        function Table(tableName, opts) {
            var options = {};

            opts || (opts = {});

            options.autoId = (opts.autoId != null) ? opts.autoId : true;
            options.timestamps = (opts.timestamps != null) ? opts.timestamps : true;
            options.functions = extend(opts.functions || {}, functions);

            this._options = options;
            this._keys = null;
            this._functions = {};
            this._defines = {};

            this.schema = null;
            this.tableName = tableName;

            this.columns = {};

            if (opts.columns) this.addColumns(opts.columns);
        }

        Table.coerceType = coerceType;
        Table.coerceValue = coerceValue;
        Table.types = types;
        Table.allowed = allowed;

        Table.prototype.init = function() {
            var _this = this,
                options = this._options,
                schema = this.schema,
                columns = this.columns;

            if (options.autoId) this.add("autoId", options.autoId);
            if (options.timestamps) this.add("timestamps", options.timestamps);

            forEach(this._defines, function(column, columnName) {

                columns[columnName] = extend({}, column);
            });
            forEach(this._functions, function(opts, functionName) {

                options.functions[functionName](schema, _this, opts);
            });

            return this;
        };

        Table.prototype.table = function(tableName) {

            return this.schema.table(tableName);
        };

        Table.prototype.column = function(columnName) {
            var column = this.columns[columnName];

            if (column === undefined || column === null) {
                throw new Error(
                    "Table.column(columnName)\n" +
                    "    " + this.tableName + " has no column defined named " + columnName
                );
            }

            return column;
        };

        Table.prototype.has = function(columnName) {

            return !!this.columns[columnName];
        };

        Table.prototype.addColumns = function(columns) {
            var _this = this;

            forEach(columns, function(attributes, columnName) {

                _this.add(columnName, attributes);
            });
            return this;
        };

        Table.prototype.add = function(columnName, attributes) {
            var defines;

            if (has(this._options.functions, columnName)) {
                Table_parseFunction(this, columnName, attributes);
            } else {
                defines = this._defines;
                Table_parseColumn(this, columnName, attributes, defines[columnName] || (defines[columnName] = {}));
            }

            return this;
        };

        Table.prototype.functionAdd = function(columnName, attributes) {
            var columns = this.columns,
                column = columns[columnName] || (columns[columnName] = {});

            Table_parseColumn(this, columnName, attributes, column);
            return this;
        };

        Table.prototype.filter = function(values, accessible) {
            var filtered = {},
                columns = this.columns,
                keys = this._keys || [],
                i = keys.length,
                key, value, newValue;

            while (i--) {
                key = keys[i];
                value = values[key];
                newValue = coerceValue(columns[key], value);

                if (newValue != null && (accessible ? accessible[key] : true)) {
                    filtered[key] = newValue;
                }
            }

            return filtered;
        };

        Table.prototype.coerce = function(values) {
            var columns = this.columns,
                keys = this._keys || [],
                i = keys.length,
                key;

            while (i--) {
                key = keys[i];
                values[key] = coerceValue(columns[key], values[key]);
            }

            return values;
        };

        Table.prototype.toJSON = function() {
            var json = {};

            forEach(this._defines, function(column, columnName) {
                var objectKeys = keys(column),
                    i = objectKeys.length,
                    jsonColumn, key;

                if (i === 1) {
                    key = objectKeys[0];
                    json[columnName] = column[key];
                } else {
                    jsonColumn = json[columnName] = {};

                    while (i--) {
                        key = objectKeys[i];
                        jsonColumn[key] = column[key];
                    }
                }
            });
            forEach(this._functions, function(options, functionName) {

                json[functionName] = options;
            });

            return json;
        };

        function Table_parseFunction(_this, columnName, attributes) {

            _this._functions[columnName] = attributes != null ? attributes : true;
        }

        function Table_parseColumn(_this, columnName, attributes, column) {
            if (isString(attributes)) {
                attributes = {
                    type: attributes
                };
            }

            forEach(attributes, function(value, key) {
                var coerced;

                if (key === "type") {
                    coerced = coerceType(value);

                    if (indexOf(types, coerced) === -1) {
                        throw new Error(
                            "Table parseColumn(columnName, attributes, column)\n" +
                            "    table " + _this.tableName + " was passed a column named " + columnName + " with a value of " + value + "\n" +
                            "    interpreted as type which must be on of\n" +
                            "    " + types.join(", ")
                        );
                    }

                    column[key] = coerced;
                } else if (key === "defaults") {
                    column[key] = value;
                } else {
                    if (indexOf(allowed, key) === -1) {
                        throw new Error(
                            "Table parseColumn(columnName, attributes, column)\n" +
                            "    table " + _this.tableName + " column " + columnName + " passed " + value + " allowed attributes are,\n" +
                            "    type, " + allowed.join(", ")
                        );
                    }

                    column[key] = true;
                }
            });
        }


        module.exports = Table;


    },
    function(require, exports, module, global) {

        module.exports = function isString(obj) {
            return typeof(obj) === "string" || false;
        };


    },
    function(require, exports, module, global) {

        var isArray = require(25);


        function arrayIndexOf(array, value, fromIndex) {
            var i = fromIndex - 1,
                il = array.length - 1;

            while (i++ < il) {
                if (array[i] === value) {
                    return i;
                }
            }

            return -1;
        }

        module.exports = function indexOf(array, value, fromIndex) {
            return isArray(array) ? arrayIndexOf(array, value, fromIndex || 0) : -1;
        };


    },
    function(require, exports, module, global) {

        var isLength = require(20),
            isObjectLike = require(19);


        var objectArray = "[object Array]",
            toString = Object.prototype.toString;


        module.exports = Array.isArray || function isArray(obj) {
            return isObjectLike(obj) && isLength(obj.length) && toString.call(obj) === objectArray;
        };


    },
    function(require, exports, module, global) {

        var isObject = require(13),
            isArray = require(25),
            forEach = require(17),

            foreignKey = require(27),
            singularize = require(33),
            pluralize = require(37);


        var functions = module.exports;


        functions.autoId = function(schema, table, options) {
            var value = {};

            options = isObject(options) ? options : {};

            value.type = options.type || "integer";
            if (options.primaryKey !== false) value.primaryKey = true;
            if (options.autoIncrement !== false) value.autoIncrement = true;

            table.functionAdd(options.key || "id", value);
        };

        functions.timestamps = function(schema, table, options) {
            var createdAt = "createdAt",
                updatedAt = "updatedAt";

            if (isObject(options)) {
                if (options.underscore === true || options.camelcase === false) {
                    createdAt = "created_at";
                    updatedAt = "updated_at";
                }
            }

            table.functionAdd(createdAt, "datetime");
            table.functionAdd(updatedAt, "datetime");
        };

        functions.hasMany = function(schema, table, options) {
            var model, columnName;

            if (isArray(options)) {
                forEach(options, function(value) {
                    functions.hasMany(schema, table, value);
                });
                return;
            }

            options = isObject(options) ? options : {
                collection: options + ""
            };

            model = schema.table(options.collection);

            columnName = foreignKey(
                singularize(table.tableName, options.locale),
                options.key || "id",
                options.underscore === false || options.camelcase === true || true,
                options.lowFirstLetter != null ? !!options.lowFirstLetter : true
            );

            model.functionAdd(columnName, {
                type: options.type || "integer",
                foreignKey: true
            });
        };

        functions.hasOne = function(schema, table, options) {
            var model, columnName;

            if (isArray(options)) {
                forEach(options, function(value) {
                    functions.hasOne(schema, table, value);
                });
                return;
            }

            options = isObject(options) ? options : {
                model: options + ""
            };

            model = schema.table(pluralize(options.model, options.locale));

            columnName = foreignKey(
                singularize(table.tableName, options.locale),
                options.key || "id",
                options.underscore === false || options.camelcase === true || true,
                options.lowFirstLetter != null ? !!options.lowFirstLetter : true
            );

            model.functionAdd(columnName, {
                type: options.type || "integer",
                unique: true,
                foreignKey: true
            });
        };

        functions.belongsTo = function(schema, table, options) {
            var model, columnName;

            if (isArray(options)) {
                forEach(options, function(value) {
                    functions.belongsTo(schema, table, value);
                });
                return;
            }

            options = isObject(options) ? options : {
                model: options + ""
            };

            model = schema.table(pluralize(options.model, options.locale));

            columnName = foreignKey(
                options.model,
                options.key || "id",
                options.underscore === false || options.camelcase === true || true,
                options.lowFirstLetter != null ? !!options.lowFirstLetter : true
            );

            table.functionAdd(columnName, {
                type: options.type || "integer",
                foreignKey: true
            });
        };


    },
    function(require, exports, module, global) {

        var isString = require(23),
            isBoolean = require(28),
            camelize = require(29),
            underscore = require(32);


        module.exports = function foreignKey(string, key, camelized, lowFirstLetter) {
            if (isBoolean(key)) {
                lowFirstLetter = camelized;
                camelized = key;
                key = "id";
            }

            key = isString(key) ? key : "id";

            if (camelized !== false) {
                return camelize(string + "_" + key, lowFirstLetter);
            } else {
                return underscore(string + "_" + key);
            }
        };


    },
    function(require, exports, module, global) {

        module.exports = function isBoolean(obj) {
            return typeof(obj) === "boolean" || false;
        };


    },
    function(require, exports, module, global) {

        var reInflect = require(30),
            capitalizeString = require(31);


        module.exports = function camelize(string, lowFirstLetter) {
            var parts = string.match(reInflect),
                i = parts.length;

            while (i--) {
                parts[i] = capitalizeString(parts[i]);
            }
            string = parts.join("");

            return lowFirstLetter !== false ? string.charAt(0).toLowerCase() + string.slice(1) : string;
        };


    },
    function(require, exports, module, global) {

        module.exports = /[^A-Z-_ \.]+|[A-Z][^A-Z-_ \.]+|[^a-z-_ \.]+/g;


    },
    function(require, exports, module, global) {

        module.exports = function capitalizeString(string) {
            return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
        };


    },
    function(require, exports, module, global) {

        var reInflect = require(30);


        module.exports = function underscore(string) {
            return string.match(reInflect).join("_").toLowerCase();
        };


    },
    function(require, exports, module, global) {

        var inflections = require(34);


        module.exports = function singularize(string, locale) {
            return inflections(locale).singularize(string);
        };


    },
    function(require, exports, module, global) {

        var Inflector = require(35),
            defineProperty = require(36);


        var locales = global.__INFLECTORS__,
            defaultLocale = global.__DEFAULT_LOCALE__;


        if (!locales) {
            locales = {};
            defineProperty(global, "__INFLECTORS__", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: locales
            });
        }

        if (!defaultLocale) {
            defaultLocale = "en";
            defineProperty(global, "__DEFAULT_LOCALE__", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: defaultLocale
            });
        }


        module.exports = inflections;


        function inflections(locale) {
            locale = locale || defaultLocale;
            return locales[locale] || (locales[locale] = Inflector.create());
        }

        inflections.setDefaultLocale = function(locale) {
            global.__DEFAULT_LOCALE__ = defaultLocale = locale;
        };


    },
    function(require, exports, module, global) {

        var indexOf = require(24);


        module.exports = Inflector;


        function Inflector() {
            this.plurals = [];
            this.singulars = [];
            this.uncountables = [];
        }

        Inflector.create = function() {
            return new Inflector();
        };

        Inflector.prototype.clear = function() {

            this.plurals.length = 0;
            this.singulars.length = 0;
            this.uncountables.length = 0;

            return this;
        };

        Inflector.prototype.uncountable = function() {
            var uncountables = this.uncountables,
                i = -1,
                il = arguments.length - 1;

            while (i++ < il) {
                uncountables[uncountables.length] = arguments[i].toLowerCase();
            }
            return this;
        };

        Inflector.prototype.plural = function(rule, replacement) {
            var plurals = this.plurals;

            plurals[plurals.length] = [rule, replacement];
            return this;
        };

        Inflector.prototype.singular = function(rule, replacement) {
            var singulars = this.singulars;

            singulars[singulars.length] = [rule, replacement];
            return this;
        };

        Inflector.prototype.irregular = function(singular, plural) {

            singular = singular.toLowerCase();
            plural = plural.toLowerCase();

            this.plural(new RegExp("\\b" + singular + "\\b", "i"), plural);
            this.singular(new RegExp("\\b" + plural + "\\b", "i"), singular);

            return this;
        };

        Inflector.prototype.pluralize = function(word) {
            var plurals = this.plurals,
                result = word,
                i = plurals.length,
                pattern;

            if (indexOf(this.uncountables, word.toLowerCase()) !== -1) {
                return word;
            }

            while (i--) {
                pattern = plurals[i];

                if ((result = replace(word, pattern[0], pattern[1]))) {
                    return result;
                }
            }

            return word;
        };

        Inflector.prototype.isPlural = function(word) {

            return this.singularize(word) !== word;
        };

        Inflector.prototype.is_plural = Inflector.prototype.isPlural;

        Inflector.prototype.singularize = function(word) {
            var singulars = this.singulars,
                result = word,
                i = singulars.length,
                pattern;

            if (indexOf(this.uncountables, word.toLowerCase()) !== -1) {
                return word;
            }

            while (i--) {
                pattern = singulars[i];

                if ((result = replace(word, pattern[0], pattern[1]))) {
                    return result;
                }
            }

            return word;
        };

        Inflector.prototype.isSingular = function(word) {

            return this.pluralize(word) !== word;
        };

        Inflector.prototype.is_singular = Inflector.prototype.isSingular;

        function replace(word, rule, replacement) {
            if (rule.test(word)) {
                return word.replace(rule, replacement);
            } else {
                return false;
            }
        }


    },
    function(require, exports, module, global) {

        var isFunction = require(6),
            isObjectLike = require(19),
            isNative = require(12);


        var defineProperty;


        if (!isNative(Object.defineProperty)) {
            defineProperty = function defineProperty(object, name, value) {
                if (!isObjectLike(object)) {
                    throw new TypeError("defineProperty called on non-object");
                }
                object[name] = isObjectLike(value) ? (isFunction(value.get) ? value.get : value.value) : value;
            };
        } else {
            defineProperty = Object.defineProperty;
        }

        module.exports = defineProperty;


    },
    function(require, exports, module, global) {

        var inflections = require(34);


        module.exports = function pluralize(string, locale) {
            return inflections(locale).pluralize(string);
        };


    },
    function(require, exports, module, global) {

        var EventEmitter = require(5),
            forEach = require(17),
            isString = require(23),
            isFunction = require(6),
            isObject = require(13),
            isArray = require(25),
            tableize = require(39),
            underscore = require(32),
            PromisePolyfill = require(40),
            validator = require(43),

            Query = require(61),
            Table = require(22),
            hooks = require(62);


        var slice = Array.prototype.slice;


        function Model(opts) {
            var options = {};

            opts || (opts = {});

            if (!isString(opts.name) && !isString(opts.className)) {
                throw new Error(
                    "Model(options)\n" +
                    "    options.name or options.className required as string ex {name: 'User'}"
                );
            }

            options.columns = opts.columns || opts.schema;
            options.functions = opts.functions;

            options.className = opts.name || opts.className;
            options.tableName = isString(opts.tableName) ? opts.tableName : tableize(options.className);

            options.autoId = (opts.autoId != null) ? opts.autoId : true;
            options.timestamps = (opts.timestamps != null) ? opts.timestamps : true;

            EventEmitter.call(this);

            this._options = options;

            this._init = false;
            this._collection = null;

            this._accessible = {};
            this._validations = {};
            this._wrappers = {};

            this._schema = new Table(options.tableName, options);

            this.Class = null;

            this.adapter = opts.adapter;

            this.className = options.className;
            this.tableName = options.tableName;

            this.prototype = {};
        }
        EventEmitter.extend(Model);

        Model.prototype.init = function(callback) {
            var _this = this,
                adapter = this.adapter || this._collection._options.defaultAdapter,
                schema = this._schema;

            forEach(schema._functions, function(options, name) {
                var hookFunc = hooks[name],
                    hook;

                if (!isFunction(hookFunc)) return;

                hook = hookFunc(isObject(options) ? options : {});

                forEach(hook.events, function(event, eventType) {
                    if (isArray(event)) {
                        forEach(event, function(e) {
                            _this.on(eventType, e);
                        });
                    } else if (isFunction(event)) {
                        _this.on(eventType, event);
                    }
                });
            });

            forEach(schema.columns, function(column, name) {

                _this.validates(name)[column.type]();
            });

            if (isString(adapter)) {
                this.adapter = this._collection.adapter(adapter);
            } else {
                this.adapter = adapter;
            }

            this.generateClass();
            this._wrappers = {};

            this.emitAsync("init", callback);

            return this;
        };

        Model.prototype.build = function(attributes) {
            var instance = new this.Class(),
                schema, columns, columnType, keys, key, attribute, i;

            if (isObject(attributes)) {
                schema = this._schema;
                columns = schema.columns;
                keys = schema._keys;
                i = keys.length;

                while (i--) {
                    key = keys[i];
                    attribute = attributes[key];
                    columnType = columns[key].type;

                    if (attribute != null) {
                        if (columnType === "datetime") {
                            instance[key] = (new Date(attribute)).toJSON();
                        } else if (columnType === "json" && isString(attribute)) {
                            try {
                                instance[key] = JSON.parse(attribute);
                            } catch (e) {
                                instance[key] = null;
                            }
                        } else {
                            instance[key] = attribute;
                        }
                    }
                }
            }

            return instance;
        };

        Model.prototype["new"] = Model.prototype.build;

        Model.prototype.create = function(attributes, callback) {
            var _this = this,
                isPromise = !isFunction(callback),
                model = this.build(attributes),
                defer;

            if (isPromise) {
                defer = PromisePolyfill.defer();
            }

            function resolve(row) {
                return isPromise ? defer.resolve(row) : callback(undefined, row);
            }

            function reject(err) {
                return isPromise ? defer.reject(err) : callback(err);
            }

            function beforeValidate(err) {
                var errors;

                if (err) {
                    reject(err);
                    return;
                }
                if ((errors = _this.validate(model))) {
                    reject(errors);
                    return;
                }

                _this.emitAsync("validate", model, validate);
            }

            function validate(err) {
                if (err) {
                    reject(err);
                    return;
                }
                _this.emitAsync("beforeCreate", model, beforeCreate);
            }

            function beforeCreate(err) {
                if (err) {
                    reject(err);
                    return;
                }
                _this.adapter.save(_this.tableName, model, function(err, row) {
                    if (err) {
                        reject(err);
                        return;
                    }

                    row = _this.build(row);
                    _this.emitAsync("create", row, function(err) {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve(row);
                    });
                });
            }

            this._schema.coerce(model);
            this.emitAsync("beforeValidate", model, beforeValidate);

            return defer ? defer.promise : undefined;
        };

        Model.prototype.save = function(model, callback) {
            var _this = this,
                isPromise = !isFunction(callback),
                defer;

            if (isPromise) {
                defer = PromisePolyfill.defer();
            }

            function resolve(row) {
                return isPromise ? defer.resolve(row) : callback(undefined, row);
            }

            function reject(err) {
                return isPromise ? defer.reject(err) : callback(err);
            }

            function beforeValidate(err) {
                var errors;

                if (err) {
                    reject(err);
                    return;
                }
                if ((errors = _this.validate(model))) {
                    reject(errors);
                    return;
                }

                _this.emitAsync("validate", model, validate);
            }

            function validate(err) {
                if (err) {
                    reject(err);
                    return;
                }
                _this.emitAsync("beforeSave", model, beforeSave);
            }

            function beforeSave(err) {
                if (err) {
                    reject(err);
                    return;
                }
                _this.adapter.save(_this.tableName, model, function(err, row) {
                    if (err) {
                        reject(err);
                        return;
                    }

                    row = _this.build(row);
                    _this.emitAsync("save", row, function(err) {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve(row);
                    });
                });
            }

            this._schema.coerce(model);
            this.emitAsync("beforeValidate", model, beforeValidate);

            return defer ? defer.promise : undefined;
        };

        Model.prototype.update = function(id, model, callback) {
            var _this = this,
                isPromise = !isFunction(callback),
                defer;

            if (isPromise) {
                defer = PromisePolyfill.defer();
            }

            function resolve(row) {
                return isPromise ? defer.resolve(row) : callback(undefined, row);
            }

            function reject(err) {
                return isPromise ? defer.reject(err) : callback(err);
            }

            function beforeValidate(err) {
                var errors;

                if (err) {
                    reject(err);
                    return;
                }
                if ((errors = _this.validate(model))) {
                    reject(errors);
                    return;
                }

                _this.emitAsync("validate", model, validate);
            }

            function validate(err) {
                if (err) {
                    reject(err);
                    return;
                }
                _this.emitAsync("beforeUpdate", model, beforeUpdate);
            }

            function beforeUpdate(err) {
                if (err) {
                    reject(err);
                    return;
                }
                _this.adapter.update(_this.tableName, id, model, function(err, row) {
                    if (err) {
                        reject(err);
                        return;
                    }

                    row = _this.build(row);
                    _this.emitAsync("update", row, function(err) {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve(row);
                    });
                });
            }

            model = this._schema.filter(model, this._accessible);
            this.emitAsync("beforeValidate", model, beforeValidate);

            return defer ? defer.promise : undefined;
        };

        Model.prototype.find = function(query, callback) {
            var _this = this;

            if (isFunction(query)) {
                callback = query;
                query = {};
            }

            if (isFunction(callback)) {
                if (!isObject(query)) query = {};

                if (query.where === undefined || query.where === null) {
                    query.where = {};
                }

                this.adapter.find(this.tableName, query, function(err, rows) {
                    if (err) {
                        callback(err);
                        return;
                    }

                    callback(undefined, Model_toModels(_this, rows));
                });
                return undefined;
            }

            return new Query(this, "find", query);
        };

        Model.prototype.findOne = function(query, callback) {
            var _this = this;

            if (isFunction(query)) {
                callback = query;
                query = {};
            }

            if (isFunction(callback)) {
                if (!isObject(query)) query = {};

                if (query.where === undefined || query.where === null) {
                    query.where = {};
                }

                this.adapter.findOne(this.tableName, query, function(err, row) {
                    if (err) {
                        callback(err);
                        return;
                    }

                    callback(undefined, _this.build(row));
                });
                return undefined;
            }

            return new Query(this, "findOne", query);
        };

        Model.prototype.destroy = function(query, callback) {
            var _this = this,
                beforeDestroy;

            if (isFunction(query)) {
                callback = query;
                query = {};
            }

            if (isFunction(callback)) {
                beforeDestroy = function beforeDestroy(err) {
                    if (err) {
                        callback(err);
                        return;
                    }

                    if (!isObject(query)) query = {};

                    if (query.where === undefined || query.where === null) {
                        query.where = {};
                    }

                    _this.adapter.destroy(_this.tableName, query, function(err, rows) {
                        if (err) {
                            callback(err);
                            return;
                        }

                        rows = Model_toModels(_this, rows);
                        _this.emitAsync("destroy", rows, function(err) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            callback(undefined, rows);
                        });
                    });
                };

                this.emitAsync("beforeDestroy", query, beforeDestroy);
                return undefined;
            }

            return new Query(this, "destroy", query);
        };

        Model.prototype.accessible = function() {
            var accessible = this._accessible,
                i = arguments.length,
                columnName;

            while (i--) {
                if ((columnName = arguments[i])) {
                    accessible[columnName] = true;
                }
            }
            return this;
        };

        Model.prototype.validates = function(columnName) {
            var validations = this._validations,
                wrappers = this._wrappers,
                validation = validations[columnName] || (validations[columnName] = {}),
                wrapper = wrappers[columnName];

            if (!wrapper) {
                wrapper = wrappers[columnName] = {};

                forEach(validator.rules, function(rule, ruleName) {
                    wrapper[ruleName] = function() {
                        validation[underscore(ruleName)] = arguments.length > 0 ? slice.call(arguments) : true;
                        return wrapper;
                    };
                });
            }

            return wrapper;
        };

        function ValidationError(tableName, columnName, value, rule, args) {

            this.tableName = tableName;
            this.columnName = columnName;
            this.value = value;
            this.rule = rule;
            this.args = args;
        }

        Model.prototype.validate = function(values, method) {
            var match = validator.match,
                validations = this._validations,
                keys = this._schema._keys,
                i = keys.length,
                key, validation, value, rule, args, error, errors;

            while (i--) {
                key = keys[i];
                value = values[key];
                validation = validations[key];

                if (
                    (value === undefined || value === null) &&
                    (!validation || !validation.required || method === "update")
                ) {
                    continue;
                }

                for (rule in validation) {
                    args = validation[rule];

                    if (typeof(args) === "boolean") {
                        error = match(rule, value);
                    } else {
                        error = match(rule, value, args);
                    }

                    if (error) {
                        (errors || (errors = [])).push(new ValidationError(this.tableName, key, value, rule, args));
                    }
                }
            }

            return errors;
        };

        Model.prototype.generateClass = function() {
            var model = this,
                Class;

            try {
                eval([
                    "function " + this.className + "() {",
                    Model_generateClassAttributes(this),
                    "}",
                    "Class = " + this.className + ";"
                ].join("\n"));
            } catch (e) {
                throw new Error("Model.generateClass() failed to generate model for " + this.className + " with error " + e.message);
            }

            Class.prototype = model.prototype;
            Class.prototype.constructor = Class;

            Class.prototype.save = function(callback) {

                return model.save(this, callback);
            };

            Class.prototype.update = function(callback) {

                return model.update(this.id, this, callback);
            };

            Class.prototype.destroy = function(callback) {
                return model.destroy({
                    where: {
                        id: this.id
                    }
                }, callback);
            };

            this.Class = Class;

            return this;
        };

        function Model_toModels(_this, array) {
            var i = array.length;

            while (i--) array[i] = _this.build(array[i]);
            return array;
        }

        function Model_generateClassAttributes(_this) {
            var out = [];

            forEach(_this._schema.columns, function(_, key) {
                out.push("\tthis." + key + " = null;");
            });

            return out.join("\n");
        }


        module.exports = Model;


    },
    function(require, exports, module, global) {

        var isString = require(23),
            camelize = require(29),
            underscore = require(32),
            pluralize = require(37);


        module.exports = function tableize(string, camelcase, locale) {
            if (isString(camelcase)) {
                locale = camelcase;
                camelcase = true;
            }

            return camelcase !== false ? camelize(pluralize(string, locale)) : underscore(pluralize(string, locale));
        };


    },
    function(require, exports, module, global) {

        var process = require(1);
        var isArray = require(25),
            isObject = require(13),
            isFunction = require(6),
            createStore = require(41),
            fastSlice = require(16);


        var PromisePolyfill, PrivatePromise;


        if (typeof(Promise) !== "undefined") {
            PromisePolyfill = Promise;
        } else {
            PrivatePromise = (function() {

                function PrivatePromise(resolver) {
                    var _this = this;

                    this.handlers = [];
                    this.state = null;
                    this.value = null;

                    handleResolve(
                        resolver,
                        function resolve(newValue) {
                            resolveValue(_this, newValue);
                        },
                        function reject(newValue) {
                            rejectValue(_this, newValue);
                        }
                    );
                }

                PrivatePromise.store = createStore();

                PrivatePromise.handle = function(_this, onFulfilled, onRejected, resolve, reject) {
                    handle(_this, new Handler(onFulfilled, onRejected, resolve, reject));
                };

                function Handler(onFulfilled, onRejected, resolve, reject) {
                    this.onFulfilled = isFunction(onFulfilled) ? onFulfilled : null;
                    this.onRejected = isFunction(onRejected) ? onRejected : null;
                    this.resolve = resolve;
                    this.reject = reject;
                }

                function handleResolve(resolver, onFulfilled, onRejected) {
                    var done = false;

                    try {
                        resolver(
                            function(value) {
                                if (done) {
                                    return;
                                }
                                done = true;
                                onFulfilled(value);
                            },
                            function(reason) {
                                if (done) {
                                    return;
                                }
                                done = true;
                                onRejected(reason);
                            }
                        );
                    } catch (err) {
                        if (done) {
                            return;
                        }
                        done = true;
                        onRejected(err);
                    }
                }

                function resolveValue(_this, newValue) {
                    try {
                        if (newValue === _this) {
                            throw new TypeError("A promise cannot be resolved with itself");
                        }

                        if (newValue && (isObject(newValue) || isFunction(newValue))) {
                            if (isFunction(newValue.then)) {
                                handleResolve(
                                    function resolver(resolve, reject) {
                                        newValue.then(resolve, reject);
                                    },
                                    function resolve(newValue) {
                                        resolveValue(_this, newValue);
                                    },
                                    function reject(newValue) {
                                        rejectValue(_this, newValue);
                                    }
                                );
                                return;
                            }
                        }
                        _this.state = true;
                        _this.value = newValue;
                        finale(_this);
                    } catch (err) {
                        rejectValue(_this, err);
                    }
                }

                function rejectValue(_this, newValue) {
                    _this.state = false;
                    _this.value = newValue;
                    finale(_this);
                }

                function finale(_this) {
                    var handlers = _this.handlers,
                        i = -1,
                        il = handlers.length - 1;

                    while (i++ < il) {
                        handle(_this, handlers[i]);
                    }

                    handlers.length = 0;
                }

                function handle(_this, handler) {
                    var state = _this.state;

                    if (_this.state === null) {
                        _this.handlers.push(handler);
                        return;
                    }

                    process.nextTick(function nextTick() {
                        var callback = state ? handler.onFulfilled : handler.onRejected,
                            value = _this.value,
                            out;

                        if (callback === null) {
                            (state ? handler.resolve : handler.reject)(value);
                            return;
                        }

                        try {
                            out = callback(value);
                        } catch (err) {
                            handler.reject(err);
                            return;
                        }

                        handler.resolve(out);
                    });
                }

                return PrivatePromise;
            }());

            PromisePolyfill = function Promise(resolver) {

                if (!(this instanceof PromisePolyfill)) {
                    throw new TypeError("Promise(resolver) \"this\" must be an instance of of Promise");
                }
                if (!isFunction(resolver)) {
                    throw new TypeError("Promise(resolver) You must pass a resolver function as the first argument to the promise constructor");
                }

                PrivatePromise.store.set(this, new PrivatePromise(resolver));
            };

            PromisePolyfill.prototype.then = function(onFulfilled, onRejected) {
                var _this = PrivatePromise.store.get(this);

                return new PromisePolyfill(function resolver(resolve, reject) {
                    PrivatePromise.handle(_this, onFulfilled, onRejected, resolve, reject);
                });
            };
        }


        if (!isFunction(PromisePolyfill.prototype["catch"])) {
            PromisePolyfill.prototype["catch"] = function(onRejected) {
                return this.then(null, onRejected);
            };
        }

        if (!isFunction(PromisePolyfill.resolve)) {
            PromisePolyfill.resolve = function(value) {
                if (value instanceof PromisePolyfill) {
                    return value;
                }

                return new PromisePolyfill(function resolver(resolve) {
                    resolve(value);
                });
            };
        }

        if (!isFunction(PromisePolyfill.reject)) {
            PromisePolyfill.reject = function(value) {
                return new PromisePolyfill(function resolver(resolve, reject) {
                    reject(value);
                });
            };
        }

        if (!isFunction(PromisePolyfill.defer)) {
            PromisePolyfill.defer = function() {
                var deferred = {};

                deferred.promise = new PromisePolyfill(function resolver(resolve, reject) {
                    deferred.resolve = resolve;
                    deferred.reject = reject;
                });

                return deferred;
            };
        }

        if (!isFunction(PromisePolyfill.all)) {
            PromisePolyfill.all = function(value) {
                var args = (arguments.length === 1 && isArray(value)) ? value : fastSlice(arguments);

                return new PromisePolyfill(function resolver(resolve, reject) {
                    var length = args.length,
                        i = -1,
                        il = length - 1;

                    if (length === 0) {
                        resolve([]);
                        return;
                    }

                    function resolveValue(index, value) {
                        try {
                            if (value && (isObject(value) || isFunction(value)) && isFunction(value.then)) {
                                value.then(function(v) {
                                    resolveValue(index, v);
                                }, reject);
                                return;
                            }
                            if (--length === 0) {
                                resolve(args);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }

                    while (i++ < il) {
                        resolveValue(i, args[i]);
                    }
                });
            };
        }

        if (!isFunction(PromisePolyfill.race)) {
            PromisePolyfill.race = function(values) {
                return new PromisePolyfill(function resolver(resolve, reject) {
                    var i = -1,
                        il = values.length - 1,
                        value;

                    while (i++ < il) {
                        value = values[i];

                        if (value && (isObject(value) || isFunction(value)) && isFunction(value.then)) {
                            value.then(resolve, reject);
                        }
                    }
                });
            };
        }


        module.exports = PromisePolyfill;


    },
    function(require, exports, module, global) {

        var has = require(11),
            defineProperty = require(36),
            isPrimitive = require(42);


        var emptyObject = {};


        module.exports = createStore;


        function privateStore(key, privateKey) {
            var store = {
                    identity: privateKey
                },
                valueOf = key.valueOf;

            defineProperty(key, "valueOf", {
                value: function(value) {
                    return value !== privateKey ? valueOf.apply(this, arguments) : store;
                },
                writable: true
            });

            return store;
        }

        function createStore() {
            var privateKey = {};

            function get(key) {
                if (isPrimitive(key)) {
                    throw new TypeError("Invalid value used as key");
                }

                return key.valueOf(privateKey) || emptyObject;
            }

            function set(key) {
                var store;

                if (isPrimitive(key)) {
                    throw new TypeError("Invalid value used as key");
                }

                store = key.valueOf(privateKey);

                if (!store || store.identity !== privateKey) {
                    store = privateStore(key, privateKey);
                }

                return store;
            }

            return {
                get: function(key) {
                    return get(key).value;
                },
                set: function(key, value) {
                    set(key).value = value;
                },
                has: function(key) {
                    return has(get(key), "value");
                },
                remove: function(key) {
                    var store = get(key);
                    return store === emptyObject ? false : delete store.value;
                },
                clear: function() {
                    privateKey = {};
                }
            };
        }


    },
    function(require, exports, module, global) {

        var isNullOrUndefined = require(15);


        module.exports = function isPrimitive(obj) {
            var typeStr;
            return isNullOrUndefined(obj) || ((typeStr = typeof(obj)) !== "object" && typeStr !== "function") || false;
        };


    },
    function(require, exports, module, global) {

        var isArray = require(25),
            rules = require(44),
            validations = require(55);


        var validator = module.exports,
            slice = Array.prototype.slice;


        validator.rules = rules;
        validator.validations = validations;


        validator.match = function(ruleName, data, args) {
            var rule = rules[ruleName],
                value, length;

            if (!rule) throw new Error("validator.match(ruleName, data, args) no ruled defined named " + ruleName);

            if (arguments.length > 2) {
                if (isArray(args)) {
                    args = args.slice();
                    args.unshift(data);
                } else {
                    args = slice.call(arguments, 1);
                }
                length = args.length;

                if (length === 2) {
                    value = rule.call(rules, args[0], args[1]);
                } else if (length === 3) {
                    value = rule.call(rules, args[0], args[1], args[2]);
                } else if (length === 4) {
                    value = rule.call(rules, args[0], args[1], args[2], args[3]);
                } else {
                    value = rule.apply(rules, args);
                }
            } else {
                value = rules[ruleName](data);
            }

            if (!value) {
                return {
                    rule: ruleName,
                    data: data,
                    args: args ? args.slice(1) : null
                };
            }

            return null;
        };


    },
    function(require, exports, module, global) {

        var Buffer = require(45).Buffer;
        var isEmpty = require(49),
            isArray = require(25),
            isUndefined = require(51),
            isObject = require(13),
            isFunction = require(6),
            isString = require(23),
            isNumber = require(52),
            isFinitePolyfill = require(53),
            isNull = require(54),
            isBoolean = require(28),
            validations = require(55);


        var rules = module.exports;


        rules.type = function(str, typeStr) {
            var rule = rules[typeStr];
            return rule && isFunction(rule) ? rule(str) : false;
        };

        rules.empty = isEmpty;

        rules.not_empty = rules.notempty = rules.notEmpty = function(obj) {
            if (!obj && obj !== 0) {
                obj = "";
            } else if (typeof(obj.toString) !== "undefined") {
                obj = obj.toString();
            } else {
                obj = "" + obj;
            }

            return !validations.isNull(obj);
        };

        rules.required = function(obj) {
            if (!obj && obj !== 0) {
                obj = "";
            } else if (typeof(obj.toString) !== "undefined") {
                obj = obj.toString();
            } else {
                obj = "" + obj;
            }

            return !validations.isNull(obj);
        };

        rules["undefined"] = isUndefined;

        rules.object = isObject;

        rules.json = function(obj) {
            if (obj === undefined || obj === null) return false;
            try {
                JSON.stringify(obj);
            } catch (e) {
                return false;
            }
            return true;
        };

        rules.text = isString;

        rules.string = isString;

        rules.alpha = validations.isAlpha;

        rules.alpha_dashed = rules.alphadashed = rules.alphaDashed = validations.isAlphaDashed;

        rules.numeric = validations.isNumeric;

        rules.alpha_numeric = rules.alphanumeric = rules.alphaNumeric = validations.isAlphaNumeric;

        rules.alpha_numeric_dashed = rules.alphanumericdashed = rules.alphaNumericDashed = validations.isAlphaNumericDashed;

        rules.email = validations.isEmail;

        rules.url = validations.isURL;

        rules.urlish = validations.isURLish;

        rules.ip = validations.isIP;

        rules.ipv4 = validations.isIPv4;

        rules.ipv6 = validations.isIPv6;

        rules.credit_card = rules.creditcard = rules.creditCard = validations.isCreditCard;

        rules.uuid = validations.isUUID;

        rules.uuidv3 = function(obj) {
            return validations.isUUID(obj, 3);
        };

        rules.uuidv4 = function(obj) {
            return validations.isUUID(obj, 4);
        };

        rules["int"] = validations.isInt;

        rules.integer = validations.isInt;

        rules.number = isNumber;

        rules.finite = isFinitePolyfill;

        rules.decimal = validations.isFloat;

        rules["float"] = validations.isFloat;

        rules.falsey = function(obj) {
            return !obj;
        };

        rules.truthy = function(obj) {
            return !!obj;
        };

        rules["null"] = isNull;

        rules.not_null = rules.notnull = rules.notNull = function(obj) {
            return !validations.isNull(obj);
        };

        rules.bool = rules["boolean"] = isBoolean;

        rules.array = isArray;

        rules.binary = function(obj) {
            return Buffer.isBuffer(obj) || isString(obj);
        };

        rules.date = validations.isDate;

        rules.date_time = rules.datetime = validations.isDate;

        rules.hexa_decimal = rules.hexadecimal = validations.isHexadecimal;

        rules.hex_color = rules.hexcolor = validations.isHexColor;

        rules.lowercase = validations.isLowercase;

        rules.uppercase = validations.isUppercase;

        rules.after = validations.isAfter;

        rules.before = validations.isBefore;

        rules.equals = validations.equals;

        rules.contains = validations.contains;

        rules.not_contains = rules.notcontains = rules.notContains = function(obj, str) {
            return !validations.contains(obj, str);
        };

        rules.length = rules.len = function(obj, min, max) {
            obj = validations.toString(obj);
            return obj.length >= min && (max != null ? obj.length <= max : true);
        };

        rules["in"] = validations.isIn;

        rules.not_in = rules.notIn = function(str, options) {
            return !validations.isIn(str, options);
        };

        rules.max = function(str, num) {
            var number = parseFloat(str);
            return isNaN(number) || number <= num;
        };

        rules.min = function(str, num) {
            var number = parseFloat(str);
            return isNaN(number) || number >= num;
        };

        rules.greater_than = rules.greaterthan = rules.greaterThan = function(str, num) {
            var number = parseFloat(str);
            return isNaN(number) || number > num;
        };

        rules.less_than = rules.lessthan = rules.lessThan = function(str, num) {
            var number = parseFloat(str);
            return isNaN(number) || number < num;
        };

        rules.max_length = rules.maxlength = rules.maxLength = function(str, max) {
            return validations.isLength(str, 0, max);
        };

        rules.min_length = rules.minlength = rules.minLength = function(str, min) {
            return validations.isLength(str, min);
        };

        rules.regex = function(str, regex) {
            return validations.matches(str, regex);
        };

        rules.not_regex = rules.notregex = rules.notRegex = function(str, regex) {
            return !validations.matches(str, regex);
        };


    },
    function(require, exports, module, global) {

        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */

        var base64 = require(46)
        var ieee754 = require(47)
        var isArray = require(48)

        exports.Buffer = Buffer
        exports.SlowBuffer = Buffer
        exports.INSPECT_MAX_BYTES = 50
        Buffer.poolSize = 8192 // not used by this implementation

        var kMaxLength = 0x3fffffff

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Note:
         *
         * - Implementation must support adding new properties to `Uint8Array` instances.
         *   Firefox 4-29 lacked support, fixed in Firefox 30+.
         *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *    incorrect length in some situations.
         *
         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
         * get the Object implementation, which is slower but will work correctly.
         */
        Buffer.TYPED_ARRAY_SUPPORT = (function() {
            try {
                var buf = new ArrayBuffer(0)
                var arr = new Uint8Array(buf)
                arr.foo = function() {
                    return 42
                }
                return 42 === arr.foo() && // typed array instances can be augmented
                    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                    new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
            } catch (e) {
                return false
            }
        })()

        /**
         * Class: Buffer
         * =============
         *
         * The Buffer constructor returns instances of `Uint8Array` that are augmented
         * with function properties for all the node `Buffer` API functions. We use
         * `Uint8Array` so that square bracket notation works as expected -- it returns
         * a single octet.
         *
         * By augmenting the instances, we can avoid modifying the `Uint8Array`
         * prototype.
         */
        function Buffer(subject, encoding, noZero) {
            if (!(this instanceof Buffer))
                return new Buffer(subject, encoding, noZero)

            var type = typeof subject

            // Find the length
            var length
            if (type === 'number')
                length = subject > 0 ? subject >>> 0 : 0
            else if (type === 'string') {
                if (encoding === 'base64')
                    subject = base64clean(subject)
                length = Buffer.byteLength(subject, encoding)
            } else if (type === 'object' && subject !== null) { // assume object is array-like
                if (subject.type === 'Buffer' && isArray(subject.data))
                    subject = subject.data
                length = +subject.length > 0 ? Math.floor(+subject.length) : 0
            } else
                throw new TypeError('must start with number, buffer, array or string')

            if (this.length > kMaxLength)
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                    'size: 0x' + kMaxLength.toString(16) + ' bytes')

            var buf
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Preferred: Return an augmented `Uint8Array` instance for best performance
                buf = Buffer._augment(new Uint8Array(length))
            } else {
                // Fallback: Return THIS instance of Buffer (created by `new`)
                buf = this
                buf.length = length
                buf._isBuffer = true
            }

            var i
            if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
                // Speed optimization -- use set if we're copying from a typed array
                buf._set(subject)
            } else if (isArrayish(subject)) {
                // Treat array-ish objects as a byte array
                if (Buffer.isBuffer(subject)) {
                    for (i = 0; i < length; i++)
                        buf[i] = subject.readUInt8(i)
                } else {
                    for (i = 0; i < length; i++)
                        buf[i] = ((subject[i] % 256) + 256) % 256
                }
            } else if (type === 'string') {
                buf.write(subject, 0, encoding)
            } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
                for (i = 0; i < length; i++) {
                    buf[i] = 0
                }
            }

            return buf
        }

        Buffer.isBuffer = function(b) {
            return !!(b != null && b._isBuffer)
        }

        Buffer.compare = function(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
                throw new TypeError('Arguments must be Buffers')

            var x = a.length
            var y = b.length
            for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
            if (i !== len) {
                x = a[i]
                y = b[i]
            }
            if (x < y) return -1
            if (y < x) return 1
            return 0
        }

        Buffer.isEncoding = function(encoding) {
            switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'raw':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    return true
                default:
                    return false
            }
        }

        Buffer.concat = function(list, totalLength) {
            if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

            if (list.length === 0) {
                return new Buffer(0)
            } else if (list.length === 1) {
                return list[0]
            }

            var i
            if (totalLength === undefined) {
                totalLength = 0
                for (i = 0; i < list.length; i++) {
                    totalLength += list[i].length
                }
            }

            var buf = new Buffer(totalLength)
            var pos = 0
            for (i = 0; i < list.length; i++) {
                var item = list[i]
                item.copy(buf, pos)
                pos += item.length
            }
            return buf
        }

        Buffer.byteLength = function(str, encoding) {
            var ret
            str = str + ''
            switch (encoding || 'utf8') {
                case 'ascii':
                case 'binary':
                case 'raw':
                    ret = str.length
                    break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    ret = str.length * 2
                    break
                case 'hex':
                    ret = str.length >>> 1
                    break
                case 'utf8':
                case 'utf-8':
                    ret = utf8ToBytes(str).length
                    break
                case 'base64':
                    ret = base64ToBytes(str).length
                    break
                default:
                    ret = str.length
            }
            return ret
        }

        // pre-set for values that may exist in the future
        Buffer.prototype.length = undefined
        Buffer.prototype.parent = undefined

        // toString(encoding, start=0, end=buffer.length)
        Buffer.prototype.toString = function(encoding, start, end) {
            var loweredCase = false

            start = start >>> 0
            end = end === undefined || end === Infinity ? this.length : end >>> 0

            if (!encoding) encoding = 'utf8'
            if (start < 0) start = 0
            if (end > this.length) end = this.length
            if (end <= start) return ''

            while (true) {
                switch (encoding) {
                    case 'hex':
                        return hexSlice(this, start, end)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Slice(this, start, end)

                    case 'ascii':
                        return asciiSlice(this, start, end)

                    case 'binary':
                        return binarySlice(this, start, end)

                    case 'base64':
                        return base64Slice(this, start, end)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return utf16leSlice(this, start, end)

                    default:
                        if (loweredCase)
                            throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = (encoding + '').toLowerCase()
                        loweredCase = true
                }
            }
        }

        Buffer.prototype.equals = function(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function() {
            var str = ''
            var max = exports.INSPECT_MAX_BYTES
            if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                if (this.length > max)
                    str += ' ... '
            }
            return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            return Buffer.compare(this, b)
        }

        // `get` will be removed in Node 0.13+
        Buffer.prototype.get = function(offset) {
            console.log('.get() is deprecated. Access using array indexes instead.')
            return this.readUInt8(offset)
        }

        // `set` will be removed in Node 0.13+
        Buffer.prototype.set = function(v, offset) {
            console.log('.set() is deprecated. Access using array indexes instead.')
            return this.writeUInt8(v, offset)
        }

        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }

            // must be an even number of digits
            var strLen = string.length
            if (strLen % 2 !== 0) throw new Error('Invalid hex string')

            if (length > strLen / 2) {
                length = strLen / 2
            }
            for (var i = 0; i < length; i++) {
                var byte = parseInt(string.substr(i * 2, 2), 16)
                if (isNaN(byte)) throw new Error('Invalid hex string')
                buf[offset + i] = byte
            }
            return i
        }

        function utf8Write(buf, string, offset, length) {
            var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
            return charsWritten
        }

        function asciiWrite(buf, string, offset, length) {
            var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
            return charsWritten
        }

        function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
            var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
            return charsWritten
        }

        function utf16leWrite(buf, string, offset, length) {
            var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
            return charsWritten
        }

        Buffer.prototype.write = function(string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length
                    length = undefined
                }
            } else { // legacy
                var swap = encoding
                encoding = offset
                offset = length
                length = swap
            }

            offset = Number(offset) || 0
            var remaining = this.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase()

            var ret
            switch (encoding) {
                case 'hex':
                    ret = hexWrite(this, string, offset, length)
                    break
                case 'utf8':
                case 'utf-8':
                    ret = utf8Write(this, string, offset, length)
                    break
                case 'ascii':
                    ret = asciiWrite(this, string, offset, length)
                    break
                case 'binary':
                    ret = binaryWrite(this, string, offset, length)
                    break
                case 'base64':
                    ret = base64Write(this, string, offset, length)
                    break
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    ret = utf16leWrite(this, string, offset, length)
                    break
                default:
                    throw new TypeError('Unknown encoding: ' + encoding)
            }
            return ret
        }

        Buffer.prototype.toJSON = function() {
            return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }

        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf)
            } else {
                return base64.fromByteArray(buf.slice(start, end))
            }
        }

        function utf8Slice(buf, start, end) {
            var res = ''
            var tmp = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                if (buf[i] <= 0x7F) {
                    res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
                    tmp = ''
                } else {
                    tmp += '%' + buf[i].toString(16)
                }
            }

            return res + decodeUtf8Char(tmp)
        }

        function asciiSlice(buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i])
            }
            return ret
        }

        function binarySlice(buf, start, end) {
            return asciiSlice(buf, start, end)
        }

        function hexSlice(buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; i++) {
                out += toHex(buf[i])
            }
            return out
        }

        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
            }
            return res
        }

        Buffer.prototype.slice = function(start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
                start += len;
                if (start < 0)
                    start = 0
            } else if (start > len) {
                start = len
            }

            if (end < 0) {
                end += len
                if (end < 0)
                    end = 0
            } else if (end > len) {
                end = len
            }

            if (end < start)
                end = start

            if (Buffer.TYPED_ARRAY_SUPPORT) {
                return Buffer._augment(this.subarray(start, end))
            } else {
                var sliceLen = end - start
                var newBuf = new Buffer(sliceLen, undefined, true)
                for (var i = 0; i < sliceLen; i++) {
                    newBuf[i] = this[i + start]
                }
                return newBuf
            }
        }

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset(offset, ext, length) {
            if ((offset % 1) !== 0 || offset < 0)
                throw new RangeError('offset is not uint')
            if (offset + ext > length)
                throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUInt8 = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 1, this.length)
            return this[offset]
        }

        Buffer.prototype.readUInt16LE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 2, this.length)
            return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 2, this.length)
            return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 4, this.length)

            return ((this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 4, this.length)

            return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
        }

        Buffer.prototype.readInt8 = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 1, this.length)
            if (!(this[offset] & 0x80))
                return (this[offset])
            return ((0xff - this[offset] + 1) * -1)
        }

        Buffer.prototype.readInt16LE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 2, this.length)
            var val = this[offset] | (this[offset + 1] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 2, this.length)
            var val = this[offset + 1] | (this[offset] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 4, this.length)

            return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 4, this.length)

            return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function(offset, noAssert) {
            if (!noAssert)
                checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
            if (value > max || value < min) throw new TypeError('value is out of bounds')
            if (offset + ext > buf.length) throw new TypeError('index out of range')
        }

        Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 1, 0xff, 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            this[offset] = value
            return offset + 1
        }

        function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                    (littleEndian ? i : 1 - i) * 8
            }
        }

        Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value
                this[offset + 1] = (value >>> 8)
            } else objectWriteUInt16(this, value, offset, true)
            return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8)
                this[offset + 1] = value
            } else objectWriteUInt16(this, value, offset, false)
            return offset + 2
        }

        function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffffffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
            }
        }

        Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24)
                this[offset + 2] = (value >>> 16)
                this[offset + 1] = (value >>> 8)
                this[offset] = value
            } else objectWriteUInt32(this, value, offset, true)
            return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = value
            } else objectWriteUInt32(this, value, offset, false)
            return offset + 4
        }

        Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 1, 0x7f, -0x80)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            if (value < 0) value = 0xff + value + 1
            this[offset] = value
            return offset + 1
        }

        Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value
                this[offset + 1] = (value >>> 8)
            } else objectWriteUInt16(this, value, offset, true)
            return offset + 2
        }

        Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8)
                this[offset + 1] = value
            } else objectWriteUInt16(this, value, offset, false)
            return offset + 2
        }

        Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value
                this[offset + 1] = (value >>> 8)
                this[offset + 2] = (value >>> 16)
                this[offset + 3] = (value >>> 24)
            } else objectWriteUInt32(this, value, offset, true)
            return offset + 4
        }

        Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
                checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (value < 0) value = 0xffffffff + value + 1
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = value
            } else objectWriteUInt32(this, value, offset, false)
            return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min) throw new TypeError('value is out of bounds')
            if (offset + ext > buf.length) throw new TypeError('index out of range')
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert)
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
        }

        Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert)
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function(target, target_start, start, end) {
            var source = this

            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (!target_start) target_start = 0

            // Copy 0 bytes; we're done
            if (end === start) return
            if (target.length === 0 || source.length === 0) return

            // Fatal error conditions
            if (end < start) throw new TypeError('sourceEnd < sourceStart')
            if (target_start < 0 || target_start >= target.length)
                throw new TypeError('targetStart out of bounds')
            if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
            if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length)
                end = this.length
            if (target.length - target_start < end - start)
                end = target.length - target_start + start

            var len = end - start

            if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < len; i++) {
                    target[i + target_start] = this[i + start]
                }
            } else {
                target._set(this.subarray(start, start + len), target_start)
            }
        }

        // fill(value, start=0, end=buffer.length)
        Buffer.prototype.fill = function(value, start, end) {
            if (!value) value = 0
            if (!start) start = 0
            if (!end) end = this.length

            if (end < start) throw new TypeError('end < start')

            // Fill 0 bytes; we're done
            if (end === start) return
            if (this.length === 0) return

            if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
            if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

            var i
            if (typeof value === 'number') {
                for (i = start; i < end; i++) {
                    this[i] = value
                }
            } else {
                var bytes = utf8ToBytes(value.toString())
                var len = bytes.length
                for (i = start; i < end; i++) {
                    this[i] = bytes[i % len]
                }
            }

            return this
        }

        /**
         * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
         * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
         */
        Buffer.prototype.toArrayBuffer = function() {
            if (typeof Uint8Array !== 'undefined') {
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    return (new Buffer(this)).buffer
                } else {
                    var buf = new Uint8Array(this.length)
                    for (var i = 0, len = buf.length; i < len; i += 1) {
                        buf[i] = this[i]
                    }
                    return buf.buffer
                }
            } else {
                throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
            }
        }

        // HELPER FUNCTIONS
        // ================

        var BP = Buffer.prototype

        /**
         * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
         */
        Buffer._augment = function(arr) {
            arr.constructor = Buffer
            arr._isBuffer = true

            // save reference to original Uint8Array get/set methods before overwriting
            arr._get = arr.get
            arr._set = arr.set

            // deprecated, will be removed in node 0.13+
            arr.get = BP.get
            arr.set = BP.set

            arr.write = BP.write
            arr.toString = BP.toString
            arr.toLocaleString = BP.toString
            arr.toJSON = BP.toJSON
            arr.equals = BP.equals
            arr.compare = BP.compare
            arr.copy = BP.copy
            arr.slice = BP.slice
            arr.readUInt8 = BP.readUInt8
            arr.readUInt16LE = BP.readUInt16LE
            arr.readUInt16BE = BP.readUInt16BE
            arr.readUInt32LE = BP.readUInt32LE
            arr.readUInt32BE = BP.readUInt32BE
            arr.readInt8 = BP.readInt8
            arr.readInt16LE = BP.readInt16LE
            arr.readInt16BE = BP.readInt16BE
            arr.readInt32LE = BP.readInt32LE
            arr.readInt32BE = BP.readInt32BE
            arr.readFloatLE = BP.readFloatLE
            arr.readFloatBE = BP.readFloatBE
            arr.readDoubleLE = BP.readDoubleLE
            arr.readDoubleBE = BP.readDoubleBE
            arr.writeUInt8 = BP.writeUInt8
            arr.writeUInt16LE = BP.writeUInt16LE
            arr.writeUInt16BE = BP.writeUInt16BE
            arr.writeUInt32LE = BP.writeUInt32LE
            arr.writeUInt32BE = BP.writeUInt32BE
            arr.writeInt8 = BP.writeInt8
            arr.writeInt16LE = BP.writeInt16LE
            arr.writeInt16BE = BP.writeInt16BE
            arr.writeInt32LE = BP.writeInt32LE
            arr.writeInt32BE = BP.writeInt32BE
            arr.writeFloatLE = BP.writeFloatLE
            arr.writeFloatBE = BP.writeFloatBE
            arr.writeDoubleLE = BP.writeDoubleLE
            arr.writeDoubleBE = BP.writeDoubleBE
            arr.fill = BP.fill
            arr.inspect = BP.inspect
            arr.toArrayBuffer = BP.toArrayBuffer

            return arr
        }

        var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

        function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
                str = str + '='
            }
            return str
        }

        function stringtrim(str) {
            if (str.trim) return str.trim()
            return str.replace(/^\s+|\s+$/g, '')
        }

        function isArrayish(subject) {
            return isArray(subject) || Buffer.isBuffer(subject) ||
                subject && typeof subject === 'object' &&
                typeof subject.length === 'number'
        }

        function toHex(n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
        }

        function utf8ToBytes(str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                var b = str.charCodeAt(i)
                if (b <= 0x7F) {
                    byteArray.push(b)
                } else {
                    var start = i
                    if (b >= 0xD800 && b <= 0xDFFF) i++
                        var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%')
                    for (var j = 0; j < h.length; j++) {
                        byteArray.push(parseInt(h[j], 16))
                    }
                }
            }
            return byteArray
        }

        function asciiToBytes(str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF)
            }
            return byteArray
        }

        function utf16leToBytes(str) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                c = str.charCodeAt(i)
                hi = c >> 8
                lo = c % 256
                byteArray.push(lo)
                byteArray.push(hi)
            }

            return byteArray
        }

        function base64ToBytes(str) {
            return base64.toByteArray(str)
        }

        function blitBuffer(src, dst, offset, length, unitSize) {
            if (unitSize) length -= length % unitSize;
            for (var i = 0; i < length; i++) {
                if ((i + offset >= dst.length) || (i >= src.length))
                    break
                dst[i + offset] = src[i]
            }
            return i
        }

        function decodeUtf8Char(str) {
            try {
                return decodeURIComponent(str)
            } catch (err) {
                return String.fromCharCode(0xFFFD) // UTF 8 invalid char
            }
        }


    },
    function(require, exports, module, global) {

        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

        ;
        (function(exports) {
            'use strict';

            var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array

            var PLUS = '+'.charCodeAt(0)
            var SLASH = '/'.charCodeAt(0)
            var NUMBER = '0'.charCodeAt(0)
            var LOWER = 'a'.charCodeAt(0)
            var UPPER = 'A'.charCodeAt(0)

            function decode(elt) {
                var code = elt.charCodeAt(0)
                if (code === PLUS)
                    return 62 // '+'
                if (code === SLASH)
                    return 63 // '/'
                if (code < NUMBER)
                    return -1 //no match
                if (code < NUMBER + 10)
                    return code - NUMBER + 26 + 26
                if (code < UPPER + 26)
                    return code - UPPER
                if (code < LOWER + 26)
                    return code - LOWER + 26
            }

            function b64ToByteArray(b64) {
                var i, j, l, tmp, placeHolders, arr

                if (b64.length % 4 > 0) {
                    throw new Error('Invalid string. Length must be a multiple of 4')
                }

                // the number of equal signs (place holders)
                // if there are two placeholders, than the two characters before it
                // represent one byte
                // if there is only one, then the three characters before it represent 2 bytes
                // this is just a cheap hack to not do indexOf twice
                var len = b64.length
                placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

                // base64 is 4/3 + up to two characters of the original data
                arr = new Arr(b64.length * 3 / 4 - placeHolders)

                // if there are placeholders, only get up to the last complete 4 chars
                l = placeHolders > 0 ? b64.length - 4 : b64.length

                var L = 0

                function push(v) {
                    arr[L++] = v
                }

                for (i = 0, j = 0; i < l; i += 4, j += 3) {
                    tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                    push((tmp & 0xFF0000) >> 16)
                    push((tmp & 0xFF00) >> 8)
                    push(tmp & 0xFF)
                }

                if (placeHolders === 2) {
                    tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                    push(tmp & 0xFF)
                } else if (placeHolders === 1) {
                    tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                    push((tmp >> 8) & 0xFF)
                    push(tmp & 0xFF)
                }

                return arr
            }

            function uint8ToBase64(uint8) {
                var i,
                    extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                    output = "",
                    temp, length

                function encode(num) {
                    return lookup.charAt(num)
                }

                function tripletToBase64(num) {
                    return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
                }

                // go through the array every three bytes, we'll deal with trailing stuff later
                for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                    output += tripletToBase64(temp)
                }

                // pad the end with zeros, but make sure to not forget the extra bytes
                switch (extraBytes) {
                    case 1:
                        temp = uint8[uint8.length - 1]
                        output += encode(temp >> 2)
                        output += encode((temp << 4) & 0x3F)
                        output += '=='
                        break
                    case 2:
                        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                        output += encode(temp >> 10)
                        output += encode((temp >> 4) & 0x3F)
                        output += encode((temp << 2) & 0x3F)
                        output += '='
                        break
                }

                return output
            }

            exports.toByteArray = b64ToByteArray
            exports.fromByteArray = uint8ToBase64
        }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))


    },
    function(require, exports, module, global) {

        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                nBits = -7,
                i = isLE ? (nBytes - 1) : 0,
                d = isLE ? -1 : 1,
                s = buffer[offset + i];

            i += d;

            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
                i = isLE ? 0 : (nBytes - 1),
                d = isLE ? 1 : -1,
                s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }

                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

            buffer[offset + i - d] |= s * 128;
        };


    },
    function(require, exports, module, global) {


        /**
         * isArray
         */

        var isArray = Array.isArray;

        /**
         * toString
         */

        var str = Object.prototype.toString;

        /**
         * Whether or not the given `val`
         * is an array.
         *
         * example:
         *
         *        isArray([]);
         *        // > true
         *        isArray(arguments);
         *        // > false
         *        isArray('');
         *        // > false
         *
         * @param {mixed} val
         * @return {bool}
         */

        module.exports = isArray || function(val) {
            return !!val && '[object Array]' == str.call(val);
        };


    },
    function(require, exports, module, global) {

        var isString = require(23),
            has = require(11),
            isArrayLike = require(50);


        function isObjectEmpty(object) {
            var localHas = has,
                key;

            for (key in object) {
                if (localHas(object, key)) {
                    return false;
                }
            }

            return true;
        }

        module.exports = function isEmpty(obj) {
            return (
                obj == null ? true : (
                    isString(obj) || isArrayLike(obj) ? obj.length === 0 : isObjectEmpty(obj)
                )
            );
        };


    },
    function(require, exports, module, global) {

        var isLength = require(20),
            isObjectLike = require(19);


        var objectToString = Object.prototype.toString,
            objectArrayBufferString = "[object ArrayBuffer]",
            arrayLikeStrings = {
                "[object Array]": true,
                "[object Arguments]": true,
                "[object Float32Array]": true,
                "[object Float64Array]": true,
                "[object Int8Array]": true,
                "[object Int16Array]": true,
                "[object Int32Array]": true,
                "[object Uint8Array]": true,
                "[object Uint8ClampedArray]": true,
                "[object Uint16Array]": true,
                "[object Uint32Array]": true
            };


        arrayLikeStrings[objectArrayBufferString] = true;


        module.exports = function isArrayLike(obj) {
            var isObject = isObjectLike(obj),
                objectString = isObject && objectToString.call(obj);

            return isObject && (
                objectString !== objectArrayBufferString ? (
                    isLength(obj.length) && arrayLikeStrings[objectString]
                ) : true
            ) || false;
        };


    },
    function(require, exports, module, global) {

        module.exports = function isUndefined(obj) {
            return obj === void 0;
        };


    },
    function(require, exports, module, global) {

        module.exports = function isNumber(obj) {
            return typeof(obj) === "number" || false;
        };


    },
    function(require, exports, module, global) {

        module.exports = Number.isFinite || function isFinite(obj) {
            return !(
                typeof(obj) !== "number" ||
                (obj !== obj || obj === Infinity || obj === -Infinity) ||
                false
            );
        };


    },
    function(require, exports, module, global) {

        module.exports = function isNull(obj) {
            return obj === null;
        };


    },
    function(require, exports, module, global) {

        var mixin = require(14),
            isArray = require(25),
            isNaNPolyfill = require(56),
            isDate = require(57),
            isBoolean = require(28),
            isInteger = require(58),
            isDecimal = require(59),
            isRegExp = require(60),
            isNumber = require(52);


        var validations = module.exports,

            EMAIL = /^((([a-z]|\d|[!#\$%&"\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&"\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
            URLISH = /^\s([^\/]+\.)+.+\s*$/g,

            CREDIT_CARD = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,

            ISBN_10_MAYBE = /^(?:[0-9]{9}X|[0-9]{10})$/,
            ISBN_13_MAYBE = /^(?:[0-9]{13})$/,

            IPv4_MAYBE = /^(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)$/,
            IPv6 = /^::|^::1|^([a-fA-F0-9]{1,4}::?){1,7}([a-fA-F0-9]{1,4})$/,

            ALPHA = /^[a-zA-Z]+$/,
            ALPHA_DASHED = /^[a-zA-Z-_]*$/,
            ALPHA_NUMERIC = /^[a-zA-Z0-9]+$/,
            ALPHA_NUMERIC_DASHED = /^[a-zA-Z0-9-_]*$/,
            NUMERIC = /^-?[0-9]+$/,
            INT = /^(?:-?(?:0|[1-9][0-9]*))$/,
            FLOAT = /^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/,
            HEXADECIMAL = /^[0-9a-fA-F]+$/,
            HEX_COLOR = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/,

            UUID = {
                "3": /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
                "4": /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                "5": /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
            },

            ASCII = /^[\x00-\x7F]+$/,
            MULTIBYTE = /[^\x00-\x7F]/,
            FULLWIDTH = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/,
            HALFWIDTH = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/,

            SURROGATE_PAIR = /[\uD800-\uDBFF][\uDC00-\uDFFF]/,
            SURROGATE_PAIRS = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,

            BASE_64 = /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/,

            SPACES = /[\s-]+/g,
            NOT_NUMBERS = /[^0-9]+/g;

        validations.toString = function(obj) {
            if (typeof(obj) === "object" && obj !== null && obj.toString) {
                obj = obj.toString();
            } else if (obj === null || typeof(obj) === "undefined" || (isNaNPolyfill(obj) && !obj.length)) {
                obj = "";
            } else if (typeof(obj) !== "string") {
                obj += "";
            }

            return obj;
        };

        validations.toDate = function(date) {
            if (isDate(date)) return data;
            if (isNumber(date)) return new Date(date);
            date = Date.parse(date);
            return !isNaNPolyfill(date) ? new Date(date) : null;
        };

        validations.toFloat = function(str) {
            return typeof(str) === "number" ? str : parseFloat(str);
        };

        validations.toInt = function(str, radix) {
            return typeof(str) === "number" ? str : parseInt(str, radix || 10);
        };

        validations.toBoolean = function(str, strict) {
            if (isBoolean(str)) return !!str;
            if (strict) return str === "1" || str === "true";
            return str !== "0" && str !== "false" && str !== "";
        };

        validations.equals = function(str, comparison) {
            str = validations.toString(str);

            return str === validations.toString(comparison);
        };

        validations.contains = function(str, elem) {
            str = validations.toString(str);

            return str.indexOf(validations.toString(elem)) >= 0;
        };

        validations.matches = function(str, pattern, modifiers) {
            str = validations.toString(str);

            if (!isRegExp(pattern)) {
                pattern = new RegExp(pattern, modifiers);
            }
            return pattern.test(str);
        };

        validations.isEmail = function(str) {
            str = validations.toString(str);

            return EMAIL.test(str);
        };

        var defaultURLOptions = {
            protocols: ["http", "https", "ftp"],
            requireTLD: true,
            requireProtocol: false,
            allowUnderscores: false
        };
        validations.isURL = function(str, options) {
            str = validations.toString(str);

            if (!str || str.length >= 2083) {
                return false;
            }
            options = mixin(options || {}, defaultURLOptions);
            var separators = "-?-?" + (options.allowUnderscores ? "_?" : ""),
                url = new RegExp("^(?!mailto:)(?:(?:" + options.protocols.join("|") + ")://)" + (options.requireProtocol ? "" : "?") + "(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:www.)?)?(?:(?:[a-z\\u00a1-\\uffff0-9]+" + separators + ")*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+" + separators + ")*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" + (options.requireTLD ? "" : "?") + ")|localhost)(?::(\\d{1,5}))?(?:(?:/|\\?|#)[^\\s]*)?$", "i"),
                match = str.match(url),
                port = match ? match[1] : 0;

            return !!(match && (!port || (port > 0 && port <= 65535)));
        };

        validations.isURLish = function(str) {
            str = validations.toString(str);

            return URLISH.test(str);
        };

        validations.isIP = function(str, version) {
            str = validations.toString(str);

            version = validations.toString(version);
            var parts;

            if (!version) {
                return validations.isIP(str, 4) || validations.isIP(str, 6);
            } else if (version === "4") {
                if (!IPv4_MAYBE.test(str)) return false;
                parts = str.split(".").sort();
                return parts[3] <= 255;
            }

            return version === "6" && IPv6.test(str);
        };

        validations.isIPv4 = function(str) {
            return validations.isIP(str, 4);
        };

        validations.isIPv6 = function(str) {
            return validations.isIP(str, 6);
        };

        validations.isAlpha = function(str) {
            str = validations.toString(str);

            return ALPHA.test(str);
        };

        validations.isAlphaDashed = function(str) {
            str = validations.toString(str);

            return ALPHA_DASHED.test(str);
        };

        validations.isAlphaNumeric = function(str) {
            str = validations.toString(str);

            return ALPHA_NUMERIC.test(str);
        };

        validations.isAlphaNumericDashed = function(str) {
            str = validations.toString(str);

            return ALPHA_NUMERIC_DASHED.test(str);
        };

        validations.isNumeric = function(str) {
            str = validations.toString(str);

            return NUMERIC.test(str);
        };

        validations.isHexadecimal = function(str) {
            str = validations.toString(str);

            return HEXADECIMAL.test(str);
        };

        validations.isHexColor = function(str) {
            str = validations.toString(str);

            return HEX_COLOR.test(str);
        };

        validations.isLowercase = function(str) {

            return str === str.toLowerCase();
        };

        validations.isUppercase = function(str) {

            return str === str.toUpperCase();
        };

        validations.isInt = function(str) {

            return isInteger(str) || INT.test(validations.toString(str));
        };

        validations.isFloat = function(str) {

            return isDecimal(str) || FLOAT.test(validations.toString(str));
        };

        validations.isDivisibleBy = function(str, num) {
            if (isString(str)) {
                str = validations.toFloat(str);
            }

            return str % validations.toInt(num) === 0;
        };

        validations.isNull = function(str) {

            return validations.toString(str).length === 0;
        };

        validations.isLength = function(str, min, max) {
            str = validations.toString(str);
            var surrogatePairs = str.match(SURROGATE_PAIRS) || [],
                len = str.length - surrogatePairs.length;

            return len >= min && (typeof(max) === "undefined" || len <= max);
        };

        validations.isByteLength = function(str, min, max) {
            str = validations.toString(str);

            return str.length >= min && (typeof(max) === "undefined" || str.length <= max);
        };

        validations.isUUID = function(str, version) {
            var pattern = UUID[version ? version : "all"];

            return pattern && pattern.test(validations.toString(str));
        };

        validations.isDate = function(str) {
            str = validations.toString(str);

            return !isNaNPolyfill(Date.parse(str));
        };

        validations.isAfter = function(str, date) {
            var comparison = validations.toDate(date || new Date()),
                original = validations.toDate(validations.toString(str));

            return !!(original && comparison && original > comparison);
        };

        validations.isBefore = function(str, date) {
            var comparison = validations.toDate(date || new Date()),
                original = validations.toDate(validations.toString(str));

            return original && comparison && original < comparison;
        };

        validations.isIn = function(str, options) {
            var i, array = options;

            if (!options || typeof(options.indexOf) !== "function") {
                return false;
            }
            if (isArray(options)) {
                i = options.length;
                array = [];

                while (i--) array.push(options[i]);
            }

            return array.indexOf(validations.toString(str)) !== -1;
        };

        validations.isCreditCard = function(str) {
            str = validations.toString(str);
            var sanitized = str.replace(NOT_NUMBERS, ""),
                sum = 0,
                digit, tmpNum, shouldDouble,
                i;

            if (!CREDIT_CARD.test(sanitized)) return false;

            for (i = sanitized.length - 1; i >= 0; i--) {
                digit = sanitized.substring(i, (i + 1));
                tmpNum = parseInt(digit, 10);

                if (shouldDouble) {
                    tmpNum *= 2;
                    if (tmpNum >= 10) {
                        sum += ((tmpNum % 10) + 1);
                    } else {
                        sum += tmpNum;
                    }
                } else {
                    sum += tmpNum;
                }
                shouldDouble = !shouldDouble;
            }
            return !!((sum % 10) === 0 ? sanitized : false);
        };

        validations.isISBN = function(str, version) {
            str = validations.toString(str);

            version = validations.toString(version);
            if (!version) return validations.isISBN(str, 10) || validations.isISBN(str, 13);

            var sanitized = str.replace(SPACES, ""),
                checksum = 0,
                i, factor;

            if (version === "10") {
                if (!ISBN_10_MAYBE.test(sanitized)) {
                    return false;
                }
                for (i = 0; i < 9; i++) {
                    checksum += (i + 1) * sanitized[i];
                }
                if (sanitized[9] === "X") {
                    checksum += 10 * 10;
                } else {
                    checksum += 10 * sanitized[9];
                }
                if ((checksum % 11) === 0) {
                    return !!sanitized;
                }
            } else if (version === "13") {
                if (!ISBN_13_MAYBE.test(sanitized)) {
                    return false;
                }
                factor = [1, 3];
                for (i = 0; i < 12; i++) {
                    checksum += factor[i % 2] * sanitized[i];
                }
                if (sanitized[12] - ((10 - (checksum % 10)) % 10) === 0) {
                    return !!sanitized;
                }
            }
            return false;
        };

        validations.isJSON = function(str) {
            str = validations.toString(str);

            try {
                JSON.parse(str);
            } catch (e) {
                return false;
            }
            return true;
        };

        validations.isMultibyte = function(str) {
            str = validations.toString(str);

            return MULTIBYTE.test(str);
        };

        validations.isAscii = function(str) {
            str = validations.toString(str);

            return ASCII.test(str);
        };

        validations.isFullWidth = function(str) {
            str = validations.toString(str);

            return FULLWIDTH.test(str);
        };

        validations.isHalfWidth = function(str) {
            str = validations.toString(str);

            return HALFWIDTH.test(str);
        };

        validations.isVariableWidth = function(str) {
            str = validations.toString(str);

            return FULLWIDTH.test(str) && HALFWIDTH.test(str);
        };

        validations.isSurrogatePair = function(str) {
            str = validations.toString(str);

            return SURROGATE_PAIR.test(str);
        };

        validations.isBase64 = function(str) {
            str = validations.toString(str);

            return BASE_64.test(str);
        };


    },
    function(require, exports, module, global) {

        var isNumber = require(52);


        module.exports = Number.isNaN || function isNaN(obj) {
            return isNumber(obj) && obj !== obj;
        };


    },
    function(require, exports, module, global) {

        var isObjectLike = require(19);


        var objectDateStr = "[object Date]",
            objectToString = Object.prototype.toString;


        module.exports = function isDate(obj) {
            return (isObjectLike(obj) && objectToString.call(obj) === objectDateStr) || false;
        };


    },
    function(require, exports, module, global) {

        var isNumber = require(52);


        module.exports = function isInteger(obj) {
            return isNumber(obj) && obj % 1 === 0;
        };


    },
    function(require, exports, module, global) {

        var isNumber = require(52);


        module.exports = function isDecimal(obj) {
            return isNumber(obj) && obj % 1 !== 0;
        };


    },
    function(require, exports, module, global) {

        var isObjectLike = require(19);


        var objectRegExpStr = "[object RegExp]",
            objectToString = Object.prototype.toString;


        module.exports = function isRegExp(obj) {
            return (isObjectLike(obj) && objectToString.call(obj) === objectRegExpStr) || false;
        };


    },
    function(require, exports, module, global) {

        var PromisePolyfill = require(40),
            extend = require(9);


        function Query(model, action, conditions) {

            this._model = model;
            this._action = action;

            this._currentKey = false;

            this._conditions = extend({}, conditions.where);

            delete conditions.where;
            this._params = conditions;
        }

        Query.prototype.where = function(key, value) {

            if (value === undefined) {
                this._currentKey = key;
            } else {
                this._conditions[key] = value;
                this._currentKey = false;
            }

            return this;
        };

        Query.prototype.range = function(key, from, to) {
            var currentKey = this._currentKey,
                conditions = this._conditions,
                condition;

            if (currentKey === false && to === undefined) {
                throw new Error("Query.range(from, to) no key is currently selected");
            }

            if (to === undefined) {
                if (currentKey !== false) {
                    to = from;
                    from = key;
                    condition = conditions[currentKey] || (conditions[currentKey] = {});

                    condition.gt = from;
                    condition.lt = to;
                }
            } else {
                this._currentKey = false;

                condition = conditions[key] || (conditions[key] = {});

                condition.gt = from;
                condition.lt = to;
            }
            return this;
        };

        Query.prototype.between = Query.prototype.range;

        ["gt", "gte", "lt", "lte", "in", "inq", "ne", "neq", "nin"].forEach(function(method) {
            Query.prototype[method] = function(key, value) {
                var conditions = this._conditions,
                    currentKey = this._currentKey;

                if (currentKey === false && value === undefined) {
                    throw new Error("Query." + method + "(value) no key is currently selected");
                }

                if (value === undefined) {
                    if (currentKey !== false) {
                        (conditions[currentKey] || (conditions[currentKey] = {}))[method] = key;
                    }
                } else {
                    (conditions[key] || (conditions[key] = {}))[method] = value;
                    this._currentKey = false;
                }

                return this;
            };
        });

        var NEGATIVE = /^-/;
        Query.prototype.order = function(key, value) {
            var params = this._params,
                param;

            this._currentKey = false;

            if (key === undefined && value === undefined) {
                throw new Error("Query.order(key, value) key and value, or key required");
            }

            if (value === undefined) {
                param = params.order || (params.order = []);

                if (NEGATIVE.test(key)) {
                    param[0] = key.replace(NEGATIVE, "");
                    param[1] = "DESC";
                } else {
                    param[0] = key;
                    param[1] = "ASC";
                }
            } else {
                param = params.order || (params.order = []);
                param[0] = key;
                param[1] = value.toUpperCase();
            }
            return this;
        };
        Query.prototype.sort = Query.prototype.order;

        ["skip", "limit"].forEach(function(method) {
            Query.prototype[method] = function(value) {
                this._currentKey = false;

                if (value === undefined) {
                    throw new Error("Query." + method + "(value) value required");
                }

                this._params[method] = value;
                return this;
            };
        });

        Query.prototype.asc = function(value) {
            var params = this._params,
                param = params.order || (params.order = []);

            this._currentKey = false;
            param[0] = value;
            param[1] = "ASC";

            return this;
        };

        Query.prototype.desc = function(value) {
            var params = this._params,
                param = params.order || (params.order = []);

            this._currentKey = false;
            param[0] = value;
            param[1] = "DESC";

            return this;
        };

        Query.prototype.exec = function(callback) {
            var query = extend({
                where: extend({}, this._conditions)
            }, this._params);

            this._model[this._action](query, callback);
        };

        Query.prototype.run = Query.prototype.exec;

        Query.prototype.then = function(onFulfill, onReject) {
            var defer = PromisePolyfill.defer(),
                query = extend({
                    where: extend({}, this._conditions)
                }, this._params);

            this._model[this._action](query, function(err, result) {
                if (err) {
                    defer.reject(err);
                    return;
                }

                defer.resolve(result);
            });

            return defer.promise.then(onFulfill, onReject);
        };


        module.exports = Query;


    },
    function(require, exports, module, global) {

        var hooks = module.exports;


        hooks.timestamps = function(options) {
            var underscore = options.underscore === true || options.camelcase === false;

            return {
                events: {
                    beforeCreate: function(values, next) {
                        if (underscore) {
                            values.created_at = new Date();
                            values.updated_at = new Date();
                        } else {
                            values.createdAt = new Date();
                            values.updatedAt = new Date();
                        }
                        next();
                    },
                    beforeSave: function(values, next) {
                        if (underscore) {
                            if (values.created_at == null) values.created_at = new Date();
                            if (values.updated_at == null) values.updated_at = new Date();
                        } else {
                            if (values.createdAt == null) values.createdAt = new Date();
                            if (values.updatedAt == null) values.updatedAt = new Date();
                        }
                        next();
                    },
                    beforeUpdate: function(values, next) {
                        if (underscore) {
                            values.updated_at = new Date();
                        } else {
                            values.updatedAt = new Date();
                        }
                        next();
                    }
                }
            };
        };


    },
    function(require, exports, module, global) {

        var process = require(1);
        var keys = require(10),
            indexOf = require(24),
            extend = require(9),
            isDate = require(57),
            isObject = require(13),
            forEach = require(17),
            map = require(64);


        function buildSort(columns, key, order) {
            var typeStr = columns[key].type;

            if (typeStr === "float" || typeStr === "integer") {
                return (
                    order === "ASC" ?
                    function sortNumber(a, b) {
                        return a[key] - b[key];
                    } :
                    function sortNumber(a, b) {
                        return b[key] - a[key];
                    }
                );
            } else if (typeStr === "string") {
                return (
                    order === "ASC" ?
                    function sortString(a, b) {
                        return a[key] < b[key] ? -1 : 1;
                    } :
                    function sortString(a, b) {
                        return a[key] < b[key] ? 1 : -1;
                    }
                );
            } else if (typeStr === "datetime") {
                return (
                    order === "ASC" ?
                    function sortDate(a, b) {
                        return Date.parse(a[key]) < Date.parse(b[key]) ? -1 : 1;
                    } :
                    function sortDate(a, b) {
                        return Date.parse(a[key]) < Date.parse(b[key]) ? 1 : -1;
                    }
                );
            } else {
                return false;
            }
        }

        function queryAll(columns, array, query) {
            var i = (query.skip || 0) - 1,
                il = array.length,

                where = query.where,
                objectKeys = keys(where),
                length = objectKeys.length,

                results = [],
                k = 0,

                limit = +query.limit,
                order = query.order,

                item, pass, j, key, sortFn;

            while (++i < il) {
                item = array[i];
                pass = true;

                j = length;
                while (j-- && pass) {
                    key = objectKeys[j];
                    pass = compare(columns[key], item[key], where[key]);
                }

                if (pass) {
                    results[k++] = item;
                    if (limit > -1 && k >= limit) {
                        break;
                    }
                }
            }

            if (order) {
                sortFn = buildSort(columns, order[0], order[1]);

                if (sortFn) {
                    results.sort(sortFn);
                }
            }

            return results;
        }

        function queryOne(columns, array, query) {
            var i = (query.skip || 0) - 1,
                il = array.length,

                where = query.where,
                objectKeys = keys(where),
                length = objectKeys.length,

                item, pass, j, key;

            while (++i < il) {
                item = array[i];
                pass = true;

                j = length;
                while (j-- && pass) {
                    key = objectKeys[j];
                    pass = compare(columns[key], item[key], where[key]);
                }

                if (pass) {
                    return item;
                }
            }

            return null;
        }

        function isUnique(array, key, value, id) {
            var i = array.length,
                row;

            while (i--) {
                row = array[i];
                if (row[key] === value && (id ? row.id !== id : true)) return false;
            }
            return true;
        }

        function compare(column, value, whereValue) {
            var columnType = column.type,
                key;

            if (isObject(whereValue)) {
                var pass = true;

                for (key in whereValue) {
                    if (columnType === "datetime") {
                        pass = conditions[key](Date.parse(value), Date.parse(whereValue[key]));
                    } else {
                        pass = conditions[key](value, whereValue[key]);
                    }
                }

                return pass;
            }

            return value === whereValue;
        }

        var conditions = {
            gt: function(a, b) {
                return a > b;
            },
            gte: function(a, b) {
                return a >= b;
            },
            lt: function(a, b) {
                return a < b;
            },
            lte: function(a, b) {
                return a <= b;
            },
            "in": function(a, b) {
                return indexOf(b, a) !== -1;
            },
            inq: function(a, b) {
                return indexOf(b, a) !== -1;
            },
            ne: function(a, b) {
                return a !== b;
            },
            neq: function(a, b) {
                return a !== b;
            },
            nin: function(a, b) {
                return indexOf(b, a) === -1;
            }
        };


        function MemoryAdapter() {

            this._collection = null;
            this._tables = {};
        }

        MemoryAdapter.prototype.init = function(callback) {
            var tables = this._tables,
                collection = this._collection,
                schema = collection && collection._schema;

            process.nextTick(function() {
                if (schema) {
                    forEach(schema.tables, function(tableSchema, tableName) {
                        var counters = {},
                            uniques = {};

                        forEach(tableSchema.columns, function(column, columnName) {
                            forEach(column, function(value, key) {
                                if (key === "autoIncrement") {
                                    counters[columnName] = 1;
                                } else if (key === "unique") {
                                    uniques[columnName] = true;
                                }
                            });
                        });

                        tables[tableName] = {
                            counters: counters,
                            uniques: uniques,
                            schema: tableSchema,
                            rows: []
                        };
                    });
                }

                callback();
            });
            return this;
        };

        MemoryAdapter.prototype.close = function() {

            return this;
        };

        MemoryAdapter.prototype.save = function(tableName, params, callback) {
            var table = this._tables[tableName],
                columns = table.schema.columns;

            process.nextTick(function() {
                var counters = table.counters,
                    rows = table.rows,
                    row = {},
                    err;

                forEach(table.uniques, function(_, key) {
                    if (isUnique(rows, key, params[key]) === false) {
                        err = new Error(
                            "MemoryAdapter save(tableName, params, callback) table " + tableName + " already has a row where " + key + " = " + params[key]
                        );
                        return false;
                    }
                    return true;
                });

                if (err) {
                    callback(err);
                    return;
                }

                forEach(counters, function(counter, key) {
                    params[key] = counters[key] ++;
                });

                forEach(table.schema._keys, function(key) {
                    var value = params[key],
                        columnType = columns[key].type;

                    if (value == null) {
                        row[key] = null;
                    } else {
                        if (columnType === "datetime") {
                            row[key] = isDate(value) ? value.toJSON() : (new Date(value).toJSON());
                        } else {
                            row[key] = value;
                        }
                    }
                });

                rows.push(row);
                callback(undefined, row);
            });
            return this;
        };

        MemoryAdapter.prototype.update = function(tableName, id, params, callback) {
            var table = this._tables[tableName],
                columns = table.schema.columns;

            process.nextTick(function() {
                var rows = table.rows,
                    row = queryOne(columns, rows, {
                        where: {
                            id: id
                        }
                    }),
                    err;

                if (!row) {
                    callback(new Error("MemoryAdapter update(tableName, id, params, callback) no row found where id=" + id));
                    return;
                }

                forEach(table.uniques, function(_, key) {
                    if (isUnique(rows, key, params[key], id) === false) {
                        err = new Error(
                            "MemoryAdapter update(tableName, id, params, callback) table " + tableName + " already has a row where " + key + " = " + params[key]
                        );
                        return false;
                    }
                    return true;
                });

                if (err) {
                    callback(err);
                    return;
                }

                forEach(table.schema._keys, function(key) {
                    var value = params[key];

                    if (value != null) {
                        if (columns[key].type === "datetime") {
                            row[key] = isDate(value) ? value.toJSON() : (new Date(value).toJSON());
                        } else {
                            row[key] = value;
                        }
                    }
                });

                callback(undefined, extend({}, row));
            });
            return this;
        };

        MemoryAdapter.prototype.find = function(tableName, query, callback) {
            var table = this._tables[tableName];

            process.nextTick(function() {
                var rows = queryAll(table.schema.columns, table.rows, query);

                callback(undefined, map(rows, function(row) {
                    return extend({}, row);
                }));
            });
            return this;
        };

        MemoryAdapter.prototype.findOne = function(tableName, query, callback) {
            var table = this._tables[tableName];

            process.nextTick(function() {
                var row = queryOne(table.schema.columns, table.rows, query);

                callback(undefined, extend({}, row));
            });
            return this;
        };

        MemoryAdapter.prototype.destroy = function(tableName, query, callback) {
            var table = this._tables[tableName];

            process.nextTick(function() {
                var rows = table.rows,
                    results = queryAll(table.schema.columns, rows, query),
                    i = results.length,
                    out, row;

                if (!i) {
                    callback(new Error("MemoryAdapter destroy(tableName, query, callback) no rows found with query " + JSON.stringify(query)));
                    return;
                }

                out = [];

                while (i--) {
                    row = results[i];
                    rows.splice(indexOf(rows, row), 1);

                    out.push(extend({}, row));
                }

                callback(undefined, out);
            });
            return this;
        };

        MemoryAdapter.prototype.createTable = function(tableName, columns, options, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.renameTable = function(tableName, newTableName, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.removeTable = function(tableName, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.addColumn = function(tableName, columnName, column, options, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.renameColumn = function(tableName, columnName, newColumnName, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.removeColumn = function(tableName, columnName, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.createIndex = function(tableName, columnName, options, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.removeIndex = function(tableName, columnName, options, callback) {

            process.nextTick(callback);
            return this;
        };

        MemoryAdapter.prototype.removeDatabase = function(callback) {

            process.nextTick(callback);
            return this;
        };


        module.exports = MemoryAdapter;


    },
    function(require, exports, module, global) {

        var keys = require(10),
            isNullOrUndefined = require(15),
            fastBindThis = require(18),
            isObjectLike = require(19),
            isLength = require(20);


        function mapArray(array, callback) {
            var length = array.length,
                i = -1,
                il = length - 1,
                result = new Array(length);

            while (i++ < il) {
                result[i] = callback(array[i], i);
            }

            return result;
        }

        function mapObject(object, callback) {
            var objectKeys = keys(object),
                i = -1,
                il = objectKeys.length - 1,
                result = {},
                key;

            while (i++ < il) {
                key = objectKeys[i];
                result[key] = callback(object[key], key);
            }

            return result;
        }

        module.exports = function map(object, callback, thisArg) {
            callback = isNullOrUndefined(thisArg) ? callback : fastBindThis(callback, thisArg, 2);
            return (isObjectLike(object) && isLength(object.length)) ? mapArray(object, callback) : mapObject(object, callback);
        };


    },
    function(require, exports, module, global) {

        var orm = require(3);


        var SPLITER = /[\s ]+/;


        var User = new orm.define({
            name: "User",

            schema: {
                firstName: "string",
                lastName: "string",
                age: "integer",
                email: {
                    type: "string",
                    unique: true
                },
                password: "string"
            }
        });

        User.accessible(
            "firstName",
            "lastName",
            "age",
            "email"
        );

        Object.defineProperty(User.prototype, "fullName", {
            get: function() {
                return this.firstName + " " + this.lastName;
            },
            set: function(value) {
                var split = (value || "").split(SPLITER);

                this.firstName = split[0] || this.firstName;
                this.lastName = split[1] || this.lastName;
            }
        });

        User.validates("email")
            .required()
            .email();

        User.validates("password")
            .required()
            .minLength(6);

        User.on("init", function(next) {
            var Cart = require(66);

            function encryptPassword(model, next) {
                model.password = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                next();
            }

            User.on("beforeCreate", encryptPassword);
            User.on("beforeSave", encryptPassword);

            User.on("destroy", function(users, next) {
                users.forEach(function(user) {
                    Cart.destroy({
                        where: {
                            userId: user.id
                        }
                    }, function(err) {
                        if (err) {
                            next(err);
                            return;
                        }
                    });
                });
            });

            next();
        });


        module.exports = User;


    },
    function(require, exports, module, global) {

        var orm = require(3);


        var Cart = new orm.define({
            name: "Cart",

            schema: {
                title: "string",
                content: "string",
                belongsTo: "user"
            }
        });

        Cart.accessible(
            "title",
            "content",
            "userId"
        );


        module.exports = Cart;


    },
    function(require, exports, module, global) {

        var orm = require(3);


        var Item = new orm.define({
            name: "Item",

            schema: {
                title: "string",
                content: "string",
                json: "json",
                belongsTo: ["user", "cart"]
            }
        });

        Item.accessible(
            "title",
            "content",
            "json"
        );


        module.exports = Item;


    },
    function(require, exports, module, global) {

        var process = require(1);
        var type = require(69),
            each = require(70),
            MongoClient = require(72).MongoClient;


        function MongoAdapter(options) {
            options || (options = {});

            this.db = null;
            this.database = options.database != null ? options.database : "test";
            this.port = type.isNumber(options.port) ? +options.port : 27017;

            this._counters = {};
        }

        MongoAdapter.prototype.init = function(callback) {
            var _this = this,
                collection = this._collection,
                schema = collection && collection._schema;

            MongoClient.connect("mongodb://127.0.0.1:" + this.port + "/" + this.database, function(err, db) {
                if (err) {
                    callback(err);
                    return;
                }
                _this.db = db;

                process.on("exit", function() {
                    db.close();
                });

                if (schema) {
                    createCallback = series(callback);

                    each(schema.tables, function(tableSchema, tableName) {
                        var counters = _this._counters[tableName] = {};

                        each(tableSchema.columns, function(column, columnName) {
                            each(column, function(value, key) {
                                if (key === "autoIncrement") {
                                    addAutoIncrement(counters, db, tableName, columnName, createCallback());
                                } else if (key === "unique") {
                                    addUnique(db, tableName, columnName, createCallback());
                                }
                            });
                        });
                    });
                    return;
                }

                callback();
            });
            return this;
        };

        function addAutoIncrement(counters, db, tableName, columnName, callback) {
            var collectionName = createCollectionName(tableName, columnName);

            hasItem(db, collectionName, {
                _id: columnName
            }, function(has) {
                var collection = db.collection(collectionName);

                counters[columnName] = function(done) {
                    collection.findAndModify({
                            _id: columnName
                        },
                        null, {
                            $inc: {
                                seq: 1
                            }
                        },
                        function(err, value) {
                            if (err || !value) {
                                done(err);
                                return;
                            }
                            done(undefined, value.seq);
                        });
                };

                if (!has) {
                    collection.insert({
                        _id: columnName,
                        seq: 1
                    }, function(err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        callback();
                    });
                } else {
                    callback();
                }
            });
        }

        function addUnique(db, tableName, columnName, callback) {
            var value = {};

            value[columnName] = 1;

            db.collection(tableName).ensureIndex(value, {
                unique: true
            }, function(err, indexName) {
                if (err) {
                    callback(err);
                    return;
                }
                callback(undefined, indexName);
            });
        }

        function hasItem(db, collectionName, query, callback) {
            var collection = db.collection(collectionName);

            collection.findOne(query, function(err, doc) {
                if (err || !doc) {
                    callback(false);
                    return;
                }
                callback(true);
            });
        }

        function createCollectionName(tableName, columnName) {

            return "__" + tableName + "_" + columnName + "__";
        }

        function series(done) {
            var length = 0,
                called = false;

            function callback(err) {
                if (called === true) {
                    return;
                }
                if (--length <= 0 || err) {
                    called = true;
                    done(err);
                }
            }

            return function createCallback() {
                length++;
                return callback;
            };
        }

        MongoAdapter.prototype.save = function(tableName, params, callback) {
            var collection = this.db.collection(tableName),
                counters = this._counters[tableName],
                createCallback;

            createCallback = series(function(err) {
                if (err) {
                    callback(err);
                    return;
                }

                collection.insert(params, function(err, row) {
                    if (err) {
                        callback(err);
                        return;
                    }

                    callback(undefined, row);
                });
            });

            each(counters, function(counter, columnName) {
                var next = createCallback();

                counter(function(err, value) {
                    if (err) {
                        next(err);
                        return;
                    }

                    params[columnName] = value;
                    next();
                });
            });

            return this;
        };

        MongoAdapter.prototype.update = function(tableName, id, params, callback) {
            var _this = this;

            this.db.collection(tableName).update({
                id: id
            }, {
                $set: params
            }, function(err) {
                if (err) {
                    callback(err);
                    return;
                }

                _this.findOne(tableName, {
                    where: {
                        id: id
                    }
                }, callback);
            });
            return this;
        };

        MongoAdapter.prototype.find = function(tableName, query, callback) {

            this.db.collection(tableName).find(query.where || {}, function(err, docs) {
                if (err) {
                    callback(err);
                    return;
                }

                docs.toArray(function(err, items) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback(undefined, items);
                });
            });
            return this;
        };

        MongoAdapter.prototype.findOne = function(tableName, query, callback) {

            this.db.collection(tableName).findOne(query.where || {}, function(err, item) {
                if (err || !item) {
                    callback(err || new Error("MongoAdapter.findOne(tableName, query, callback)"));
                    return;
                }

                callback(undefined, item);
            });
            return this;
        };

        MongoAdapter.prototype.destroy = function(tableName, query, callback) {

            this.db.collection(tableName).remove(query.where || {}, function(err, docs) {
                if (err) {
                    callback(err);
                    return;
                }

                docs.toArray(function(err, items) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback(undefined, items);
                });
            });
            return this;
        };

        MongoAdapter.prototype.createTable = function(tableName, columns, options, callback) {

            callback(new Error("createTable(tableName, columns, options, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.renameTable = function(tableName, newTableName, callback) {

            callback(new Error("renameTable(tableName, newTableName, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.removeTable = function(tableName, callback) {

            callback(new Error("removeTable(tableName, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.addColumn = function(tableName, columnName, column, options, callback) {

            callback(new Error("addColumn(tableName, columnName, column, options, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.renameColumn = function(tableName, columnName, newColumnName, callback) {

            callback(new Error("renameColumn(tableName, columnName, newColumnName, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.removeColumn = function(tableName, columnName, callback) {

            callback(new Error("removeColumn(tableName, columnName, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.addIndex = function(tableName, columnName, options, callback) {

            callback(new Error("addIndex(tableName, columnName, options, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.removeIndex = function(tableName, columnName, options, callback) {

            callback(new Error("removeIndex(tableName, columnName, options, callback) MongoAdapter not implemented"));
            return this;
        };

        MongoAdapter.prototype.removeDatabase = function(callback) {

            callback(new Error("removeDatabase(callback) MongoAdapter not implemented"));
            return this;
        };


        module.exports = MongoAdapter;


    },
    function(require, exports, module, global) {

        var type = module.exports,

            toString = Object.prototype.toString,
            fnToString = Function.prototype.toString,
            hasOwnProperty = Object.prototype.hasOwnProperty,

            HOST_CTOR = /^\[object .+?Constructor\]$/,

            IS_NATIVE = RegExp("^" +
                fnToString.call(toString)
                .replace(/[.*+?^${}()|[\]\/\\]/g, "\\$&")
                .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
            );


        type.isError = function(obj) {

            return toString.call(obj) === "[object Error]";
        };

        type.isObject = function(obj) {
            var typeStr;

            if (obj === null || obj === undefined) return false;
            typeStr = typeof(obj);

            return (typeStr === "function" || typeStr === "object");
        };

        type.isHash = function(obj) {
            var typeStr;

            if (obj === null || obj === undefined) return false;
            typeStr = typeof(obj);

            return typeStr === "object" && obj.constructor === Object;
        };

        type.isArrayLike = function(obj) {

            return obj !== null && typeof(obj) === "object" && (obj.length === +obj.length);
        };

        type.isArray = Array.isArray || function isArray(obj) {

            return toString.call(obj) === "[object Array]";
        };

        type.isArguments = function(obj) {

            return toString.call(obj) === "[object Arguments]";
        };

        if (typeof(/./) !== "function") {
            type.isFunction = function(obj) {

                return typeof(obj) === "function";
            };
        } else {
            type.isFunction = function(obj) {

                return toString.call(obj) === "[object Function]";
            };
        }

        type.isString = function(obj) {
            var type = typeof obj;

            return type === "string" || (obj && type === "object" && toString.call(obj) === "[object String]") || false;
        };

        type.isNumber = function(obj) {
            var type = typeof(obj);

            return type === "number" || (obj && type === "object" && toString.call(obj) === "[object Number]") || false;
        };

        type.isFinite = Number.isFinite || function isFinite(obj) {
            return !(
                typeof(obj) !== "number" ||
                (obj !== obj || obj === Infinity || obj === -Infinity) ||
                false
            );
        };

        type.isNaN = Number.isNaN || function(obj) {

            return type.isNumber(obj) && (obj !== +obj);
        };

        type.isDecimal = function(obj) {

            return type.isNumber(obj) && obj % 1 !== 0;
        };

        type.isFloat = type.isDecimal;

        type.isInteger = function(obj) {

            return type.isNumber(obj) && obj % 1 === 0;
        };

        type.isInt = type.isInteger;

        type.isDate = function(obj) {

            return toString.call(obj) === "[object Date]";
        };

        type.isRegExp = function(obj) {

            return toString.call(obj) === "[object RegExp]";
        };

        type.isBoolean = function(obj) {

            return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
        };

        type.isNull = function(obj) {

            return obj === null;
        };

        type.isUndefined = function(obj) {

            return obj === undefined;
        };

        type.isUndefinedOrNull = function(obj) {

            return obj !== null && obj !== undefined;
        };

        type.isPrimitive = function(obj) {
            var typeStr = typeof(obj);
            return (obj === undefined || obj === null) || (typeStr !== "object" && typeStr !== "function");
        };

        type.isNative = function(obj) {
            var typeStr = typeof(obj);

            return typeStr === "function" ?
                IS_NATIVE.test(fnToString.call(obj)) :
                (obj && typeStr === "object" && HOST_CTOR.test(toString.call(obj))) || false;
        };

        type.isWindow = function(obj) {
            var className = toString.call(obj);

            return className === "[object global]" || className === "[object Window]" || toString === "[object DOMWindow]";
        };

        type.isDocument = function(obj) {

            return obj && (obj.constructor === Document || obj.constructor === HTMLDocument);
        };

        type.isElement = function(obj) {

            return obj instanceof Element;
        };

        type.isElementOrDocument = function(obj) {

            return type.isElement(obj) || type.isDocument(obj);
        };

        type.isNodeList = function(obj) {

            return obj instanceof NodeList;
        };

        type.isHTMLElement = function(obj) {

            return obj instanceof HTMLElement;
        };


    },
    function(require, exports, module, global) {

        var type = require(69),
            utils = require(71);


        function createCallback(func, thisArg, argsCount) {
            return (
                argsCount === 3 ?
                function callback(a1, a2, a3) {
                    return func.call(thisArg, a1, a2, a3);
                } :
                function callback(a1, a2, a3, a4) {
                    return func.call(thisArg, a1, a2, a3, a4);
                }
            );
        }

        function arrayEach(array, iteratee) {
            var i = -1,
                length = array.length - 1;

            while (i++ < length) {
                if (iteratee(array[i], i, array) === false) {
                    break;
                }
            }

            return array;
        }

        function objectEach(obj, iteratee) {
            var i = -1,
                keys = utils.keys(obj),
                length = keys.length - 1,
                key;

            while (i++ < length) {
                key = keys[i];
                if (iteratee(obj[key], key, obj) === false) {
                    break;
                }
            }

            return obj;
        }

        function each(obj, iteratee, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayEach(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3))) :
                objectEach(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3)))
            );
        }

        each.forEach = each;

        function arrayIter(array, iteratee) {
            var index = 0,
                length = array.length;

            return (function next(iteratee) {
                var i = index++;

                if (iteratee(array[i], i, array) === false) {
                    return false;
                }
                if (index >= length) {
                    return array;
                }

                return next(iteratee);
            }(iteratee));
        }

        function objectIter(obj, iteratee) {
            var index = 0,
                keys = utils.keys(obj),
                length = keys.length;

            return (function next(iteratee) {
                var key = keys[index++];

                if (iteratee(obj[key], key, obj) === false) {
                    return false;
                }
                if (index >= length) {
                    return obj;
                }

                return next(iteratee);
            }(iteratee));
        }

        each.iter = function(obj, iteratee, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayIter(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3))) :
                objectIter(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3)))
            );
        };

        function arrayEachRight(array, iteratee) {
            var i = array.length;

            while (i--) {
                if (iteratee(array[i], i, array) === false) {
                    break;
                }
            }

            return array;
        }

        function objectEachRight(obj, iteratee) {
            var keys = utils.keys(obj),
                i = keys.length,
                key;

            while (i--) {
                key = keys[i];
                if (iteratee(obj[key], key, obj) === false) {
                    break;
                }
            }

            return obj;
        }

        each.right = function(obj, iteratee, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayEachRight(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3))) :
                objectEachRight(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3)))
            );
        };

        each.forEachRight = each.right;

        function arrayEvery(array, predicate) {
            var i = -1,
                length = array.length - 1;

            while (i++ < length) {
                if (!predicate(array[i], i, array)) {
                    return false;
                }
            }
            return true;
        }

        function objectEvery(obj, predicate) {
            var i = -1,
                keys = utils.keys(obj),
                length = keys.length - 1,
                key;

            while (i++ < length) {
                key = keys[i];
                if (!predicate(obj[key], key, obj)) {
                    return false;
                }
            }
            return true;
        }

        each.every = function(obj, predicate, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayEvery(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3))) :
                objectEvery(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3)))
            );
        };

        function arrayMap(array, iteratee) {
            var i = -1,
                length = array.length - 1,
                result = [];

            while (i++ < length) {
                result[i] = iteratee(array[i], i, array);
            }
            return result;
        }

        function objectMap(obj, iteratee) {
            var i = -1,
                keys = utils.keys(obj),
                length = keys.length - 1,
                result = [],
                key;

            while (i++ < length) {
                key = keys[i];
                result[i] = iteratee(obj[key], key, obj);
            }
            return result;
        }

        each.map = function(obj, iteratee, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayMap(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3))) :
                objectMap(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3)))
            );
        };

        function arrayFilter(array, predicate) {
            var i = -1,
                j = -1,
                length = array.length - 1,
                result = [],
                value;

            while (i++ < length) {
                value = array[i];
                if (predicate(value, i, array)) {
                    result[++j] = value;
                }
            }
            return result;
        }

        function objectFilter(obj, predicate) {
            var i = -1,
                j = -1,
                keys = utils.keys(obj),
                length = keys.length - 1,
                result = [],
                key, value;

            while (i++ < length) {
                key = keys[i];
                value = obj[key];
                if (predicate(value, key, array)) {
                    result[++j] = value;
                }
            }
            return result;
        }

        each.filter = function(obj, predicate, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayFilter(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3))) :
                objectFilter(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3)))
            );
        };

        function arrayOne(array, predicate) {
            var i = -1,
                length = array.length - 1,
                value;

            while (i++ < length) {
                value = array[i];
                if (predicate(value, i, array)) {
                    return value;
                }
            }
            return undefined;
        }

        function objectOne(obj, predicate) {
            var i = -1,
                keys = utils.keys(obj),
                length = keys.length - 1,
                key, value;

            while (i++ < length) {
                key = keys[i];
                value = obj[key];
                if (predicate(value, key, obj)) {
                    return value;
                }
            }
            return undefined;
        }

        each.one = function(obj, predicate, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayOne(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3))) :
                objectOne(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3)))
            );
        };

        function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var i = -1,
                length = array.length - 1;

            if (initFromArray && length) {
                accumulator = array[i++];
            }

            while (i++ < length) {
                accumulator = iteratee(accumulator, array[i], i, array);
            }
            return accumulator;
        }

        function objectReduce(obj, iteratee, accumulator, initFromArray) {
            var i = -1,
                keys = utils.keys(obj),
                length = keys.length - 1,
                key;

            if (initFromArray && length) {
                accumulator = obj[keys[i++]];
            }

            while (i++ < length) {
                key = keys[i];
                accumulator = iteratee(accumulator, obj[key], key, obj);
            }
            return accumulator;
        }

        each.reduce = function(obj, iteratee, accumulator, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayReduce(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 4)), accumulator, arguments.length < 3) :
                objectReduce(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 4)), accumulator, arguments.length < 3)
            );
        };

        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var i = array.length;

            if (initFromArray && i) {
                accumulator = array[--i];
            }

            while (i--) {
                accumulator = iteratee(accumulator, array[i], i, array);
            }

            return accumulator;
        }

        function objectReduceRight(obj, iteratee, accumulator, initFromArray) {
            var keys = utils.keys(obj),
                i = keys.length,
                key;

            if (initFromArray && i) {
                accumulator = obj[keys[--i]];
            }

            while (i--) {
                key = keys[i];
                accumulator = iteratee(accumulator, obj[key], key, obj);
            }

            return accumulator;
        }

        each.reduceRight = function(obj, iteratee, accumulator, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arrayReduceRight(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 4)), accumulator, arguments.length < 3) :
                objectReduceRight(obj, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 4)), accumulator, arguments.length < 3)
            );
        };

        function arraySome(array, predicate) {
            var i = -1,
                length = array.length - 1;

            while (i++ < length) {
                if (predicate(array[i], i, array)) {
                    return true;
                }
            }
            return false;
        }

        function objectSome(obj, predicate) {
            var i = -1,
                keys = utils.keys(obj),
                length = array.length - 1,
                key;

            while (i++ < length) {
                key = keys[i];
                if (predicate(obj[key], key, obj)) {
                    return true;
                }
            }
            return false;
        }

        each.some = function(obj, predicate, thisArg) {
            return (
                type.isArrayLike(obj) ?
                arraySome(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3))) :
                objectSome(obj, ((thisArg === undefined || thisArg === null) ? predicate : createCallback(predicate, thisArg, 3)))
            );
        };

        function forUp(start, end, increment, iteratee) {
            var i = start,
                length = end;

            while (i < length) {
                if (iteratee(i, length, increment) === false) {
                    break;
                }

                i += increment;
            }
        }

        function forDown(start, end, increment, iteratee) {
            var i = start - 1,
                length = end - 1;

            if (increment >= 0) increment *= -1;

            while (i > length) {
                if (iteratee(i, length, increment) === false) {
                    break;
                }

                i += increment;
            }
        }

        each["for"] = function(start, end, increment, iteratee, thisArg) {
            if (type.isFunction(increment)) {
                thisArg = iteratee;
                iteratee = increment;
                increment = 1;
            }
            if (thisArg !== undefined && thisArg !== null) {
                iteratee = createCallback(iteratee, thisArg, 3);
            }

            return (
                start < end ?
                forUp(start, end, increment, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3))) :
                forDown(start, end, increment, ((thisArg === undefined || thisArg === null) ? iteratee : createCallback(iteratee, thisArg, 3)))
            );
        };

        function loop(iteratee) {
            if (iteratee() === false) {
                return undefined;
            } else {
                return loop(iteratee);
            }
        }

        each["while"] = function(iteratee, thisArg) {

            return loop((thisArg === undefined || thisArg === null) ? iteratee : function callback() {
                return iteratee.call(thisArg);
            });
        };

        each.loop = each["while"];


        module.exports = each;


    },
    function(require, exports, module, global) {

        var type = require(69);


        var utils = module.exports,

            nativeKeys = Object.keys,

            toString = Object.prototype.toString,
            hasOwnProp = Object.prototype.hasOwnProperty,

            wrapperDescriptor = {
                configurable: false,
                enumerable: false,
                writable: false,
                value: null
            },

            FORMAT_REPLACER = /%[sdj%]/g;


        utils.noop = function noop() {};

        utils.isEmpty = function(obj) {
            var has = hasOwnProp,
                key;

            if (obj === null || obj === undefined) return true;
            if (type.isString(obj) || type.isArray(obj)) return obj.length === 0;

            for (key in obj) {
                if (has.call(obj, key)) return false;
            }

            return true;
        };

        function isEqual(a, b, stackA, stackB) {
            var has, className, length, aCtor, bCtor, size, key, keys, result;

            if (a === b) return a !== 0 || 1 / a === 1 / b;

            if (a == null || b == null) return a === b;

            className = toString.call(a);
            if (className !== toString.call(b)) return false;

            if (className === "[object String]" || className === "[object RegExp]") {
                return "" + a === "" + b;
            } else if (className === "[object Number]") {
                if (+a !== +a) return +b !== +b;
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            } else if (className === "[object Date]" || className === "[object Boolean]") {
                return +a === +b;
            }

            if (typeof(a) !== "object" || typeof(b) !== "object") return false;

            length = stackA.length;
            while (length--) {
                if (stackA[length] === a) return stackB[length] === b;
            }

            aCtor = a.constructor;
            bCtor = b.constructor;

            if (
                aCtor !== bCtor && "constructor" in a && "constructor" in b &&
                !(
                    type.isFunction(aCtor) && aCtor instanceof aCtor &&
                    type.isFunction(bCtor) && bCtor instanceof bCtor
                )
            ) {
                return false;
            }

            stackA.push(a);
            stackB.push(b);

            if (className === "[object Array]") {
                size = a.length;
                result = size === b.length;

                if (result) {
                    while (size--) {
                        if (!(result = isEqual(a[size], b[size], stackA, stackB))) break;
                    }
                }
            } else {
                has = hasOwnProp;
                keys = utils.keys(a);

                size = keys.length;
                result = utils.keys(b).length === size;

                if (result) {
                    while (size--) {
                        key = keys[size];
                        if (!(result = has.call(b, key) && isEqual(a[key], b[key], stackA, stackB))) break;
                    }
                }
            }

            stackA.pop();
            stackB.pop();

            return !!result;
        }

        utils.isEqual = function(a, b) {

            return isEqual(a, b, [], []);
        };

        if (type.isNative(nativeKeys)) {
            utils.keys = function(obj) {
                if (!type.isObject(obj)) return [];
                return nativeKeys(obj);
            };
        } else {
            utils.keys = function(obj) {
                var has = hasOwnProp,
                    keys = [],
                    i = 0,
                    key;

                if (!type.isObject(obj)) return keys;

                for (key in obj) {
                    if (has.call(obj, key)) {
                        keys[i++] = key;
                    }
                }
                return keys;
            };
        }

        utils.values = function(obj) {
            var props = utils.keys(obj),
                i = props.length,
                result = [];

            while (i--) {
                result[i] = obj[props[i]];
            }

            return result;
        };

        utils.reverse = function(obj) {
            var out;

            if (!type.isObject(obj)) throw new TypeError("reverse(obj) argument must be an Object");

            out = {};
            for (var key in obj) out[obj[key]] = key;
            return out;
        };

        utils.has = function(obj, key) {

            return hasOwnProp.call(obj, key);
        };

        function extend(a, b) {
            var props = utils.keys(b),
                i = props.length,
                key;

            while (i--) {
                key = props[i];
                a[key] = b[key];
            }

            return a;
        }

        utils.extend = function(out) {
            var i = 0,
                length = arguments.length;

            while (++i < length) {
                extend(out, arguments[i]);
            }
            return out;
        };

        utils.deepExtend = function(out) {
            var i = 0,
                length = arguments.length,
                seen = [],
                copied = [];

            while (++i < length) {
                extend(out, deepCopy(arguments[i], seen, copied));
                seen.length = 0;
                copied.length = 0;
            }
            return out;
        };

        function merge(a, b) {
            var props = utils.keys(b),
                i = props.length,
                key, value;

            while (i--) {
                key = props[i];
                if ((value = b[key])) a[key] = value;
            }

            return a;
        }

        utils.merge = function(out) {
            var i = 0,
                length = arguments.length;

            while (++i < length) {
                merge(out, arguments[i]);
            }
            return out;
        };

        utils.deepMerge = function(out) {
            var i = 0,
                length = arguments.length,
                seen = [],
                copied = [];

            while (++i < length) {
                merge(out, deepCopy(arguments[i], seen, copied));
                seen.length = 0;
                copied.length = 0;
            }
            return out;
        };

        function mixin(a, b) {
            var props = utils.keys(b),
                i = props.length,
                key, value;

            while (i--) {
                key = props[i];
                if (!a[key] && (value = b[key])) a[key] = value;
            }

            return a;
        }

        utils.mixin = function(out) {
            var i = 0,
                length = arguments.length;

            while (++i < length) {
                mixin(out, arguments[i]);
            }
            return out;
        };

        utils.deepMixin = function(out) {
            var i = 0,
                length = arguments.length,
                seen = [],
                copied = [];

            while (++i < length) {
                mixin(out, deepCopy(arguments[i], seen, copied));
                seen.length = 0;
                copied.length = 0;
            }
            return out;
        };

        utils.copy = function(obj) {
            if (!type.isObject(obj)) return obj;
            return type.isArray(obj) ? slice(obj) : extend({}, obj);
        };

        function deepCopy(obj, seen, copied) {
            var index = utils.indexOf(seen, obj),
                out, i, il, key, has;

            if (!type.isObject(obj) || type.isFunction(obj)) return obj;
            if (index !== -1) return copied[index];

            seen.push(obj);

            if (type.isArray(obj)) {
                out = [];
                copied.push(out);
                i = 0;
                il = obj.length;
                for (; i < il; i++) out[i] = deepCopy(obj[i], seen, copied);
            } else if (type.isDate(obj)) {
                out = new Date(obj);
                copied.push(out);
            } else {
                has = hasOwnProp;
                out = {};
                copied.push(out);
                for (key in obj) {
                    if (!has.call(obj, key)) continue;
                    out[key] = deepCopy(obj[key], seen, copied);
                }
            }

            return out;
        }

        utils.deepCopy = function(obj) {

            return deepCopy(obj, [], []);
        };

        utils.defaults = function(obj) {
            var utilsKeys = utils.keys,

                args = slice(arguments, 1),
                i = -1,
                il = args.length,
                src, keys, j, key;

            while (++i < il) {
                src = args[i];

                if (src) {
                    keys = utilsKeys(src);
                    j = keys.length;
                    while (j--) {
                        key = keys[j];
                        if (obj[key] === undefined) obj[key] = src[key];
                    }
                }
            }

            return obj;
        };

        utils.indexOf = function(array, value, fromIndex) {
            var i = (fromIndex || 0) - 1,
                il = array.length;

            while (++i < il) {
                if (value === array[i]) return i;
            }

            return -1;
        };

        utils.remove = function(array, value) {
            var index = utils.indexOf(array, value);

            if (index !== -1) {
                array.splice(value);
                return index;
            }

            return -1;
        };

        utils.unique = function() {
            var indexOf = utils.indexOf,
                isArrayLike = type.isArrayLike,
                i = 0,
                il = arguments.length,
                out = [],
                seen = [],
                array, item, j, jl;

            for (; i < il; i++) {
                array = arguments[i];
                if (!isArrayLike(array)) continue;

                for (j = 0, jl = array.length; j < jl; j++) {
                    item = array[j];
                    if (indexOf(seen, item) !== -1) continue;

                    seen.push(item);
                    out.push(item);
                }
            }

            return out;
        };

        function flattenArray(array, out) {
            var isArray = type.isArray,
                i = array.length,
                item;

            out || (out = []);

            while (i--) {
                item = array[i];

                if (isArray(item)) {
                    flattenArray(item, out);
                } else {
                    out.push(item);
                }
            }

            return out;
        }

        utils.difference = function(obj) {
            var rest = flattenArray(slice(arguments, 1)),
                i = 0,
                il = obj.length,
                out = [],
                jl = rest.length,
                a, b, j, pass;

            for (; i < il; i++) {
                a = obj[i];
                pass = true;

                j = jl;
                while (j--) {
                    b = rest[j];
                    if (a === b) {
                        pass = false;
                        break;
                    }
                }

                if (pass) out.push(a);
            }

            return out;
        };

        utils.create = Object.create || (function() {
            function F() {}
            return function create(obj) {
                F.prototype = obj;
                return new F();
            };
        }());

        function Wrapper() {
            this.thisArg = null;
            this.args = null;
            this.argsRight = null;
        }

        function slice(array, offset) {
            var results = [],
                i = array.length - (offset || (offset = 0));

            while (i--) {
                results[i] = array[offset + i];
            }

            return results;
        }

        function concat(a, b) {
            var results = [],
                aLength = a.length,
                bLength = b.length,
                i = aLength;

            while (i--) {
                results[i] = a[i];
            }
            i = bLength;
            while (i--) {
                results[aLength + i] = b[i];
            }

            return results;
        }

        function createWrapper(func) {
            var wrapper;

            if (hasOwnProp.call(func, "__wrapper__")) {
                wrapper = func;
            } else {
                wrapper = function wrapper() {
                    var __wrapper__ = wrapper.__wrapper__,
                        wrapperArgs = __wrapper__.args,
                        wrapperArgsRight = __wrapper__.argsRight,
                        args = slice(arguments),
                        length;

                    if (wrapperArgs) args = concat(wrapperArgs, args);
                    if (wrapperArgsRight) args = concat(args, wrapperArgsRight);

                    length = args.length;

                    if (length === 0) {
                        return func.call(__wrapper__.thisArg);
                    } else if (length === 1) {
                        return func.call(__wrapper__.thisArg, args[0]);
                    } else if (length === 2) {
                        return func.call(__wrapper__.thisArg, args[0], args[1]);
                    } else if (length === 3) {
                        return func.call(__wrapper__.thisArg, args[0], args[1], args[2]);
                    } else if (length === 4) {
                        return func.call(__wrapper__.thisArg, args[0], args[1], args[2], args[3]);
                    } else if (length === 5) {
                        return func.call(__wrapper__.thisArg, args[0], args[1], args[2], args[3], args[4]);
                    }

                    return func.apply(__wrapper__.thisArg, args);
                };

                wrapperDescriptor.value = new Wrapper();
                Object.defineProperty(wrapper, "__wrapper__", wrapperDescriptor);
                wrapperDescriptor.value = null;
            }

            return wrapper;
        }

        utils.bind = function(func, thisArg) {
            var wrapper = createWrapper(func),
                __wrapper__ = wrapper.__wrapper__,
                args = slice(arguments, 2);

            __wrapper__.thisArg = thisArg;

            if (args.length) {
                if (!__wrapper__.args) {
                    __wrapper__.args = args;
                } else {
                    __wrapper__.args = concat(__wrapper__.args, args);
                }
            }

            return wrapper;
        };

        utils.bindThis = function(func, thisArg) {
            var wrapper = createWrapper(func);

            wrapper.__wrapper__.thisArg = thisArg;

            return wrapper;
        };

        utils.curry = function(func) {
            var wrapper = createWrapper(func),
                __wrapper__ = wrapper.__wrapper__,
                args = slice(arguments, 1);

            if (args.length) {
                if (!__wrapper__.args) {
                    __wrapper__.args = args;
                } else {
                    __wrapper__.args = concat(__wrapper__.args, args);
                }
            }

            return wrapper;
        };

        utils.curryRight = function(func) {
            var wrapper = createWrapper(func),
                __wrapper__ = wrapper.__wrapper__,
                argsRight = slice(arguments, 1);

            if (argsRight.length) {
                if (!__wrapper__.argsRight) {
                    __wrapper__.argsRight = argsRight;
                } else {
                    __wrapper__.argsRight = concat(__wrapper__.argsRight, argsRight);
                }
            }

            return wrapper;
        };

        utils.tryParseJSON = function(obj) {
            var parsed;

            try {
                parsed = JSON.parse(obj);
                if (parsed && parsed !== null && type.isObject(parsed)) return parsed;
            } catch (e) {}

            return false;
        };

        utils.inherits = function(child, parent) {
            if (!parent) {
                parent = this;
            } else {
                parent.extend = utils.inherits;
            }

            child.prototype = utils.create(parent.prototype);
            child.prototype.constructor = child;
            child._super = parent.prototype;
            child.extend = parent.extend;

            return child;
        };

        utils.format = function(str) {
            var i = 1,
                length = arguments.length,
                args = arguments,
                arg;

            return str.replace(FORMAT_REPLACER, function(x) {
                if (x === "%%") return "%";
                if (i >= length) return "";
                arg = args[i++];

                if (x === "%s") {
                    return arg ? String(arg) : "";
                } else if (x === "%d") {
                    return arg ? Number(arg) : "";
                } else if (x === "%j") {
                    if (!arg) return "";

                    try {
                        return JSON.stringify(arg);
                    } catch (e) {
                        return "[Circular]";
                    }
                }

                return "";
            });
        };


    },
    function(require, exports, module, global) {

        try {
            exports.BSONPure = require(73).BSONPure;
            exports.BSONNative = require(73).BSONNative;
        } catch (err) {
            // do nothing
        }

        // export the driver version
        exports.version = require(88).version;

        ['commands/base_command', 'admin', 'collection', 'connection/read_preference', 'connection/connection', 'connection/server', 'connection/mongos', 'connection/repl_set/repl_set', 'mongo_client', 'cursor', 'db', 'mongo_client', 'gridfs/grid', 'gridfs/chunk', 'gridfs/gridstore'].forEach(function(path) {
            var module = require('./' + path);
            for (var i in module) {
                exports[i] = module[i];
            }
        });

        // backwards compat
        exports.ReplSetServers = exports.ReplSet;
        // Add BSON Classes
        exports.Binary = require(73).Binary;
        exports.Code = require(73).Code;
        exports.DBRef = require(73).DBRef;
        exports.Double = require(73).Double;
        exports.Long = require(73).Long;
        exports.MinKey = require(73).MinKey;
        exports.MaxKey = require(73).MaxKey;
        exports.ObjectID = require(73).ObjectID;
        exports.Symbol = require(73).Symbol;
        exports.Timestamp = require(73).Timestamp;
        // Add BSON Parser
        exports.BSON = require(73).BSONPure.BSON;

        // Set up the connect function
        var connect = exports.Db.connect;

        // Add the pure and native backward compatible functions
        exports.pure = exports.native = function() {
            return connect;
        }

        // Map all values to the exports value
        for (var name in exports) {
            connect[name] = exports[name];
        }

        // Set our exports to be the connect function
        module.exports = connect;


    },
    function(require, exports, module, global) {

        var Buffer = require(45).Buffer;
        var Long = require(74).Long,
            Double = require(75).Double,
            Timestamp = require(76).Timestamp,
            ObjectID = require(77).ObjectID,
            Symbol = require(81).Symbol,
            Code = require(82).Code,
            MinKey = require(83).MinKey,
            MaxKey = require(84).MaxKey,
            DBRef = require(85).DBRef,
            Binary = require(86).Binary,
            BinaryParser = require(78).BinaryParser,
            writeIEEE754 = require(87).writeIEEE754,
            readIEEE754 = require(87).readIEEE754

        // To ensure that 0.4 of node works correctly
        var isDate = function isDate(d) {
            return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
        }

        /**
         * Create a new BSON instance
         *
         * @class Represents the BSON Parser
         * @return {BSON} instance of BSON Parser.
         */
        function BSON() {};

        /**
         * @ignore
         * @api private
         */
        // BSON MAX VALUES
        BSON.BSON_INT32_MAX = 0x7FFFFFFF;
        BSON.BSON_INT32_MIN = -0x80000000;

        BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
        BSON.BSON_INT64_MIN = -Math.pow(2, 63);

        // JS MAX PRECISE VALUES
        BSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.
        BSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.

        // Internal long versions
        var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.
        var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.

        /**
         * Number BSON Type
         *
         * @classconstant BSON_DATA_NUMBER
         **/
        BSON.BSON_DATA_NUMBER = 1;
        /**
         * String BSON Type
         *
         * @classconstant BSON_DATA_STRING
         **/
        BSON.BSON_DATA_STRING = 2;
        /**
         * Object BSON Type
         *
         * @classconstant BSON_DATA_OBJECT
         **/
        BSON.BSON_DATA_OBJECT = 3;
        /**
         * Array BSON Type
         *
         * @classconstant BSON_DATA_ARRAY
         **/
        BSON.BSON_DATA_ARRAY = 4;
        /**
         * Binary BSON Type
         *
         * @classconstant BSON_DATA_BINARY
         **/
        BSON.BSON_DATA_BINARY = 5;
        /**
         * Binary BSON Type
         *
         * @classconstant BSON_DATA_UNDEFINED
         **/
        BSON.BSON_DATA_UNDEFINED = 6;
        /**
         * ObjectID BSON Type
         *
         * @classconstant BSON_DATA_OID
         **/
        BSON.BSON_DATA_OID = 7;
        /**
         * Boolean BSON Type
         *
         * @classconstant BSON_DATA_BOOLEAN
         **/
        BSON.BSON_DATA_BOOLEAN = 8;
        /**
         * Date BSON Type
         *
         * @classconstant BSON_DATA_DATE
         **/
        BSON.BSON_DATA_DATE = 9;
        /**
         * null BSON Type
         *
         * @classconstant BSON_DATA_NULL
         **/
        BSON.BSON_DATA_NULL = 10;
        /**
         * RegExp BSON Type
         *
         * @classconstant BSON_DATA_REGEXP
         **/
        BSON.BSON_DATA_REGEXP = 11;
        /**
         * Code BSON Type
         *
         * @classconstant BSON_DATA_CODE
         **/
        BSON.BSON_DATA_CODE = 13;
        /**
         * Symbol BSON Type
         *
         * @classconstant BSON_DATA_SYMBOL
         **/
        BSON.BSON_DATA_SYMBOL = 14;
        /**
         * Code with Scope BSON Type
         *
         * @classconstant BSON_DATA_CODE_W_SCOPE
         **/
        BSON.BSON_DATA_CODE_W_SCOPE = 15;
        /**
         * 32 bit Integer BSON Type
         *
         * @classconstant BSON_DATA_INT
         **/
        BSON.BSON_DATA_INT = 16;
        /**
         * Timestamp BSON Type
         *
         * @classconstant BSON_DATA_TIMESTAMP
         **/
        BSON.BSON_DATA_TIMESTAMP = 17;
        /**
         * Long BSON Type
         *
         * @classconstant BSON_DATA_LONG
         **/
        BSON.BSON_DATA_LONG = 18;
        /**
         * MinKey BSON Type
         *
         * @classconstant BSON_DATA_MIN_KEY
         **/
        BSON.BSON_DATA_MIN_KEY = 0xff;
        /**
         * MaxKey BSON Type
         *
         * @classconstant BSON_DATA_MAX_KEY
         **/
        BSON.BSON_DATA_MAX_KEY = 0x7f;

        /**
         * Binary Default Type
         *
         * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
         **/
        BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
        /**
         * Binary Function Type
         *
         * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
         **/
        BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
        /**
         * Binary Byte Array Type
         *
         * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
         **/
        BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
        /**
         * Binary UUID Type
         *
         * @classconstant BSON_BINARY_SUBTYPE_UUID
         **/
        BSON.BSON_BINARY_SUBTYPE_UUID = 3;
        /**
         * Binary MD5 Type
         *
         * @classconstant BSON_BINARY_SUBTYPE_MD5
         **/
        BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
        /**
         * Binary User Defined Type
         *
         * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
         **/
        BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

        /**
         * Calculate the bson size for a passed in Javascript object.
         *
         * @param {Object} object the Javascript object to calculate the BSON byte size for.
         * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
         * @return {Number} returns the number of bytes the BSON object will take up.
         * @api public
         */
        BSON.calculateObjectSize = function calculateObjectSize(object, serializeFunctions) {
            var totalLength = (4 + 1);

            if (Array.isArray(object)) {
                for (var i = 0; i < object.length; i++) {
                    totalLength += calculateElement(i.toString(), object[i], serializeFunctions)
                }
            } else {
                // If we have toBSON defined, override the current object
                if (object.toBSON) {
                    object = object.toBSON();
                }

                // Calculate size
                for (var key in object) {
                    totalLength += calculateElement(key, object[key], serializeFunctions)
                }
            }

            return totalLength;
        }

        /**
         * @ignore
         * @api private
         */
        function calculateElement(name, value, serializeFunctions) {
            var isBuffer = typeof Buffer !== 'undefined';

            // If we have toBSON defined, override the current object
            if (value && value.toBSON) {
                value = value.toBSON();
            }

            switch (typeof value) {
                case 'string':
                    return 1 + (!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1 + 4 + (!isBuffer ? numberOfBytes(value) : Buffer.byteLength(value, 'utf8')) + 1;
                case 'number':
                    if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
                        if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) { // 32 bit
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (4 + 1);
                        } else {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
                        }
                    } else { // 64 bit
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
                    }
                case 'undefined':
                    return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1);
                case 'boolean':
                    return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1 + 1);
                case 'object':
                    if (value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1);
                    } else if (value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (12 + 1);
                    } else if (value instanceof Date || isDate(value)) {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
                    } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1 + 4 + 1) + value.length;
                    } else if (value instanceof Long || value instanceof Double || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp') {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
                    } else if (value instanceof Code || value['_bsontype'] == 'Code') {
                        // Calculate size depending on the availability of a scope
                        if (value.scope != null && Object.keys(value.scope).length > 0) {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.code.toString()) : Buffer.byteLength(value.code.toString(), 'utf8')) + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions);
                        } else {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + (!isBuffer ? numberOfBytes(value.code.toString()) : Buffer.byteLength(value.code.toString(), 'utf8')) + 1;
                        }
                    } else if (value instanceof Binary || value['_bsontype'] == 'Binary') {
                        // Check what kind of subtype we have
                        if (value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (value.position + 1 + 4 + 1 + 4);
                        } else {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (value.position + 1 + 4 + 1);
                        }
                    } else if (value instanceof Symbol || value['_bsontype'] == 'Symbol') {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + ((!isBuffer ? numberOfBytes(value.value) : Buffer.byteLength(value.value, 'utf8')) + 4 + 1 + 1);
                    } else if (value instanceof DBRef || value['_bsontype'] == 'DBRef') {
                        // Set up correct object for serialization
                        var ordered_values = {
                            '$ref': value.namespace,
                            '$id': value.oid
                        };

                        // Add db reference if it exists
                        if (null != value.db) {
                            ordered_values['$db'] = value.db;
                        }

                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + BSON.calculateObjectSize(ordered_values, serializeFunctions);
                    } else if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + (!isBuffer ? numberOfBytes(value.source) : Buffer.byteLength(value.source, 'utf8')) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
                    } else {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + BSON.calculateObjectSize(value, serializeFunctions) + 1;
                    }
                case 'function':
                    // WTF for 0.4.X where typeof /someregexp/ === 'function'
                    if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
                        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + (!isBuffer ? numberOfBytes(value.source) : Buffer.byteLength(value.source, 'utf8')) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
                    } else {
                        if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.toString()) : Buffer.byteLength(value.toString(), 'utf8')) + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions);
                        } else if (serializeFunctions) {
                            return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + (!isBuffer ? numberOfBytes(value.toString()) : Buffer.byteLength(value.toString(), 'utf8')) + 1;
                        }
                    }
            }

            return 0;
        }

        /**
         * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
         *
         * @param {Object} object the Javascript object to serialize.
         * @param {Boolean} checkKeys the serializer will check if keys are valid.
         * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
         * @param {Number} index the index in the buffer where we wish to start serializing into.
         * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
         * @return {Number} returns the new write index in the Buffer.
         * @api public
         */
        BSON.serializeWithBufferAndIndex = function serializeWithBufferAndIndex(object, checkKeys, buffer, index, serializeFunctions) {
            // Default setting false
            serializeFunctions = serializeFunctions == null ? false : serializeFunctions;
            // Write end information (length of the object)
            var size = buffer.length;
            // Write the size of the object
            buffer[index++] = size & 0xff;
            buffer[index++] = (size >> 8) & 0xff;
            buffer[index++] = (size >> 16) & 0xff;
            buffer[index++] = (size >> 24) & 0xff;
            return serializeObject(object, checkKeys, buffer, index, serializeFunctions) - 1;
        }

        /**
         * @ignore
         * @api private
         */
        var serializeObject = function(object, checkKeys, buffer, index, serializeFunctions) {
            if (object.toBSON) {
                if (typeof object.toBSON != 'function') throw new Error("toBSON is not a function");
                object = object.toBSON();
                if (object != null && typeof object != 'object') throw new Error("toBSON function did not return an object");
            }

            // Process the object
            if (Array.isArray(object)) {
                for (var i = 0; i < object.length; i++) {
                    index = packElement(i.toString(), object[i], checkKeys, buffer, index, serializeFunctions);
                }
            } else {
                // If we have toBSON defined, override the current object
                if (object.toBSON) {
                    object = object.toBSON();
                }

                // Serialize the object
                for (var key in object) {
                    // Check the key and throw error if it's illegal
                    if (key != '$db' && key != '$ref' && key != '$id') {
                        // dollars and dots ok
                        BSON.checkKey(key, !checkKeys);
                    }

                    // Pack the element
                    index = packElement(key, object[key], checkKeys, buffer, index, serializeFunctions);
                }
            }

            // Write zero
            buffer[index++] = 0;
            return index;
        }

        var stringToBytes = function(str) {
            var ch, st, re = [];
            for (var i = 0; i < str.length; i++) {
                ch = str.charCodeAt(i); // get char
                st = []; // set up "stack"
                do {
                    st.push(ch & 0xFF); // push byte to stack
                    ch = ch >> 8; // shift value down by 1 byte
                }
                while (ch);
                // add stack contents to result
                // done because chars have "wrong" endianness
                re = re.concat(st.reverse());
            }
            // return an array of bytes
            return re;
        }

        var numberOfBytes = function(str) {
            var ch, st, re = 0;
            for (var i = 0; i < str.length; i++) {
                ch = str.charCodeAt(i); // get char
                st = []; // set up "stack"
                do {
                    st.push(ch & 0xFF); // push byte to stack
                    ch = ch >> 8; // shift value down by 1 byte
                }
                while (ch);
                // add stack contents to result
                // done because chars have "wrong" endianness
                re = re + st.length;
            }
            // return an array of bytes
            return re;
        }

        /**
         * @ignore
         * @api private
         */
        var writeToTypedArray = function(buffer, string, index) {
            var bytes = stringToBytes(string);
            for (var i = 0; i < bytes.length; i++) {
                buffer[index + i] = bytes[i];
            }
            return bytes.length;
        }

        /**
         * @ignore
         * @api private
         */
        var supportsBuffer = typeof Buffer != 'undefined';

        /**
         * @ignore
         * @api private
         */
        var packElement = function(name, value, checkKeys, buffer, index, serializeFunctions) {

            // If we have toBSON defined, override the current object
            if (value && value.toBSON) {
                value = value.toBSON();
            }

            var startIndex = index;

            switch (typeof value) {
                case 'string':
                    // console.log("+++++++++++ index string:: " + index)
                    // Encode String type
                    buffer[index++] = BSON.BSON_DATA_STRING;
                    // Number of written bytes
                    var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                    // Encode the name
                    index = index + numberOfWrittenBytes + 1;
                    buffer[index - 1] = 0;

                    // Calculate size
                    var size = supportsBuffer ? Buffer.byteLength(value) + 1 : numberOfBytes(value) + 1;
                    // console.log("====== key :: " + name + " size ::" + size)
                    // Write the size of the string to buffer
                    buffer[index + 3] = (size >> 24) & 0xff;
                    buffer[index + 2] = (size >> 16) & 0xff;
                    buffer[index + 1] = (size >> 8) & 0xff;
                    buffer[index] = size & 0xff;
                    // Ajust the index
                    index = index + 4;
                    // Write the string
                    supportsBuffer ? buffer.write(value, index, 'utf8') : writeToTypedArray(buffer, value, index);
                    // Update index
                    index = index + size - 1;
                    // Write zero
                    buffer[index++] = 0;
                    // Return index
                    return index;
                case 'number':
                    // We have an integer value
                    if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
                        // If the value fits in 32 bits encode as int, if it fits in a double
                        // encode it as a double, otherwise long
                        if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
                            // Set int type 32 bits or less
                            buffer[index++] = BSON.BSON_DATA_INT;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            // Write the int value
                            buffer[index++] = value & 0xff;
                            buffer[index++] = (value >> 8) & 0xff;
                            buffer[index++] = (value >> 16) & 0xff;
                            buffer[index++] = (value >> 24) & 0xff;
                        } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
                            // Encode as double
                            buffer[index++] = BSON.BSON_DATA_NUMBER;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            // Write float
                            writeIEEE754(buffer, value, index, 'little', 52, 8);
                            // Ajust index
                            index = index + 8;
                        } else {
                            // Set long type
                            buffer[index++] = BSON.BSON_DATA_LONG;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            var longVal = Long.fromNumber(value);
                            var lowBits = longVal.getLowBits();
                            var highBits = longVal.getHighBits();
                            // Encode low bits
                            buffer[index++] = lowBits & 0xff;
                            buffer[index++] = (lowBits >> 8) & 0xff;
                            buffer[index++] = (lowBits >> 16) & 0xff;
                            buffer[index++] = (lowBits >> 24) & 0xff;
                            // Encode high bits
                            buffer[index++] = highBits & 0xff;
                            buffer[index++] = (highBits >> 8) & 0xff;
                            buffer[index++] = (highBits >> 16) & 0xff;
                            buffer[index++] = (highBits >> 24) & 0xff;
                        }
                    } else {
                        // Encode as double
                        buffer[index++] = BSON.BSON_DATA_NUMBER;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Write float
                        writeIEEE754(buffer, value, index, 'little', 52, 8);
                        // Ajust index
                        index = index + 8;
                    }

                    return index;
                case 'undefined':
                    // Set long type
                    buffer[index++] = BSON.BSON_DATA_NULL;
                    // Number of written bytes
                    var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                    // Encode the name
                    index = index + numberOfWrittenBytes + 1;
                    buffer[index - 1] = 0;
                    return index;
                case 'boolean':
                    // Write the type
                    buffer[index++] = BSON.BSON_DATA_BOOLEAN;
                    // Number of written bytes
                    var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                    // Encode the name
                    index = index + numberOfWrittenBytes + 1;
                    buffer[index - 1] = 0;
                    // Encode the boolean value
                    buffer[index++] = value ? 1 : 0;
                    return index;
                case 'object':
                    if (value === null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
                        // Write the type of either min or max key
                        if (value === null) {
                            buffer[index++] = BSON.BSON_DATA_NULL;
                        } else if (value instanceof MinKey) {
                            buffer[index++] = BSON.BSON_DATA_MIN_KEY;
                        } else {
                            buffer[index++] = BSON.BSON_DATA_MAX_KEY;
                        }

                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        return index;
                    } else if (value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
                        // console.log("+++++++++++ index OBJECTID:: " + index)
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_OID;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;

                        // Write objectid
                        supportsBuffer ? buffer.write(value.id, index, 'binary') : writeToTypedArray(buffer, value.id, index);
                        // Ajust index
                        index = index + 12;
                        return index;
                    } else if (value instanceof Date || isDate(value)) {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_DATE;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;

                        // Write the date
                        var dateInMilis = Long.fromNumber(value.getTime());
                        var lowBits = dateInMilis.getLowBits();
                        var highBits = dateInMilis.getHighBits();
                        // Encode low bits
                        buffer[index++] = lowBits & 0xff;
                        buffer[index++] = (lowBits >> 8) & 0xff;
                        buffer[index++] = (lowBits >> 16) & 0xff;
                        buffer[index++] = (lowBits >> 24) & 0xff;
                        // Encode high bits
                        buffer[index++] = highBits & 0xff;
                        buffer[index++] = (highBits >> 8) & 0xff;
                        buffer[index++] = (highBits >> 16) & 0xff;
                        buffer[index++] = (highBits >> 24) & 0xff;
                        return index;
                    } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_BINARY;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Get size of the buffer (current write point)
                        var size = value.length;
                        // Write the size of the string to buffer
                        buffer[index++] = size & 0xff;
                        buffer[index++] = (size >> 8) & 0xff;
                        buffer[index++] = (size >> 16) & 0xff;
                        buffer[index++] = (size >> 24) & 0xff;
                        // Write the default subtype
                        buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
                        // Copy the content form the binary field to the buffer
                        value.copy(buffer, index, 0, size);
                        // Adjust the index
                        index = index + size;
                        return index;
                    } else if (value instanceof Long || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
                        // Write the type
                        buffer[index++] = value instanceof Long || value['_bsontype'] == 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Write the date
                        var lowBits = value.getLowBits();
                        var highBits = value.getHighBits();
                        // Encode low bits
                        buffer[index++] = lowBits & 0xff;
                        buffer[index++] = (lowBits >> 8) & 0xff;
                        buffer[index++] = (lowBits >> 16) & 0xff;
                        buffer[index++] = (lowBits >> 24) & 0xff;
                        // Encode high bits
                        buffer[index++] = highBits & 0xff;
                        buffer[index++] = (highBits >> 8) & 0xff;
                        buffer[index++] = (highBits >> 16) & 0xff;
                        buffer[index++] = (highBits >> 24) & 0xff;
                        return index;
                    } else if (value instanceof Double || value['_bsontype'] == 'Double') {
                        // Encode as double
                        buffer[index++] = BSON.BSON_DATA_NUMBER;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Write float
                        writeIEEE754(buffer, value, index, 'little', 52, 8);
                        // Ajust index
                        index = index + 8;
                        return index;
                    } else if (value instanceof Code || value['_bsontype'] == 'Code') {
                        if (value.scope != null && Object.keys(value.scope).length > 0) {
                            // Write the type
                            buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            // Calculate the scope size
                            var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions);
                            // Function string
                            var functionString = value.code.toString();
                            // Function Size
                            var codeSize = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;

                            // Calculate full size of the object
                            var totalSize = 4 + codeSize + scopeSize + 4;

                            // Write the total size of the object
                            buffer[index++] = totalSize & 0xff;
                            buffer[index++] = (totalSize >> 8) & 0xff;
                            buffer[index++] = (totalSize >> 16) & 0xff;
                            buffer[index++] = (totalSize >> 24) & 0xff;

                            // Write the size of the string to buffer
                            buffer[index++] = codeSize & 0xff;
                            buffer[index++] = (codeSize >> 8) & 0xff;
                            buffer[index++] = (codeSize >> 16) & 0xff;
                            buffer[index++] = (codeSize >> 24) & 0xff;

                            // Write the string
                            supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
                            // Update index
                            index = index + codeSize - 1;
                            // Write zero
                            buffer[index++] = 0;
                            // Serialize the scope object
                            var scopeObjectBuffer = supportsBuffer ? new Buffer(scopeSize) : new Uint8Array(new ArrayBuffer(scopeSize));
                            // Execute the serialization into a seperate buffer
                            serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions);

                            // Adjusted scope Size (removing the header)
                            var scopeDocSize = scopeSize;
                            // Write scope object size
                            buffer[index++] = scopeDocSize & 0xff;
                            buffer[index++] = (scopeDocSize >> 8) & 0xff;
                            buffer[index++] = (scopeDocSize >> 16) & 0xff;
                            buffer[index++] = (scopeDocSize >> 24) & 0xff;

                            // Write the scopeObject into the buffer
                            supportsBuffer ? scopeObjectBuffer.copy(buffer, index, 0, scopeSize) : buffer.set(scopeObjectBuffer, index);
                            // Adjust index, removing the empty size of the doc (5 bytes 0000000005)
                            index = index + scopeDocSize - 5;
                            // Write trailing zero
                            buffer[index++] = 0;
                            return index
                        } else {
                            buffer[index++] = BSON.BSON_DATA_CODE;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            // Function string
                            var functionString = value.code.toString();
                            // Function Size
                            var size = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
                            // Write the size of the string to buffer
                            buffer[index++] = size & 0xff;
                            buffer[index++] = (size >> 8) & 0xff;
                            buffer[index++] = (size >> 16) & 0xff;
                            buffer[index++] = (size >> 24) & 0xff;
                            // Write the string
                            supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
                            // Update index
                            index = index + size - 1;
                            // Write zero
                            buffer[index++] = 0;
                            return index;
                        }
                    } else if (value instanceof Binary || value['_bsontype'] == 'Binary') {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_BINARY;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Extract the buffer
                        var data = value.value(true);
                        // Calculate size
                        var size = value.position;
                        // Write the size of the string to buffer
                        buffer[index++] = size & 0xff;
                        buffer[index++] = (size >> 8) & 0xff;
                        buffer[index++] = (size >> 16) & 0xff;
                        buffer[index++] = (size >> 24) & 0xff;
                        // Write the subtype to the buffer
                        buffer[index++] = value.sub_type;

                        // If we have binary type 2 the 4 first bytes are the size
                        if (value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
                            buffer[index++] = size & 0xff;
                            buffer[index++] = (size >> 8) & 0xff;
                            buffer[index++] = (size >> 16) & 0xff;
                            buffer[index++] = (size >> 24) & 0xff;
                        }

                        // Write the data to the object
                        supportsBuffer ? data.copy(buffer, index, 0, value.position) : buffer.set(data, index);
                        // Ajust index
                        index = index + value.position;
                        return index;
                    } else if (value instanceof Symbol || value['_bsontype'] == 'Symbol') {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_SYMBOL;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Calculate size
                        var size = supportsBuffer ? Buffer.byteLength(value.value) + 1 : numberOfBytes(value.value) + 1;
                        // Write the size of the string to buffer
                        buffer[index++] = size & 0xff;
                        buffer[index++] = (size >> 8) & 0xff;
                        buffer[index++] = (size >> 16) & 0xff;
                        buffer[index++] = (size >> 24) & 0xff;
                        // Write the string
                        buffer.write(value.value, index, 'utf8');
                        // Update index
                        index = index + size - 1;
                        // Write zero
                        buffer[index++] = 0x00;
                        return index;
                    } else if (value instanceof DBRef || value['_bsontype'] == 'DBRef') {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_OBJECT;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        // Set up correct object for serialization
                        var ordered_values = {
                            '$ref': value.namespace,
                            '$id': value.oid
                        };

                        // Add db reference if it exists
                        if (null != value.db) {
                            ordered_values['$db'] = value.db;
                        }

                        // Message size
                        var size = BSON.calculateObjectSize(ordered_values, serializeFunctions);
                        // Serialize the object
                        var endIndex = BSON.serializeWithBufferAndIndex(ordered_values, checkKeys, buffer, index, serializeFunctions);
                        // Write the size of the string to buffer
                        buffer[index++] = size & 0xff;
                        buffer[index++] = (size >> 8) & 0xff;
                        buffer[index++] = (size >> 16) & 0xff;
                        buffer[index++] = (size >> 24) & 0xff;
                        // Write zero for object
                        buffer[endIndex++] = 0x00;
                        // Return the end index
                        return endIndex;
                    } else if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_REGEXP;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;

                        // Write the regular expression string
                        supportsBuffer ? buffer.write(value.source, index, 'utf8') : writeToTypedArray(buffer, value.source, index);
                        // Adjust the index
                        index = index + (supportsBuffer ? Buffer.byteLength(value.source) : numberOfBytes(value.source));
                        // Write zero
                        buffer[index++] = 0x00;
                        // Write the parameters
                        if (value.global) buffer[index++] = 0x73; // s
                        if (value.ignoreCase) buffer[index++] = 0x69; // i
                        if (value.multiline) buffer[index++] = 0x6d; // m
                        // Add ending zero
                        buffer[index++] = 0x00;
                        return index;
                    } else {
                        // Write the type
                        buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Adjust the index
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;
                        var endIndex = serializeObject(value, checkKeys, buffer, index + 4, serializeFunctions);
                        // Write size
                        var size = endIndex - index;
                        // Write the size of the string to buffer
                        buffer[index++] = size & 0xff;
                        buffer[index++] = (size >> 8) & 0xff;
                        buffer[index++] = (size >> 16) & 0xff;
                        buffer[index++] = (size >> 24) & 0xff;
                        return endIndex;
                    }
                case 'function':
                    // WTF for 0.4.X where typeof /someregexp/ === 'function'
                    if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
                        // Write the type
                        buffer[index++] = BSON.BSON_DATA_REGEXP;
                        // Number of written bytes
                        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                        // Encode the name
                        index = index + numberOfWrittenBytes + 1;
                        buffer[index - 1] = 0;

                        // Write the regular expression string
                        buffer.write(value.source, index, 'utf8');
                        // Adjust the index
                        index = index + (supportsBuffer ? Buffer.byteLength(value.source) : numberOfBytes(value.source));
                        // Write zero
                        buffer[index++] = 0x00;
                        // Write the parameters
                        if (value.global) buffer[index++] = 0x73; // s
                        if (value.ignoreCase) buffer[index++] = 0x69; // i
                        if (value.multiline) buffer[index++] = 0x6d; // m
                        // Add ending zero
                        buffer[index++] = 0x00;
                        return index;
                    } else {
                        if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
                            // Write the type
                            buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            // Calculate the scope size
                            var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions);
                            // Function string
                            var functionString = value.toString();
                            // Function Size
                            var codeSize = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;

                            // Calculate full size of the object
                            var totalSize = 4 + codeSize + scopeSize;

                            // Write the total size of the object
                            buffer[index++] = totalSize & 0xff;
                            buffer[index++] = (totalSize >> 8) & 0xff;
                            buffer[index++] = (totalSize >> 16) & 0xff;
                            buffer[index++] = (totalSize >> 24) & 0xff;

                            // Write the size of the string to buffer
                            buffer[index++] = codeSize & 0xff;
                            buffer[index++] = (codeSize >> 8) & 0xff;
                            buffer[index++] = (codeSize >> 16) & 0xff;
                            buffer[index++] = (codeSize >> 24) & 0xff;

                            // Write the string
                            supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
                            // Update index
                            index = index + codeSize - 1;
                            // Write zero
                            buffer[index++] = 0;
                            // Serialize the scope object
                            var scopeObjectBuffer = new Buffer(scopeSize);
                            // Execute the serialization into a seperate buffer
                            serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions);

                            // Adjusted scope Size (removing the header)
                            var scopeDocSize = scopeSize - 4;
                            // Write scope object size
                            buffer[index++] = scopeDocSize & 0xff;
                            buffer[index++] = (scopeDocSize >> 8) & 0xff;
                            buffer[index++] = (scopeDocSize >> 16) & 0xff;
                            buffer[index++] = (scopeDocSize >> 24) & 0xff;

                            // Write the scopeObject into the buffer
                            scopeObjectBuffer.copy(buffer, index, 0, scopeSize);

                            // Adjust index, removing the empty size of the doc (5 bytes 0000000005)
                            index = index + scopeDocSize - 5;
                            // Write trailing zero
                            buffer[index++] = 0;
                            return index
                        } else if (serializeFunctions) {
                            buffer[index++] = BSON.BSON_DATA_CODE;
                            // Number of written bytes
                            var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
                            // Encode the name
                            index = index + numberOfWrittenBytes + 1;
                            buffer[index - 1] = 0;
                            // Function string
                            var functionString = value.toString();
                            // Function Size
                            var size = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
                            // Write the size of the string to buffer
                            buffer[index++] = size & 0xff;
                            buffer[index++] = (size >> 8) & 0xff;
                            buffer[index++] = (size >> 16) & 0xff;
                            buffer[index++] = (size >> 24) & 0xff;
                            // Write the string
                            supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
                            // Update index
                            index = index + size - 1;
                            // Write zero
                            buffer[index++] = 0;
                            return index;
                        }
                    }
            }

            // If no value to serialize
            return index;
        }

        /**
         * Serialize a Javascript object.
         *
         * @param {Object} object the Javascript object to serialize.
         * @param {Boolean} checkKeys the serializer will check if keys are valid.
         * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
         * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
         * @return {Buffer} returns the Buffer object containing the serialized object.
         * @api public
         */
        BSON.serialize = function(object, checkKeys, asBuffer, serializeFunctions) {
            // Throw error if we are trying serialize an illegal type
            if (object == null || typeof object != 'object' || Array.isArray(object))
                throw new Error("Only javascript objects supported");

            // Emoty target buffer
            var buffer = null;
            // Calculate the size of the object
            var size = BSON.calculateObjectSize(object, serializeFunctions);
            // Fetch the best available type for storing the binary data
            if (buffer = typeof Buffer != 'undefined') {
                buffer = new Buffer(size);
                asBuffer = true;
            } else if (typeof Uint8Array != 'undefined') {
                buffer = new Uint8Array(new ArrayBuffer(size));
            } else {
                buffer = new Array(size);
            }

            // If asBuffer is false use typed arrays
            BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, 0, serializeFunctions);
            // console.log("++++++++++++++++++++++++++++++++++++ OLDJS :: " + buffer.length)  
            // console.log(buffer.toString('hex'))
            // console.log(buffer.toString('ascii'))
            return buffer;
        }

        /**
         * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
         *
         * @ignore
         * @api private
         */
        var functionCache = BSON.functionCache = {};

        /**
         * Crc state variables shared by function
         *
         * @ignore
         * @api private
         */
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

        /**
         * CRC32 hash method, Fast and enough versitility for our usage
         *
         * @ignore
         * @api private
         */
        var crc32 = function(string, start, end) {
            var crc = 0
            var x = 0;
            var y = 0;
            crc = crc ^ (-1);

            for (var i = start, iTop = end; i < iTop; i++) {
                y = (crc ^ string[i]) & 0xFF;
                x = table[y];
                crc = (crc >>> 8) ^ x;
            }

            return crc ^ (-1);
        }

        /**
         * Deserialize stream data as BSON documents.
         *
         * Options
         *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
         *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
         *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
         *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
         *
         * @param {Buffer} data the buffer containing the serialized set of BSON documents.
         * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
         * @param {Number} numberOfDocuments number of documents to deserialize.
         * @param {Array} documents an array where to store the deserialized documents.
         * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
         * @param {Object} [options] additional options used for the deserialization.
         * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
         * @api public
         */
        BSON.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
            // if(numberOfDocuments !== documents.length) throw new Error("Number of expected results back is less than the number of documents");
            options = options != null ? options : {};
            var index = startIndex;
            // Loop over all documents
            for (var i = 0; i < numberOfDocuments; i++) {
                // Find size of the document
                var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
                // Update options with index
                options['index'] = index;
                // Parse the document at this point
                documents[docStartIndex + i] = BSON.deserialize(data, options);
                // Adjust index by the document size
                index = index + size;
            }

            // Return object containing end index of parsing and list of documents
            return index;
        }

        /**
         * Ensure eval is isolated.
         *
         * @ignore
         * @api private
         */
        var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
            // Contains the value we are going to set
            var value = null;

            // Check for cache hit, eval if missing and return cached function
            if (functionCache[hash] == null) {
                eval("value = " + functionString);
                functionCache[hash] = value;
            }
            // Set the object
            return functionCache[hash].bind(object);
        }

        /**
         * Ensure eval is isolated.
         *
         * @ignore
         * @api private
         */
        var isolateEval = function(functionString) {
            // Contains the value we are going to set
            var value = null;
            // Eval the function
            eval("value = " + functionString);
            return value;
        }

        /**
         * Convert Uint8Array to String
         *
         * @ignore
         * @api private
         */
        var convertUint8ArrayToUtf8String = function(byteArray, startIndex, endIndex) {
            return BinaryParser.decode_utf8(convertArraytoUtf8BinaryString(byteArray, startIndex, endIndex));
        }

        var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
            var result = "";
            for (var i = startIndex; i < endIndex; i++) {
                result = result + String.fromCharCode(byteArray[i]);
            }

            return result;
        };

        /**
         * Deserialize data as BSON.
         *
         * Options
         *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
         *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
         *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
         *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
         *
         * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
         * @param {Object} [options] additional options used for the deserialization.
         * @param {Boolean} [isArray] ignore used for recursive parsing.
         * @return {Object} returns the deserialized Javascript Object.
         * @api public
         */
        BSON.deserialize = function(buffer, options, isArray) {
            // Options
            options = options == null ? {} : options;
            var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
            var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
            var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
            var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];

            // Validate that we have at least 4 bytes of buffer
            if (buffer.length < 5) throw new Error("corrupt bson message < 5 bytes long");

            // Set up index
            var index = typeof options['index'] == 'number' ? options['index'] : 0;
            // Reads in a C style string
            var readCStyleString = function() {
                // Get the start search index
                var i = index;
                // Locate the end of the c string
                while (buffer[i] !== 0x00 && i < buffer.length) {
                    i++
                }
                // If are at the end of the buffer there is a problem with the document
                if (i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
                    // Grab utf8 encoded string
                var string = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, i) : convertUint8ArrayToUtf8String(buffer, index, i);
                // Update index position
                index = i + 1;
                // Return string
                return string;
            }

            // Create holding object
            var object = isArray ? [] : {};

            // Read the document size
            var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;

            // Ensure buffer is valid size
            if (size < 5 || size > buffer.length) throw new Error("corrupt bson message");

            // While we have more left data left keep parsing
            while (true) {
                // Read the type
                var elementType = buffer[index++];
                // If we get a zero it's the last byte, exit
                if (elementType == 0) break;
                // Read the name of the field
                var name = readCStyleString();
                // Switch on the type
                switch (elementType) {
                    case BSON.BSON_DATA_OID:
                        var string = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('binary', index, index + 12) : convertArraytoUtf8BinaryString(buffer, index, index + 12);
                        // Decode the oid
                        object[name] = new ObjectID(string);
                        // Update index
                        index = index + 12;
                        break;
                    case BSON.BSON_DATA_STRING:
                        // Read the content of the field
                        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Add string to object
                        object[name] = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
                        // Update parse index position
                        index = index + stringSize;
                        break;
                    case BSON.BSON_DATA_INT:
                        // Decode the 32bit value
                        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        break;
                    case BSON.BSON_DATA_NUMBER:
                        // Decode the double value
                        object[name] = readIEEE754(buffer, index, 'little', 52, 8);
                        // Update the index
                        index = index + 8;
                        break;
                    case BSON.BSON_DATA_DATE:
                        // Unpack the low and high bits
                        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Set date object
                        object[name] = new Date(new Long(lowBits, highBits).toNumber());
                        break;
                    case BSON.BSON_DATA_BOOLEAN:
                        // Parse the boolean value
                        object[name] = buffer[index++] == 1;
                        break;
                    case BSON.BSON_DATA_UNDEFINED:
                    case BSON.BSON_DATA_NULL:
                        // Parse the boolean value
                        object[name] = null;
                        break;
                    case BSON.BSON_DATA_BINARY:
                        // Decode the size of the binary blob
                        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Decode the subtype
                        var subType = buffer[index++];
                        // Decode as raw Buffer object if options specifies it
                        if (buffer['slice'] != null) {
                            // If we have subtype 2 skip the 4 bytes for the size
                            if (subType == Binary.SUBTYPE_BYTE_ARRAY) {
                                binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                            }
                            // Slice the data
                            object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
                        } else {
                            var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
                            // If we have subtype 2 skip the 4 bytes for the size
                            if (subType == Binary.SUBTYPE_BYTE_ARRAY) {
                                binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                            }
                            // Copy the data
                            for (var i = 0; i < binarySize; i++) {
                                _buffer[i] = buffer[index + i];
                            }
                            // Create the binary object
                            object[name] = new Binary(_buffer, subType);
                        }
                        // Update the index
                        index = index + binarySize;
                        break;
                    case BSON.BSON_DATA_ARRAY:
                        options['index'] = index;
                        // Decode the size of the array document
                        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
                        // Set the array to the object
                        object[name] = BSON.deserialize(buffer, options, true);
                        // Adjust the index
                        index = index + objectSize;
                        break;
                    case BSON.BSON_DATA_OBJECT:
                        options['index'] = index;
                        // Decode the size of the object document
                        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
                        // Set the array to the object
                        object[name] = BSON.deserialize(buffer, options, false);
                        // Adjust the index
                        index = index + objectSize;
                        break;
                    case BSON.BSON_DATA_REGEXP:
                        // Create the regexp
                        var source = readCStyleString();
                        var regExpOptions = readCStyleString();
                        // For each option add the corresponding one for javascript
                        var optionsArray = new Array(regExpOptions.length);

                        // Parse options
                        for (var i = 0; i < regExpOptions.length; i++) {
                            switch (regExpOptions[i]) {
                                case 'm':
                                    optionsArray[i] = 'm';
                                    break;
                                case 's':
                                    optionsArray[i] = 'g';
                                    break;
                                case 'i':
                                    optionsArray[i] = 'i';
                                    break;
                            }
                        }

                        object[name] = new RegExp(source, optionsArray.join(''));
                        break;
                    case BSON.BSON_DATA_LONG:
                        // Unpack the low and high bits
                        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Create long object
                        var long = new Long(lowBits, highBits);
                        // Promote the long if possible
                        if (promoteLongs) {
                            object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
                        } else {
                            object[name] = long;
                        }
                        break;
                    case BSON.BSON_DATA_SYMBOL:
                        // Read the content of the field
                        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Add string to object
                        object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));
                        // Update parse index position
                        index = index + stringSize;
                        break;
                    case BSON.BSON_DATA_TIMESTAMP:
                        // Unpack the low and high bits
                        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Set the object
                        object[name] = new Timestamp(lowBits, highBits);
                        break;
                    case BSON.BSON_DATA_MIN_KEY:
                        // Parse the object
                        object[name] = new MinKey();
                        break;
                    case BSON.BSON_DATA_MAX_KEY:
                        // Parse the object
                        object[name] = new MaxKey();
                        break;
                    case BSON.BSON_DATA_CODE:
                        // Read the content of the field
                        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Function string
                        var functionString = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);

                        // If we are evaluating the functions
                        if (evalFunctions) {
                            // Contains the value we are going to set
                            var value = null;
                            // If we have cache enabled let's look for the md5 of the function in the cache
                            if (cacheFunctions) {
                                var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
                                // Got to do this to avoid V8 deoptimizing the call due to finding eval
                                object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
                            } else {
                                // Set directly
                                object[name] = isolateEval(functionString);
                            }
                        } else {
                            object[name] = new Code(functionString, {});
                        }

                        // Update parse index position
                        index = index + stringSize;
                        break;
                    case BSON.BSON_DATA_CODE_W_SCOPE:
                        // Read the content of the field
                        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
                        // Javascript function
                        var functionString = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
                        // Update parse index position
                        index = index + stringSize;
                        // Parse the element
                        options['index'] = index;
                        // Decode the size of the object document
                        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
                        // Decode the scope object
                        var scopeObject = BSON.deserialize(buffer, options, false);
                        // Adjust the index
                        index = index + objectSize;

                        // If we are evaluating the functions
                        if (evalFunctions) {
                            // Contains the value we are going to set
                            var value = null;
                            // If we have cache enabled let's look for the md5 of the function in the cache
                            if (cacheFunctions) {
                                var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
                                // Got to do this to avoid V8 deoptimizing the call due to finding eval
                                object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
                            } else {
                                // Set directly
                                object[name] = isolateEval(functionString);
                            }

                            // Set the scope on the object
                            object[name].scope = scopeObject;
                        } else {
                            object[name] = new Code(functionString, scopeObject);
                        }

                        // Add string to object
                        break;
                }
            }

            // Check if we have a db ref object
            if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);

            // Return the final objects
            return object;
        }

        /**
         * Check if key name is valid.
         *
         * @ignore
         * @api private
         */
        BSON.checkKey = function checkKey(key, dollarsAndDotsOk) {
            if (!key.length) return;
            // Check if we have a legal key for the object
            if (!!~key.indexOf("\x00")) {
                // The BSON spec doesn't allow keys with null bytes because keys are
                // null-terminated.
                throw Error("key " + key + " must not contain null bytes");
            }
            if (!dollarsAndDotsOk) {
                if ('$' == key[0]) {
                    throw Error("key " + key + " must not start with '$'");
                } else if (!!~key.indexOf('.')) {
                    throw Error("key " + key + " must not contain '.'");
                }
            }
        };

        /**
         * Deserialize data as BSON.
         *
         * Options
         *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
         *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
         *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
         *
         * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
         * @param {Object} [options] additional options used for the deserialization.
         * @param {Boolean} [isArray] ignore used for recursive parsing.
         * @return {Object} returns the deserialized Javascript Object.
         * @api public
         */
        BSON.prototype.deserialize = function(data, options) {
            return BSON.deserialize(data, options);
        }

        /**
         * Deserialize stream data as BSON documents.
         *
         * Options
         *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
         *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
         *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
         *
         * @param {Buffer} data the buffer containing the serialized set of BSON documents.
         * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
         * @param {Number} numberOfDocuments number of documents to deserialize.
         * @param {Array} documents an array where to store the deserialized documents.
         * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
         * @param {Object} [options] additional options used for the deserialization.
         * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
         * @api public
         */
        BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
            return BSON.deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options);
        }

        /**
         * Serialize a Javascript object.
         *
         * @param {Object} object the Javascript object to serialize.
         * @param {Boolean} checkKeys the serializer will check if keys are valid.
         * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
         * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
         * @return {Buffer} returns the Buffer object containing the serialized object.
         * @api public
         */
        BSON.prototype.serialize = function(object, checkKeys, asBuffer, serializeFunctions) {
            return BSON.serialize(object, checkKeys, asBuffer, serializeFunctions);
        }

        /**
         * Calculate the bson size for a passed in Javascript object.
         *
         * @param {Object} object the Javascript object to calculate the BSON byte size for.
         * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
         * @return {Number} returns the number of bytes the BSON object will take up.
         * @api public
         */
        BSON.prototype.calculateObjectSize = function(object, serializeFunctions) {
            return BSON.calculateObjectSize(object, serializeFunctions);
        }

        /**
         * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
         *
         * @param {Object} object the Javascript object to serialize.
         * @param {Boolean} checkKeys the serializer will check if keys are valid.
         * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
         * @param {Number} index the index in the buffer where we wish to start serializing into.
         * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
         * @return {Number} returns the new write index in the Buffer.
         * @api public
         */
        BSON.prototype.serializeWithBufferAndIndex = function(object, checkKeys, buffer, startIndex, serializeFunctions) {
            return BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, startIndex, serializeFunctions);
        }

        /**
         * @ignore
         * @api private
         */
        exports.Code = Code;
        exports.Symbol = Symbol;
        exports.BSON = BSON;
        exports.DBRef = DBRef;
        exports.Binary = Binary;
        exports.ObjectID = ObjectID;
        exports.Long = Long;
        exports.Timestamp = Timestamp;
        exports.Double = Double;
        exports.MinKey = MinKey;
        exports.MaxKey = MaxKey;


    },
    function(require, exports, module, global) {

        // Licensed under the Apache License, Version 2.0 (the "License");
        // you may not use this file except in compliance with the License.
        // You may obtain a copy of the License at
        //
        //     http://www.apache.org/licenses/LICENSE-2.0
        //
        // Unless required by applicable law or agreed to in writing, software
        // distributed under the License is distributed on an "AS IS" BASIS,
        // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        // See the License for the specific language governing permissions and
        // limitations under the License.
        //
        // Copyright 2009 Google Inc. All Rights Reserved

        /**
         * Defines a Long class for representing a 64-bit two's-complement
         * integer value, which faithfully simulates the behavior of a Java "Long". This
         * implementation is derived from LongLib in GWT.
         *
         * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
         * values as *signed* integers.  See the from* functions below for more
         * convenient ways of constructing Longs.
         *
         * The internal representation of a Long is the two given signed, 32-bit values.
         * We use 32-bit pieces because these are the size of integers on which
         * Javascript performs bit-operations.  For operations like addition and
         * multiplication, we split each number into 16-bit pieces, which can easily be
         * multiplied within Javascript's floating-point representation without overflow
         * or change in sign.
         *
         * In the algorithms below, we frequently reduce the negative case to the
         * positive case by negating the input(s) and then post-processing the result.
         * Note that we must ALWAYS check specially whether those values are MIN_VALUE
         * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
         * a positive number, it overflows back into a negative).  Not handling this
         * case would often result in infinite recursion.
         *
         * @class Represents the BSON Long type.
         * @param {Number} low  the low (signed) 32 bits of the Long.
         * @param {Number} high the high (signed) 32 bits of the Long.
         */
        function Long(low, high) {
            if (!(this instanceof Long)) return new Long(low, high);

            this._bsontype = 'Long';
            /**
             * @type {number}
             * @api private
             */
            this.low_ = low | 0; // force into 32 signed bits.

            /**
             * @type {number}
             * @api private
             */
            this.high_ = high | 0; // force into 32 signed bits.
        };

        /**
         * Return the int value.
         *
         * @return {Number} the value, assuming it is a 32-bit integer.
         * @api public
         */
        Long.prototype.toInt = function() {
            return this.low_;
        };

        /**
         * Return the Number value.
         *
         * @return {Number} the closest floating-point representation to this value.
         * @api public
         */
        Long.prototype.toNumber = function() {
            return this.high_ * Long.TWO_PWR_32_DBL_ +
                this.getLowBitsUnsigned();
        };

        /**
         * Return the JSON value.
         *
         * @return {String} the JSON representation.
         * @api public
         */
        Long.prototype.toJSON = function() {
            return this.toString();
        }

        /**
         * Return the String value.
         *
         * @param {Number} [opt_radix] the radix in which the text should be written.
         * @return {String} the textual representation of this value.
         * @api public
         */
        Long.prototype.toString = function(opt_radix) {
            var radix = opt_radix || 10;
            if (radix < 2 || 36 < radix) {
                throw Error('radix out of range: ' + radix);
            }

            if (this.isZero()) {
                return '0';
            }

            if (this.isNegative()) {
                if (this.equals(Long.MIN_VALUE)) {
                    // We need to change the Long value before it can be negated, so we remove
                    // the bottom-most digit in this base and then recurse to do the rest.
                    var radixLong = Long.fromNumber(radix);
                    var div = this.div(radixLong);
                    var rem = div.multiply(radixLong).subtract(this);
                    return div.toString(radix) + rem.toInt().toString(radix);
                } else {
                    return '-' + this.negate().toString(radix);
                }
            }

            // Do several (6) digits each time through the loop, so as to
            // minimize the calls to the very expensive emulated div.
            var radixToPower = Long.fromNumber(Math.pow(radix, 6));

            var rem = this;
            var result = '';
            while (true) {
                var remDiv = rem.div(radixToPower);
                var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
                var digits = intval.toString(radix);

                rem = remDiv;
                if (rem.isZero()) {
                    return digits + result;
                } else {
                    while (digits.length < 6) {
                        digits = '0' + digits;
                    }
                    result = '' + digits + result;
                }
            }
        };

        /**
         * Return the high 32-bits value.
         *
         * @return {Number} the high 32-bits as a signed value.
         * @api public
         */
        Long.prototype.getHighBits = function() {
            return this.high_;
        };

        /**
         * Return the low 32-bits value.
         *
         * @return {Number} the low 32-bits as a signed value.
         * @api public
         */
        Long.prototype.getLowBits = function() {
            return this.low_;
        };

        /**
         * Return the low unsigned 32-bits value.
         *
         * @return {Number} the low 32-bits as an unsigned value.
         * @api public
         */
        Long.prototype.getLowBitsUnsigned = function() {
            return (this.low_ >= 0) ?
                this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
        };

        /**
         * Returns the number of bits needed to represent the absolute value of this Long.
         *
         * @return {Number} Returns the number of bits needed to represent the absolute value of this Long.
         * @api public
         */
        Long.prototype.getNumBitsAbs = function() {
            if (this.isNegative()) {
                if (this.equals(Long.MIN_VALUE)) {
                    return 64;
                } else {
                    return this.negate().getNumBitsAbs();
                }
            } else {
                var val = this.high_ != 0 ? this.high_ : this.low_;
                for (var bit = 31; bit > 0; bit--) {
                    if ((val & (1 << bit)) != 0) {
                        break;
                    }
                }
                return this.high_ != 0 ? bit + 33 : bit + 1;
            }
        };

        /**
         * Return whether this value is zero.
         *
         * @return {Boolean} whether this value is zero.
         * @api public
         */
        Long.prototype.isZero = function() {
            return this.high_ == 0 && this.low_ == 0;
        };

        /**
         * Return whether this value is negative.
         *
         * @return {Boolean} whether this value is negative.
         * @api public
         */
        Long.prototype.isNegative = function() {
            return this.high_ < 0;
        };

        /**
         * Return whether this value is odd.
         *
         * @return {Boolean} whether this value is odd.
         * @api public
         */
        Long.prototype.isOdd = function() {
            return (this.low_ & 1) == 1;
        };

        /**
         * Return whether this Long equals the other
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} whether this Long equals the other
         * @api public
         */
        Long.prototype.equals = function(other) {
            return (this.high_ == other.high_) && (this.low_ == other.low_);
        };

        /**
         * Return whether this Long does not equal the other.
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} whether this Long does not equal the other.
         * @api public
         */
        Long.prototype.notEquals = function(other) {
            return (this.high_ != other.high_) || (this.low_ != other.low_);
        };

        /**
         * Return whether this Long is less than the other.
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} whether this Long is less than the other.
         * @api public
         */
        Long.prototype.lessThan = function(other) {
            return this.compare(other) < 0;
        };

        /**
         * Return whether this Long is less than or equal to the other.
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} whether this Long is less than or equal to the other.
         * @api public
         */
        Long.prototype.lessThanOrEqual = function(other) {
            return this.compare(other) <= 0;
        };

        /**
         * Return whether this Long is greater than the other.
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} whether this Long is greater than the other.
         * @api public
         */
        Long.prototype.greaterThan = function(other) {
            return this.compare(other) > 0;
        };

        /**
         * Return whether this Long is greater than or equal to the other.
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} whether this Long is greater than or equal to the other.
         * @api public
         */
        Long.prototype.greaterThanOrEqual = function(other) {
            return this.compare(other) >= 0;
        };

        /**
         * Compares this Long with the given one.
         *
         * @param {Long} other Long to compare against.
         * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
         * @api public
         */
        Long.prototype.compare = function(other) {
            if (this.equals(other)) {
                return 0;
            }

            var thisNeg = this.isNegative();
            var otherNeg = other.isNegative();
            if (thisNeg && !otherNeg) {
                return -1;
            }
            if (!thisNeg && otherNeg) {
                return 1;
            }

            // at this point, the signs are the same, so subtraction will not overflow
            if (this.subtract(other).isNegative()) {
                return -1;
            } else {
                return 1;
            }
        };

        /**
         * The negation of this value.
         *
         * @return {Long} the negation of this value.
         * @api public
         */
        Long.prototype.negate = function() {
            if (this.equals(Long.MIN_VALUE)) {
                return Long.MIN_VALUE;
            } else {
                return this.not().add(Long.ONE);
            }
        };

        /**
         * Returns the sum of this and the given Long.
         *
         * @param {Long} other Long to add to this one.
         * @return {Long} the sum of this and the given Long.
         * @api public
         */
        Long.prototype.add = function(other) {
            // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

            var a48 = this.high_ >>> 16;
            var a32 = this.high_ & 0xFFFF;
            var a16 = this.low_ >>> 16;
            var a00 = this.low_ & 0xFFFF;

            var b48 = other.high_ >>> 16;
            var b32 = other.high_ & 0xFFFF;
            var b16 = other.low_ >>> 16;
            var b00 = other.low_ & 0xFFFF;

            var c48 = 0,
                c32 = 0,
                c16 = 0,
                c00 = 0;
            c00 += a00 + b00;
            c16 += c00 >>> 16;
            c00 &= 0xFFFF;
            c16 += a16 + b16;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c32 += a32 + b32;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c48 += a48 + b48;
            c48 &= 0xFFFF;
            return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
        };

        /**
         * Returns the difference of this and the given Long.
         *
         * @param {Long} other Long to subtract from this.
         * @return {Long} the difference of this and the given Long.
         * @api public
         */
        Long.prototype.subtract = function(other) {
            return this.add(other.negate());
        };

        /**
         * Returns the product of this and the given Long.
         *
         * @param {Long} other Long to multiply with this.
         * @return {Long} the product of this and the other.
         * @api public
         */
        Long.prototype.multiply = function(other) {
            if (this.isZero()) {
                return Long.ZERO;
            } else if (other.isZero()) {
                return Long.ZERO;
            }

            if (this.equals(Long.MIN_VALUE)) {
                return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
            } else if (other.equals(Long.MIN_VALUE)) {
                return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
            }

            if (this.isNegative()) {
                if (other.isNegative()) {
                    return this.negate().multiply(other.negate());
                } else {
                    return this.negate().multiply(other).negate();
                }
            } else if (other.isNegative()) {
                return this.multiply(other.negate()).negate();
            }

            // If both Longs are small, use float multiplication
            if (this.lessThan(Long.TWO_PWR_24_) &&
                other.lessThan(Long.TWO_PWR_24_)) {
                return Long.fromNumber(this.toNumber() * other.toNumber());
            }

            // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
            // We can skip products that would overflow.

            var a48 = this.high_ >>> 16;
            var a32 = this.high_ & 0xFFFF;
            var a16 = this.low_ >>> 16;
            var a00 = this.low_ & 0xFFFF;

            var b48 = other.high_ >>> 16;
            var b32 = other.high_ & 0xFFFF;
            var b16 = other.low_ >>> 16;
            var b00 = other.low_ & 0xFFFF;

            var c48 = 0,
                c32 = 0,
                c16 = 0,
                c00 = 0;
            c00 += a00 * b00;
            c16 += c00 >>> 16;
            c00 &= 0xFFFF;
            c16 += a16 * b00;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c16 += a00 * b16;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c32 += a32 * b00;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c32 += a16 * b16;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c32 += a00 * b32;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
            c48 &= 0xFFFF;
            return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
        };

        /**
         * Returns this Long divided by the given one.
         *
         * @param {Long} other Long by which to divide.
         * @return {Long} this Long divided by the given one.
         * @api public
         */
        Long.prototype.div = function(other) {
            if (other.isZero()) {
                throw Error('division by zero');
            } else if (this.isZero()) {
                return Long.ZERO;
            }

            if (this.equals(Long.MIN_VALUE)) {
                if (other.equals(Long.ONE) ||
                    other.equals(Long.NEG_ONE)) {
                    return Long.MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                } else if (other.equals(Long.MIN_VALUE)) {
                    return Long.ONE;
                } else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shiftRight(1);
                    var approx = halfThis.div(other).shiftLeft(1);
                    if (approx.equals(Long.ZERO)) {
                        return other.isNegative() ? Long.ONE : Long.NEG_ONE;
                    } else {
                        var rem = this.subtract(other.multiply(approx));
                        var result = approx.add(rem.div(other));
                        return result;
                    }
                }
            } else if (other.equals(Long.MIN_VALUE)) {
                return Long.ZERO;
            }

            if (this.isNegative()) {
                if (other.isNegative()) {
                    return this.negate().div(other.negate());
                } else {
                    return this.negate().div(other).negate();
                }
            } else if (other.isNegative()) {
                return this.div(other.negate()).negate();
            }

            // Repeat the following until the remainder is less than other:  find a
            // floating-point that approximates remainder / other *from below*, add this
            // into the result, and subtract it from the remainder.  It is critical that
            // the approximate value is less than or equal to the real value so that the
            // remainder never becomes negative.
            var res = Long.ZERO;
            var rem = this;
            while (rem.greaterThanOrEqual(other)) {
                // Approximate the result of division. This may be a little greater or
                // smaller than the actual value.
                var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

                // We will tweak the approximate result by changing it in the 48-th digit or
                // the smallest non-fractional digit, whichever is larger.
                var log2 = Math.ceil(Math.log(approx) / Math.LN2);
                var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

                // Decrease the approximation until it is smaller than the remainder.  Note
                // that if it is too large, the product overflows and is negative.
                var approxRes = Long.fromNumber(approx);
                var approxRem = approxRes.multiply(other);
                while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                    approx -= delta;
                    approxRes = Long.fromNumber(approx);
                    approxRem = approxRes.multiply(other);
                }

                // We know the answer can't be zero... and actually, zero would cause
                // infinite recursion since we would make no progress.
                if (approxRes.isZero()) {
                    approxRes = Long.ONE;
                }

                res = res.add(approxRes);
                rem = rem.subtract(approxRem);
            }
            return res;
        };

        /**
         * Returns this Long modulo the given one.
         *
         * @param {Long} other Long by which to mod.
         * @return {Long} this Long modulo the given one.
         * @api public
         */
        Long.prototype.modulo = function(other) {
            return this.subtract(this.div(other).multiply(other));
        };

        /**
         * The bitwise-NOT of this value.
         *
         * @return {Long} the bitwise-NOT of this value.
         * @api public
         */
        Long.prototype.not = function() {
            return Long.fromBits(~this.low_, ~this.high_);
        };

        /**
         * Returns the bitwise-AND of this Long and the given one.
         *
         * @param {Long} other the Long with which to AND.
         * @return {Long} the bitwise-AND of this and the other.
         * @api public
         */
        Long.prototype.and = function(other) {
            return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
        };

        /**
         * Returns the bitwise-OR of this Long and the given one.
         *
         * @param {Long} other the Long with which to OR.
         * @return {Long} the bitwise-OR of this and the other.
         * @api public
         */
        Long.prototype.or = function(other) {
            return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
        };

        /**
         * Returns the bitwise-XOR of this Long and the given one.
         *
         * @param {Long} other the Long with which to XOR.
         * @return {Long} the bitwise-XOR of this and the other.
         * @api public
         */
        Long.prototype.xor = function(other) {
            return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
        };

        /**
         * Returns this Long with bits shifted to the left by the given amount.
         *
         * @param {Number} numBits the number of bits by which to shift.
         * @return {Long} this shifted to the left by the given amount.
         * @api public
         */
        Long.prototype.shiftLeft = function(numBits) {
            numBits &= 63;
            if (numBits == 0) {
                return this;
            } else {
                var low = this.low_;
                if (numBits < 32) {
                    var high = this.high_;
                    return Long.fromBits(
                        low << numBits, (high << numBits) | (low >>> (32 - numBits)));
                } else {
                    return Long.fromBits(0, low << (numBits - 32));
                }
            }
        };

        /**
         * Returns this Long with bits shifted to the right by the given amount.
         *
         * @param {Number} numBits the number of bits by which to shift.
         * @return {Long} this shifted to the right by the given amount.
         * @api public
         */
        Long.prototype.shiftRight = function(numBits) {
            numBits &= 63;
            if (numBits == 0) {
                return this;
            } else {
                var high = this.high_;
                if (numBits < 32) {
                    var low = this.low_;
                    return Long.fromBits(
                        (low >>> numBits) | (high << (32 - numBits)),
                        high >> numBits);
                } else {
                    return Long.fromBits(
                        high >> (numBits - 32),
                        high >= 0 ? 0 : -1);
                }
            }
        };

        /**
         * Returns this Long with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
         *
         * @param {Number} numBits the number of bits by which to shift.
         * @return {Long} this shifted to the right by the given amount, with zeros placed into the new leading bits.
         * @api public
         */
        Long.prototype.shiftRightUnsigned = function(numBits) {
            numBits &= 63;
            if (numBits == 0) {
                return this;
            } else {
                var high = this.high_;
                if (numBits < 32) {
                    var low = this.low_;
                    return Long.fromBits(
                        (low >>> numBits) | (high << (32 - numBits)),
                        high >>> numBits);
                } else if (numBits == 32) {
                    return Long.fromBits(high, 0);
                } else {
                    return Long.fromBits(high >>> (numBits - 32), 0);
                }
            }
        };

        /**
         * Returns a Long representing the given (32-bit) integer value.
         *
         * @param {Number} value the 32-bit integer in question.
         * @return {Long} the corresponding Long value.
         * @api public
         */
        Long.fromInt = function(value) {
            if (-128 <= value && value < 128) {
                var cachedObj = Long.INT_CACHE_[value];
                if (cachedObj) {
                    return cachedObj;
                }
            }

            var obj = new Long(value | 0, value < 0 ? -1 : 0);
            if (-128 <= value && value < 128) {
                Long.INT_CACHE_[value] = obj;
            }
            return obj;
        };

        /**
         * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
         *
         * @param {Number} value the number in question.
         * @return {Long} the corresponding Long value.
         * @api public
         */
        Long.fromNumber = function(value) {
            if (isNaN(value) || !isFinite(value)) {
                return Long.ZERO;
            } else if (value <= -Long.TWO_PWR_63_DBL_) {
                return Long.MIN_VALUE;
            } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
                return Long.MAX_VALUE;
            } else if (value < 0) {
                return Long.fromNumber(-value).negate();
            } else {
                return new Long(
                    (value % Long.TWO_PWR_32_DBL_) | 0, (value / Long.TWO_PWR_32_DBL_) | 0);
            }
        };

        /**
         * Returns a Long representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
         *
         * @param {Number} lowBits the low 32-bits.
         * @param {Number} highBits the high 32-bits.
         * @return {Long} the corresponding Long value.
         * @api public
         */
        Long.fromBits = function(lowBits, highBits) {
            return new Long(lowBits, highBits);
        };

        /**
         * Returns a Long representation of the given string, written using the given radix.
         *
         * @param {String} str the textual representation of the Long.
         * @param {Number} opt_radix the radix in which the text is written.
         * @return {Long} the corresponding Long value.
         * @api public
         */
        Long.fromString = function(str, opt_radix) {
            if (str.length == 0) {
                throw Error('number format error: empty string');
            }

            var radix = opt_radix || 10;
            if (radix < 2 || 36 < radix) {
                throw Error('radix out of range: ' + radix);
            }

            if (str.charAt(0) == '-') {
                return Long.fromString(str.substring(1), radix).negate();
            } else if (str.indexOf('-') >= 0) {
                throw Error('number format error: interior "-" character: ' + str);
            }

            // Do several (8) digits each time through the loop, so as to
            // minimize the calls to the very expensive emulated div.
            var radixToPower = Long.fromNumber(Math.pow(radix, 8));

            var result = Long.ZERO;
            for (var i = 0; i < str.length; i += 8) {
                var size = Math.min(8, str.length - i);
                var value = parseInt(str.substring(i, i + size), radix);
                if (size < 8) {
                    var power = Long.fromNumber(Math.pow(radix, size));
                    result = result.multiply(power).add(Long.fromNumber(value));
                } else {
                    result = result.multiply(radixToPower);
                    result = result.add(Long.fromNumber(value));
                }
            }
            return result;
        };

        // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
        // from* methods on which they depend.


        /**
         * A cache of the Long representations of small integer values.
         * @type {Object}
         * @api private
         */
        Long.INT_CACHE_ = {};

        // NOTE: the compiler should inline these constant values below and then remove
        // these variables, so there should be no runtime penalty for these.

        /**
         * Number used repeated below in calculations.  This must appear before the
         * first call to any from* function below.
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_16_DBL_ = 1 << 16;

        /**
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_24_DBL_ = 1 << 24;

        /**
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;

        /**
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;

        /**
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;

        /**
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;

        /**
         * @type {number}
         * @api private
         */
        Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

        /** @type {Long} */
        Long.ZERO = Long.fromInt(0);

        /** @type {Long} */
        Long.ONE = Long.fromInt(1);

        /** @type {Long} */
        Long.NEG_ONE = Long.fromInt(-1);

        /** @type {Long} */
        Long.MAX_VALUE =
            Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);

        /** @type {Long} */
        Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

        /**
         * @type {Long}
         * @api private
         */
        Long.TWO_PWR_24_ = Long.fromInt(1 << 24);

        /**
         * Expose.
         */
        exports.Long = Long;

    },
    function(require, exports, module, global) {

        /**
         * A class representation of the BSON Double type.
         *
         * @class Represents the BSON Double type.
         * @param {Number} value the number we want to represent as a double.
         * @return {Double}
         */
        function Double(value) {
            if (!(this instanceof Double)) return new Double(value);

            this._bsontype = 'Double';
            this.value = value;
        }

        /**
         * Access the number value.
         *
         * @return {Number} returns the wrapped double number.
         * @api public
         */
        Double.prototype.valueOf = function() {
            return this.value;
        };

        /**
         * @ignore
         * @api private
         */
        Double.prototype.toJSON = function() {
            return this.value;
        }

        exports.Double = Double;

    },
    function(require, exports, module, global) {

        // Licensed under the Apache License, Version 2.0 (the "License");
        // you may not use this file except in compliance with the License.
        // You may obtain a copy of the License at
        //
        //     http://www.apache.org/licenses/LICENSE-2.0
        //
        // Unless required by applicable law or agreed to in writing, software
        // distributed under the License is distributed on an "AS IS" BASIS,
        // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        // See the License for the specific language governing permissions and
        // limitations under the License.
        //
        // Copyright 2009 Google Inc. All Rights Reserved

        /**
         * Defines a Timestamp class for representing a 64-bit two's-complement
         * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
         * implementation is derived from TimestampLib in GWT.
         *
         * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
         * values as *signed* integers.  See the from* functions below for more
         * convenient ways of constructing Timestamps.
         *
         * The internal representation of a Timestamp is the two given signed, 32-bit values.
         * We use 32-bit pieces because these are the size of integers on which
         * Javascript performs bit-operations.  For operations like addition and
         * multiplication, we split each number into 16-bit pieces, which can easily be
         * multiplied within Javascript's floating-point representation without overflow
         * or change in sign.
         *
         * In the algorithms below, we frequently reduce the negative case to the
         * positive case by negating the input(s) and then post-processing the result.
         * Note that we must ALWAYS check specially whether those values are MIN_VALUE
         * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
         * a positive number, it overflows back into a negative).  Not handling this
         * case would often result in infinite recursion.
         *
         * @class Represents the BSON Timestamp type.
         * @param {Number} low  the low (signed) 32 bits of the Timestamp.
         * @param {Number} high the high (signed) 32 bits of the Timestamp.
         */
        function Timestamp(low, high) {
            if (!(this instanceof Timestamp)) return new Timestamp(low, high);
            this._bsontype = 'Timestamp';
            /**
             * @type {number}
             * @api private
             */
            this.low_ = low | 0; // force into 32 signed bits.

            /**
             * @type {number}
             * @api private
             */
            this.high_ = high | 0; // force into 32 signed bits.
        };

        /**
         * Return the int value.
         *
         * @return {Number} the value, assuming it is a 32-bit integer.
         * @api public
         */
        Timestamp.prototype.toInt = function() {
            return this.low_;
        };

        /**
         * Return the Number value.
         *
         * @return {Number} the closest floating-point representation to this value.
         * @api public
         */
        Timestamp.prototype.toNumber = function() {
            return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
                this.getLowBitsUnsigned();
        };

        /**
         * Return the JSON value.
         *
         * @return {String} the JSON representation.
         * @api public
         */
        Timestamp.prototype.toJSON = function() {
            return this.toString();
        }

        /**
         * Return the String value.
         *
         * @param {Number} [opt_radix] the radix in which the text should be written.
         * @return {String} the textual representation of this value.
         * @api public
         */
        Timestamp.prototype.toString = function(opt_radix) {
            var radix = opt_radix || 10;
            if (radix < 2 || 36 < radix) {
                throw Error('radix out of range: ' + radix);
            }

            if (this.isZero()) {
                return '0';
            }

            if (this.isNegative()) {
                if (this.equals(Timestamp.MIN_VALUE)) {
                    // We need to change the Timestamp value before it can be negated, so we remove
                    // the bottom-most digit in this base and then recurse to do the rest.
                    var radixTimestamp = Timestamp.fromNumber(radix);
                    var div = this.div(radixTimestamp);
                    var rem = div.multiply(radixTimestamp).subtract(this);
                    return div.toString(radix) + rem.toInt().toString(radix);
                } else {
                    return '-' + this.negate().toString(radix);
                }
            }

            // Do several (6) digits each time through the loop, so as to
            // minimize the calls to the very expensive emulated div.
            var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));

            var rem = this;
            var result = '';
            while (true) {
                var remDiv = rem.div(radixToPower);
                var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
                var digits = intval.toString(radix);

                rem = remDiv;
                if (rem.isZero()) {
                    return digits + result;
                } else {
                    while (digits.length < 6) {
                        digits = '0' + digits;
                    }
                    result = '' + digits + result;
                }
            }
        };

        /**
         * Return the high 32-bits value.
         *
         * @return {Number} the high 32-bits as a signed value.
         * @api public
         */
        Timestamp.prototype.getHighBits = function() {
            return this.high_;
        };

        /**
         * Return the low 32-bits value.
         *
         * @return {Number} the low 32-bits as a signed value.
         * @api public
         */
        Timestamp.prototype.getLowBits = function() {
            return this.low_;
        };

        /**
         * Return the low unsigned 32-bits value.
         *
         * @return {Number} the low 32-bits as an unsigned value.
         * @api public
         */
        Timestamp.prototype.getLowBitsUnsigned = function() {
            return (this.low_ >= 0) ?
                this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
        };

        /**
         * Returns the number of bits needed to represent the absolute value of this Timestamp.
         *
         * @return {Number} Returns the number of bits needed to represent the absolute value of this Timestamp.
         * @api public
         */
        Timestamp.prototype.getNumBitsAbs = function() {
            if (this.isNegative()) {
                if (this.equals(Timestamp.MIN_VALUE)) {
                    return 64;
                } else {
                    return this.negate().getNumBitsAbs();
                }
            } else {
                var val = this.high_ != 0 ? this.high_ : this.low_;
                for (var bit = 31; bit > 0; bit--) {
                    if ((val & (1 << bit)) != 0) {
                        break;
                    }
                }
                return this.high_ != 0 ? bit + 33 : bit + 1;
            }
        };

        /**
         * Return whether this value is zero.
         *
         * @return {Boolean} whether this value is zero.
         * @api public
         */
        Timestamp.prototype.isZero = function() {
            return this.high_ == 0 && this.low_ == 0;
        };

        /**
         * Return whether this value is negative.
         *
         * @return {Boolean} whether this value is negative.
         * @api public
         */
        Timestamp.prototype.isNegative = function() {
            return this.high_ < 0;
        };

        /**
         * Return whether this value is odd.
         *
         * @return {Boolean} whether this value is odd.
         * @api public
         */
        Timestamp.prototype.isOdd = function() {
            return (this.low_ & 1) == 1;
        };

        /**
         * Return whether this Timestamp equals the other
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} whether this Timestamp equals the other
         * @api public
         */
        Timestamp.prototype.equals = function(other) {
            return (this.high_ == other.high_) && (this.low_ == other.low_);
        };

        /**
         * Return whether this Timestamp does not equal the other.
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} whether this Timestamp does not equal the other.
         * @api public
         */
        Timestamp.prototype.notEquals = function(other) {
            return (this.high_ != other.high_) || (this.low_ != other.low_);
        };

        /**
         * Return whether this Timestamp is less than the other.
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} whether this Timestamp is less than the other.
         * @api public
         */
        Timestamp.prototype.lessThan = function(other) {
            return this.compare(other) < 0;
        };

        /**
         * Return whether this Timestamp is less than or equal to the other.
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} whether this Timestamp is less than or equal to the other.
         * @api public
         */
        Timestamp.prototype.lessThanOrEqual = function(other) {
            return this.compare(other) <= 0;
        };

        /**
         * Return whether this Timestamp is greater than the other.
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} whether this Timestamp is greater than the other.
         * @api public
         */
        Timestamp.prototype.greaterThan = function(other) {
            return this.compare(other) > 0;
        };

        /**
         * Return whether this Timestamp is greater than or equal to the other.
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} whether this Timestamp is greater than or equal to the other.
         * @api public
         */
        Timestamp.prototype.greaterThanOrEqual = function(other) {
            return this.compare(other) >= 0;
        };

        /**
         * Compares this Timestamp with the given one.
         *
         * @param {Timestamp} other Timestamp to compare against.
         * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
         * @api public
         */
        Timestamp.prototype.compare = function(other) {
            if (this.equals(other)) {
                return 0;
            }

            var thisNeg = this.isNegative();
            var otherNeg = other.isNegative();
            if (thisNeg && !otherNeg) {
                return -1;
            }
            if (!thisNeg && otherNeg) {
                return 1;
            }

            // at this point, the signs are the same, so subtraction will not overflow
            if (this.subtract(other).isNegative()) {
                return -1;
            } else {
                return 1;
            }
        };

        /**
         * The negation of this value.
         *
         * @return {Timestamp} the negation of this value.
         * @api public
         */
        Timestamp.prototype.negate = function() {
            if (this.equals(Timestamp.MIN_VALUE)) {
                return Timestamp.MIN_VALUE;
            } else {
                return this.not().add(Timestamp.ONE);
            }
        };

        /**
         * Returns the sum of this and the given Timestamp.
         *
         * @param {Timestamp} other Timestamp to add to this one.
         * @return {Timestamp} the sum of this and the given Timestamp.
         * @api public
         */
        Timestamp.prototype.add = function(other) {
            // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

            var a48 = this.high_ >>> 16;
            var a32 = this.high_ & 0xFFFF;
            var a16 = this.low_ >>> 16;
            var a00 = this.low_ & 0xFFFF;

            var b48 = other.high_ >>> 16;
            var b32 = other.high_ & 0xFFFF;
            var b16 = other.low_ >>> 16;
            var b00 = other.low_ & 0xFFFF;

            var c48 = 0,
                c32 = 0,
                c16 = 0,
                c00 = 0;
            c00 += a00 + b00;
            c16 += c00 >>> 16;
            c00 &= 0xFFFF;
            c16 += a16 + b16;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c32 += a32 + b32;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c48 += a48 + b48;
            c48 &= 0xFFFF;
            return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
        };

        /**
         * Returns the difference of this and the given Timestamp.
         *
         * @param {Timestamp} other Timestamp to subtract from this.
         * @return {Timestamp} the difference of this and the given Timestamp.
         * @api public
         */
        Timestamp.prototype.subtract = function(other) {
            return this.add(other.negate());
        };

        /**
         * Returns the product of this and the given Timestamp.
         *
         * @param {Timestamp} other Timestamp to multiply with this.
         * @return {Timestamp} the product of this and the other.
         * @api public
         */
        Timestamp.prototype.multiply = function(other) {
            if (this.isZero()) {
                return Timestamp.ZERO;
            } else if (other.isZero()) {
                return Timestamp.ZERO;
            }

            if (this.equals(Timestamp.MIN_VALUE)) {
                return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
            } else if (other.equals(Timestamp.MIN_VALUE)) {
                return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
            }

            if (this.isNegative()) {
                if (other.isNegative()) {
                    return this.negate().multiply(other.negate());
                } else {
                    return this.negate().multiply(other).negate();
                }
            } else if (other.isNegative()) {
                return this.multiply(other.negate()).negate();
            }

            // If both Timestamps are small, use float multiplication
            if (this.lessThan(Timestamp.TWO_PWR_24_) &&
                other.lessThan(Timestamp.TWO_PWR_24_)) {
                return Timestamp.fromNumber(this.toNumber() * other.toNumber());
            }

            // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
            // We can skip products that would overflow.

            var a48 = this.high_ >>> 16;
            var a32 = this.high_ & 0xFFFF;
            var a16 = this.low_ >>> 16;
            var a00 = this.low_ & 0xFFFF;

            var b48 = other.high_ >>> 16;
            var b32 = other.high_ & 0xFFFF;
            var b16 = other.low_ >>> 16;
            var b00 = other.low_ & 0xFFFF;

            var c48 = 0,
                c32 = 0,
                c16 = 0,
                c00 = 0;
            c00 += a00 * b00;
            c16 += c00 >>> 16;
            c00 &= 0xFFFF;
            c16 += a16 * b00;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c16 += a00 * b16;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c32 += a32 * b00;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c32 += a16 * b16;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c32 += a00 * b32;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
            c48 &= 0xFFFF;
            return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
        };

        /**
         * Returns this Timestamp divided by the given one.
         *
         * @param {Timestamp} other Timestamp by which to divide.
         * @return {Timestamp} this Timestamp divided by the given one.
         * @api public
         */
        Timestamp.prototype.div = function(other) {
            if (other.isZero()) {
                throw Error('division by zero');
            } else if (this.isZero()) {
                return Timestamp.ZERO;
            }

            if (this.equals(Timestamp.MIN_VALUE)) {
                if (other.equals(Timestamp.ONE) ||
                    other.equals(Timestamp.NEG_ONE)) {
                    return Timestamp.MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                } else if (other.equals(Timestamp.MIN_VALUE)) {
                    return Timestamp.ONE;
                } else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shiftRight(1);
                    var approx = halfThis.div(other).shiftLeft(1);
                    if (approx.equals(Timestamp.ZERO)) {
                        return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
                    } else {
                        var rem = this.subtract(other.multiply(approx));
                        var result = approx.add(rem.div(other));
                        return result;
                    }
                }
            } else if (other.equals(Timestamp.MIN_VALUE)) {
                return Timestamp.ZERO;
            }

            if (this.isNegative()) {
                if (other.isNegative()) {
                    return this.negate().div(other.negate());
                } else {
                    return this.negate().div(other).negate();
                }
            } else if (other.isNegative()) {
                return this.div(other.negate()).negate();
            }

            // Repeat the following until the remainder is less than other:  find a
            // floating-point that approximates remainder / other *from below*, add this
            // into the result, and subtract it from the remainder.  It is critical that
            // the approximate value is less than or equal to the real value so that the
            // remainder never becomes negative.
            var res = Timestamp.ZERO;
            var rem = this;
            while (rem.greaterThanOrEqual(other)) {
                // Approximate the result of division. This may be a little greater or
                // smaller than the actual value.
                var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

                // We will tweak the approximate result by changing it in the 48-th digit or
                // the smallest non-fractional digit, whichever is larger.
                var log2 = Math.ceil(Math.log(approx) / Math.LN2);
                var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

                // Decrease the approximation until it is smaller than the remainder.  Note
                // that if it is too large, the product overflows and is negative.
                var approxRes = Timestamp.fromNumber(approx);
                var approxRem = approxRes.multiply(other);
                while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                    approx -= delta;
                    approxRes = Timestamp.fromNumber(approx);
                    approxRem = approxRes.multiply(other);
                }

                // We know the answer can't be zero... and actually, zero would cause
                // infinite recursion since we would make no progress.
                if (approxRes.isZero()) {
                    approxRes = Timestamp.ONE;
                }

                res = res.add(approxRes);
                rem = rem.subtract(approxRem);
            }
            return res;
        };

        /**
         * Returns this Timestamp modulo the given one.
         *
         * @param {Timestamp} other Timestamp by which to mod.
         * @return {Timestamp} this Timestamp modulo the given one.
         * @api public
         */
        Timestamp.prototype.modulo = function(other) {
            return this.subtract(this.div(other).multiply(other));
        };

        /**
         * The bitwise-NOT of this value.
         *
         * @return {Timestamp} the bitwise-NOT of this value.
         * @api public
         */
        Timestamp.prototype.not = function() {
            return Timestamp.fromBits(~this.low_, ~this.high_);
        };

        /**
         * Returns the bitwise-AND of this Timestamp and the given one.
         *
         * @param {Timestamp} other the Timestamp with which to AND.
         * @return {Timestamp} the bitwise-AND of this and the other.
         * @api public
         */
        Timestamp.prototype.and = function(other) {
            return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_);
        };

        /**
         * Returns the bitwise-OR of this Timestamp and the given one.
         *
         * @param {Timestamp} other the Timestamp with which to OR.
         * @return {Timestamp} the bitwise-OR of this and the other.
         * @api public
         */
        Timestamp.prototype.or = function(other) {
            return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
        };

        /**
         * Returns the bitwise-XOR of this Timestamp and the given one.
         *
         * @param {Timestamp} other the Timestamp with which to XOR.
         * @return {Timestamp} the bitwise-XOR of this and the other.
         * @api public
         */
        Timestamp.prototype.xor = function(other) {
            return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
        };

        /**
         * Returns this Timestamp with bits shifted to the left by the given amount.
         *
         * @param {Number} numBits the number of bits by which to shift.
         * @return {Timestamp} this shifted to the left by the given amount.
         * @api public
         */
        Timestamp.prototype.shiftLeft = function(numBits) {
            numBits &= 63;
            if (numBits == 0) {
                return this;
            } else {
                var low = this.low_;
                if (numBits < 32) {
                    var high = this.high_;
                    return Timestamp.fromBits(
                        low << numBits, (high << numBits) | (low >>> (32 - numBits)));
                } else {
                    return Timestamp.fromBits(0, low << (numBits - 32));
                }
            }
        };

        /**
         * Returns this Timestamp with bits shifted to the right by the given amount.
         *
         * @param {Number} numBits the number of bits by which to shift.
         * @return {Timestamp} this shifted to the right by the given amount.
         * @api public
         */
        Timestamp.prototype.shiftRight = function(numBits) {
            numBits &= 63;
            if (numBits == 0) {
                return this;
            } else {
                var high = this.high_;
                if (numBits < 32) {
                    var low = this.low_;
                    return Timestamp.fromBits(
                        (low >>> numBits) | (high << (32 - numBits)),
                        high >> numBits);
                } else {
                    return Timestamp.fromBits(
                        high >> (numBits - 32),
                        high >= 0 ? 0 : -1);
                }
            }
        };

        /**
         * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
         *
         * @param {Number} numBits the number of bits by which to shift.
         * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
         * @api public
         */
        Timestamp.prototype.shiftRightUnsigned = function(numBits) {
            numBits &= 63;
            if (numBits == 0) {
                return this;
            } else {
                var high = this.high_;
                if (numBits < 32) {
                    var low = this.low_;
                    return Timestamp.fromBits(
                        (low >>> numBits) | (high << (32 - numBits)),
                        high >>> numBits);
                } else if (numBits == 32) {
                    return Timestamp.fromBits(high, 0);
                } else {
                    return Timestamp.fromBits(high >>> (numBits - 32), 0);
                }
            }
        };

        /**
         * Returns a Timestamp representing the given (32-bit) integer value.
         *
         * @param {Number} value the 32-bit integer in question.
         * @return {Timestamp} the corresponding Timestamp value.
         * @api public
         */
        Timestamp.fromInt = function(value) {
            if (-128 <= value && value < 128) {
                var cachedObj = Timestamp.INT_CACHE_[value];
                if (cachedObj) {
                    return cachedObj;
                }
            }

            var obj = new Timestamp(value | 0, value < 0 ? -1 : 0);
            if (-128 <= value && value < 128) {
                Timestamp.INT_CACHE_[value] = obj;
            }
            return obj;
        };

        /**
         * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
         *
         * @param {Number} value the number in question.
         * @return {Timestamp} the corresponding Timestamp value.
         * @api public
         */
        Timestamp.fromNumber = function(value) {
            if (isNaN(value) || !isFinite(value)) {
                return Timestamp.ZERO;
            } else if (value <= -Timestamp.TWO_PWR_63_DBL_) {
                return Timestamp.MIN_VALUE;
            } else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_) {
                return Timestamp.MAX_VALUE;
            } else if (value < 0) {
                return Timestamp.fromNumber(-value).negate();
            } else {
                return new Timestamp(
                    (value % Timestamp.TWO_PWR_32_DBL_) | 0, (value / Timestamp.TWO_PWR_32_DBL_) | 0);
            }
        };

        /**
         * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
         *
         * @param {Number} lowBits the low 32-bits.
         * @param {Number} highBits the high 32-bits.
         * @return {Timestamp} the corresponding Timestamp value.
         * @api public
         */
        Timestamp.fromBits = function(lowBits, highBits) {
            return new Timestamp(lowBits, highBits);
        };

        /**
         * Returns a Timestamp representation of the given string, written using the given radix.
         *
         * @param {String} str the textual representation of the Timestamp.
         * @param {Number} opt_radix the radix in which the text is written.
         * @return {Timestamp} the corresponding Timestamp value.
         * @api public
         */
        Timestamp.fromString = function(str, opt_radix) {
            if (str.length == 0) {
                throw Error('number format error: empty string');
            }

            var radix = opt_radix || 10;
            if (radix < 2 || 36 < radix) {
                throw Error('radix out of range: ' + radix);
            }

            if (str.charAt(0) == '-') {
                return Timestamp.fromString(str.substring(1), radix).negate();
            } else if (str.indexOf('-') >= 0) {
                throw Error('number format error: interior "-" character: ' + str);
            }

            // Do several (8) digits each time through the loop, so as to
            // minimize the calls to the very expensive emulated div.
            var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));

            var result = Timestamp.ZERO;
            for (var i = 0; i < str.length; i += 8) {
                var size = Math.min(8, str.length - i);
                var value = parseInt(str.substring(i, i + size), radix);
                if (size < 8) {
                    var power = Timestamp.fromNumber(Math.pow(radix, size));
                    result = result.multiply(power).add(Timestamp.fromNumber(value));
                } else {
                    result = result.multiply(radixToPower);
                    result = result.add(Timestamp.fromNumber(value));
                }
            }
            return result;
        };

        // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
        // from* methods on which they depend.


        /**
         * A cache of the Timestamp representations of small integer values.
         * @type {Object}
         * @api private
         */
        Timestamp.INT_CACHE_ = {};

        // NOTE: the compiler should inline these constant values below and then remove
        // these variables, so there should be no runtime penalty for these.

        /**
         * Number used repeated below in calculations.  This must appear before the
         * first call to any from* function below.
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_16_DBL_ = 1 << 16;

        /**
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_24_DBL_ = 1 << 24;

        /**
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;

        /**
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;

        /**
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;

        /**
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;

        /**
         * @type {number}
         * @api private
         */
        Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;

        /** @type {Timestamp} */
        Timestamp.ZERO = Timestamp.fromInt(0);

        /** @type {Timestamp} */
        Timestamp.ONE = Timestamp.fromInt(1);

        /** @type {Timestamp} */
        Timestamp.NEG_ONE = Timestamp.fromInt(-1);

        /** @type {Timestamp} */
        Timestamp.MAX_VALUE =
            Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);

        /** @type {Timestamp} */
        Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0);

        /**
         * @type {Timestamp}
         * @api private
         */
        Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24);

        /**
         * Expose.
         */
        exports.Timestamp = Timestamp;

    },
    function(require, exports, module, global) {

        var process = require(1);
        /**
         * Module dependencies.
         */
        var BinaryParser = require(78).BinaryParser;

        /**
         * Machine id.
         *
         * Create a random 3-byte value (i.e. unique for this
         * process). Other drivers use a md5 of the machine id here, but
         * that would mean an asyc call to gethostname, so we don't bother.
         */
        var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);

        // Regular expression that checks for hex value
        var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");

        /**
         * Create a new ObjectID instance
         *
         * @class Represents the BSON ObjectID type
         * @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.
         * @return {Object} instance of ObjectID.
         */
        var ObjectID = function ObjectID(id) {
            if (!(this instanceof ObjectID)) return new ObjectID(id);
            if ((id instanceof ObjectID)) return id;

            this._bsontype = 'ObjectID';
            var __id = null;
            var valid = ObjectID.isValid(id);

            // Throw an error if it's not a valid setup
            if (!valid && id != null) {
                throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
            } else if (valid && typeof id == 'string' && id.length == 24) {
                return ObjectID.createFromHexString(id);
            } else if (id == null || typeof id == 'number') {
                // convert to 12 byte binary string
                this.id = this.generate(id);
            } else if (id != null && id.length === 12) {
                // assume 12 byte string
                this.id = id;
            }

            if (ObjectID.cacheHexString) this.__id = this.toHexString();
        };

        // Allow usage of ObjectId as well as ObjectID
        var ObjectId = ObjectID;

        // Precomputed hex table enables speedy hex string conversion
        var hexTable = [];
        for (var i = 0; i < 256; i++) {
            hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
        }

        /**
         * Return the ObjectID id as a 24 byte hex string representation
         *
         * @return {String} return the 24 byte hex string representation.
         * @api public
         */
        ObjectID.prototype.toHexString = function() {
            if (ObjectID.cacheHexString && this.__id) return this.__id;

            var hexString = '';

            for (var i = 0; i < this.id.length; i++) {
                hexString += hexTable[this.id.charCodeAt(i)];
            }

            if (ObjectID.cacheHexString) this.__id = hexString;
            return hexString;
        };

        /**
         * Update the ObjectID index used in generating new ObjectID's on the driver
         *
         * @return {Number} returns next index value.
         * @api private
         */
        ObjectID.prototype.get_inc = function() {
            return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
        };

        /**
         * Update the ObjectID index used in generating new ObjectID's on the driver
         *
         * @return {Number} returns next index value.
         * @api private
         */
        ObjectID.prototype.getInc = function() {
            return this.get_inc();
        };

        /**
         * Generate a 12 byte id string used in ObjectID's
         *
         * @param {Number} [time] optional parameter allowing to pass in a second based timestamp.
         * @return {String} return the 12 byte id binary string.
         * @api private
         */
        ObjectID.prototype.generate = function(time) {
            if ('number' != typeof time) {
                time = parseInt(Date.now() / 1000, 10);
            }

            var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);
            /* for time-based ObjectID the bytes following the time will be zeroed */
            var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
            var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid);
            var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);

            return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
        };

        /**
         * Converts the id into a 24 byte hex string for printing
         *
         * @return {String} return the 24 byte hex string representation.
         * @api private
         */
        ObjectID.prototype.toString = function() {
            return this.toHexString();
        };

        /**
         * Converts to a string representation of this Id.
         *
         * @return {String} return the 24 byte hex string representation.
         * @api private
         */
        ObjectID.prototype.inspect = ObjectID.prototype.toString;

        /**
         * Converts to its JSON representation.
         *
         * @return {String} return the 24 byte hex string representation.
         * @api private
         */
        ObjectID.prototype.toJSON = function() {
            return this.toHexString();
        };

        /**
         * Compares the equality of this ObjectID with `otherID`.
         *
         * @param {Object} otherID ObjectID instance to compare against.
         * @return {Bool} the result of comparing two ObjectID's
         * @api public
         */
        ObjectID.prototype.equals = function equals(otherID) {
            if (otherID == null) return false;
            var id = (otherID instanceof ObjectID || otherID.toHexString) ? otherID.id : ObjectID.createFromHexString(otherID).id;

            return this.id === id;
        }

        /**
         * Returns the generation date (accurate up to the second) that this ID was generated.
         *
         * @return {Date} the generation date
         * @api public
         */
        ObjectID.prototype.getTimestamp = function() {
            var timestamp = new Date();
            timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0, 4), 32, true, true)) * 1000);
            return timestamp;
        }

        /**
         * @ignore
         * @api private
         */
        ObjectID.index = parseInt(Math.random() * 0xFFFFFF, 10);

        ObjectID.createPk = function createPk() {
            return new ObjectID();
        };

        /**
         * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
         *
         * @param {Number} time an integer number representing a number of seconds.
         * @return {ObjectID} return the created ObjectID
         * @api public
         */
        ObjectID.createFromTime = function createFromTime(time) {
            var id = BinaryParser.encodeInt(time, 32, true, true) +
                BinaryParser.encodeInt(0, 64, true, true);
            return new ObjectID(id);
        };

        /**
         * Creates an ObjectID from a hex string representation of an ObjectID.
         *
         * @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.
         * @return {ObjectID} return the created ObjectID
         * @api public
         */
        ObjectID.createFromHexString = function createFromHexString(hexString) {
            // Throw an error if it's not a valid setup
            if (typeof hexString === 'undefined' || hexString != null && hexString.length != 24)
                throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

            var len = hexString.length;

            if (len > 12 * 2) {
                throw new Error('Id cannot be longer than 12 bytes');
            }

            var result = '',
                string, number;

            for (var index = 0; index < len; index += 2) {
                string = hexString.substr(index, 2);
                number = parseInt(string, 16);
                result += BinaryParser.fromByte(number);
            }

            return new ObjectID(result, hexString);
        };

        /**
         * Checks if a value is a valid bson ObjectId
         *
         * @return {Boolean} return true if the value is a valid bson ObjectId, return false otherwise.
         * @api public
         */
        ObjectID.isValid = function isValid(id) {
            if (id == null) return false;

            if (id != null && 'number' != typeof id && (id.length != 12 && id.length != 24)) {
                return false;
            } else {
                // Check specifically for hex correctness
                if (typeof id == 'string' && id.length == 24) return checkForHexRegExp.test(id);
                return true;
            }
        };

        /**
         * @ignore
         */
        Object.defineProperty(ObjectID.prototype, "generationTime", {
            enumerable: true,
            get: function() {
                return Math.floor(BinaryParser.decodeInt(this.id.substring(0, 4), 32, true, true));
            },
            set: function(value) {
                var value = BinaryParser.encodeInt(value, 32, true, true);
                this.id = value + this.id.substr(4);
                // delete this.__id;
                this.toHexString();
            }
        });

        /**
         * Expose.
         */
        exports.ObjectID = ObjectID;
        exports.ObjectId = ObjectID;


    },
    function(require, exports, module, global) {

        var Buffer = require(45).Buffer;
        var process = require(1);
        /**
         * Binary Parser.
         * Jonas Raoni Soares Silva
         * http://jsfromhell.com/classes/binary-parser [v1.0]
         */
        var chr = String.fromCharCode;

        var maxBits = [];
        for (var i = 0; i < 64; i++) {
            maxBits[i] = Math.pow(2, i);
        }

        function BinaryParser(bigEndian, allowExceptions) {
            if (!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);

            this.bigEndian = bigEndian;
            this.allowExceptions = allowExceptions;
        };

        BinaryParser.warn = function warn(msg) {
            if (this.allowExceptions) {
                throw new Error(msg);
            }

            return 1;
        };

        BinaryParser.decodeFloat = function decodeFloat(data, precisionBits, exponentBits) {
            var b = new this.Buffer(this.bigEndian, data);

            b.checkBuffer(precisionBits + exponentBits + 1);

            var bias = maxBits[exponentBits - 1] - 1,
                signal = b.readBits(precisionBits + exponentBits, 1),
                exponent = b.readBits(precisionBits, exponentBits),
                significand = 0,
                divisor = 2,
                curByte = b.buffer.length + (-precisionBits >> 3) - 1;

            do {
                for (var byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1;
                    (byteValue & mask) && (significand += 1 / divisor), divisor *= 2);
            } while (precisionBits -= startBit);

            return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
        };

        BinaryParser.decodeInt = function decodeInt(data, bits, signed, forceBigEndian) {
            var b = new this.Buffer(this.bigEndian || forceBigEndian, data),
                x = b.readBits(0, bits),
                max = maxBits[bits]; //max = Math.pow( 2, bits );

            return signed && x >= max / 2 ? x - max : x;
        };

        BinaryParser.encodeFloat = function encodeFloat(data, precisionBits, exponentBits) {
            var bias = maxBits[exponentBits - 1] - 1,
                minExp = -bias + 1,
                maxExp = bias,
                minUnnormExp = minExp - precisionBits,
                n = parseFloat(data),
                status = isNaN(n) || n == -Infinity || n == +Infinity ? n : 0,
                exp = 0,
                len = 2 * bias + 1 + precisionBits + 3,
                bin = new Array(len),
                signal = (n = status !== 0 ? 0 : n) < 0,
                intPart = Math.floor(n = Math.abs(n)),
                floatPart = n - intPart,
                lastBit, rounded, result, i, j;

            for (i = len; i; bin[--i] = 0);

            for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));

            for (i = bias + 1; floatPart > 0 && i;
                (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart);

            for (i = -1; ++i < len && !bin[i];);

            if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
                if (!(rounded = bin[lastBit])) {
                    for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
                }

                for (j = lastBit + 1; rounded && --j >= 0;
                    (bin[j] = !bin[j] - 0) && (rounded = 0));
            }

            for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);

            if ((exp = bias + 1 - i) >= minExp && exp <= maxExp) {
                ++i;
            } else if (exp < minExp) {
                exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow");
                i = bias + 1 - (exp = minExp - 1);
            }

            if (intPart || status !== 0) {
                this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status);
                exp = maxExp + 1;
                i = bias + 2;

                if (status == -Infinity) {
                    signal = 1;
                } else if (isNaN(status)) {
                    bin[i] = 1;
                }
            }

            for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);

            for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; j = (j + 1) % 8) {
                n += (1 << j) * result.charAt(--i);
                if (j == 7) {
                    r[r.length] = String.fromCharCode(n);
                    n = 0;
                }
            }

            r[r.length] = n ? String.fromCharCode(n) : "";

            return (this.bigEndian ? r.reverse() : r).join("");
        };

        BinaryParser.encodeInt = function encodeInt(data, bits, signed, forceBigEndian) {
            var max = maxBits[bits];

            if (data >= max || data < -(max / 2)) {
                this.warn("encodeInt::overflow");
                data = 0;
            }

            if (data < 0) {
                data += max;
            }

            for (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));

            for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");

            return ((this.bigEndian || forceBigEndian) ? r.reverse() : r).join("");
        };

        BinaryParser.toSmall = function(data) {
            return this.decodeInt(data, 8, true);
        };
        BinaryParser.fromSmall = function(data) {
            return this.encodeInt(data, 8, true);
        };
        BinaryParser.toByte = function(data) {
            return this.decodeInt(data, 8, false);
        };
        BinaryParser.fromByte = function(data) {
            return this.encodeInt(data, 8, false);
        };
        BinaryParser.toShort = function(data) {
            return this.decodeInt(data, 16, true);
        };
        BinaryParser.fromShort = function(data) {
            return this.encodeInt(data, 16, true);
        };
        BinaryParser.toWord = function(data) {
            return this.decodeInt(data, 16, false);
        };
        BinaryParser.fromWord = function(data) {
            return this.encodeInt(data, 16, false);
        };
        BinaryParser.toInt = function(data) {
            return this.decodeInt(data, 32, true);
        };
        BinaryParser.fromInt = function(data) {
            return this.encodeInt(data, 32, true);
        };
        BinaryParser.toLong = function(data) {
            return this.decodeInt(data, 64, true);
        };
        BinaryParser.fromLong = function(data) {
            return this.encodeInt(data, 64, true);
        };
        BinaryParser.toDWord = function(data) {
            return this.decodeInt(data, 32, false);
        };
        BinaryParser.fromDWord = function(data) {
            return this.encodeInt(data, 32, false);
        };
        BinaryParser.toQWord = function(data) {
            return this.decodeInt(data, 64, true);
        };
        BinaryParser.fromQWord = function(data) {
            return this.encodeInt(data, 64, true);
        };
        BinaryParser.toFloat = function(data) {
            return this.decodeFloat(data, 23, 8);
        };
        BinaryParser.fromFloat = function(data) {
            return this.encodeFloat(data, 23, 8);
        };
        BinaryParser.toDouble = function(data) {
            return this.decodeFloat(data, 52, 11);
        };
        BinaryParser.fromDouble = function(data) {
            return this.encodeFloat(data, 52, 11);
        };

        // Factor out the encode so it can be shared by add_header and push_int32
        BinaryParser.encode_int32 = function encode_int32(number, asArray) {
            var a, b, c, d, unsigned;
            unsigned = (number < 0) ? (number + 0x100000000) : number;
            a = Math.floor(unsigned / 0xffffff);
            unsigned &= 0xffffff;
            b = Math.floor(unsigned / 0xffff);
            unsigned &= 0xffff;
            c = Math.floor(unsigned / 0xff);
            unsigned &= 0xff;
            d = Math.floor(unsigned);
            return asArray ? [chr(a), chr(b), chr(c), chr(d)] : chr(a) + chr(b) + chr(c) + chr(d);
        };

        BinaryParser.encode_int64 = function encode_int64(number) {
            var a, b, c, d, e, f, g, h, unsigned;
            unsigned = (number < 0) ? (number + 0x10000000000000000) : number;
            a = Math.floor(unsigned / 0xffffffffffffff);
            unsigned &= 0xffffffffffffff;
            b = Math.floor(unsigned / 0xffffffffffff);
            unsigned &= 0xffffffffffff;
            c = Math.floor(unsigned / 0xffffffffff);
            unsigned &= 0xffffffffff;
            d = Math.floor(unsigned / 0xffffffff);
            unsigned &= 0xffffffff;
            e = Math.floor(unsigned / 0xffffff);
            unsigned &= 0xffffff;
            f = Math.floor(unsigned / 0xffff);
            unsigned &= 0xffff;
            g = Math.floor(unsigned / 0xff);
            unsigned &= 0xff;
            h = Math.floor(unsigned);
            return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);
        };

        /**
         * UTF8 methods
         */

        // Take a raw binary string and return a utf8 string
        BinaryParser.decode_utf8 = function decode_utf8(binaryStr) {
            var len = binaryStr.length,
                decoded = '',
                i = 0,
                c = 0,
                c1 = 0,
                c2 = 0,
                c3;

            while (i < len) {
                c = binaryStr.charCodeAt(i);
                if (c < 128) {
                    decoded += String.fromCharCode(c);
                    i++;
                } else if ((c > 191) && (c < 224)) {
                    c2 = binaryStr.charCodeAt(i + 1);
                    decoded += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                    i += 2;
                } else {
                    c2 = binaryStr.charCodeAt(i + 1);
                    c3 = binaryStr.charCodeAt(i + 2);
                    decoded += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                    i += 3;
                }
            }

            return decoded;
        };

        // Encode a cstring
        BinaryParser.encode_cstring = function encode_cstring(s) {
            return unescape(encodeURIComponent(s)) + BinaryParser.fromByte(0);
        };

        // Take a utf8 string and return a binary string
        BinaryParser.encode_utf8 = function encode_utf8(s) {
            var a = "",
                c;

            for (var n = 0, len = s.length; n < len; n++) {
                c = s.charCodeAt(n);

                if (c < 128) {
                    a += String.fromCharCode(c);
                } else if ((c > 127) && (c < 2048)) {
                    a += String.fromCharCode((c >> 6) | 192);
                    a += String.fromCharCode((c & 63) | 128);
                } else {
                    a += String.fromCharCode((c >> 12) | 224);
                    a += String.fromCharCode(((c >> 6) & 63) | 128);
                    a += String.fromCharCode((c & 63) | 128);
                }
            }

            return a;
        };

        BinaryParser.hprint = function hprint(s) {
            var number;

            for (var i = 0, len = s.length; i < len; i++) {
                if (s.charCodeAt(i) < 32) {
                    number = s.charCodeAt(i) <= 15 ? "0" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);
                    process.stdout.write(number + " ")
                } else {
                    number = s.charCodeAt(i) <= 15 ? "0" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);
                    process.stdout.write(number + " ")
                }
            }

            process.stdout.write("\n\n");
        };

        BinaryParser.ilprint = function hprint(s) {
            var number;

            for (var i = 0, len = s.length; i < len; i++) {
                if (s.charCodeAt(i) < 32) {
                    number = s.charCodeAt(i) <= 15 ? "0" + s.charCodeAt(i).toString(10) : s.charCodeAt(i).toString(10);

                    require(79).debug(number + ' : ');
                } else {
                    number = s.charCodeAt(i) <= 15 ? "0" + s.charCodeAt(i).toString(10) : s.charCodeAt(i).toString(10);
                    require(79).debug(number + ' : ' + s.charAt(i));
                }
            }
        };

        BinaryParser.hlprint = function hprint(s) {
            var number;

            for (var i = 0, len = s.length; i < len; i++) {
                if (s.charCodeAt(i) < 32) {
                    number = s.charCodeAt(i) <= 15 ? "0" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);
                    require(79).debug(number + ' : ');
                } else {
                    number = s.charCodeAt(i) <= 15 ? "0" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);
                    require(79).debug(number + ' : ' + s.charAt(i));
                }
            }
        };

        /**
         * BinaryParser buffer constructor.
         */
        function BinaryParserBuffer(bigEndian, buffer) {
            this.bigEndian = bigEndian || 0;
            this.buffer = [];
            this.setBuffer(buffer);
        };

        BinaryParserBuffer.prototype.setBuffer = function setBuffer(data) {
            var l, i, b;

            if (data) {
                i = l = data.length;
                b = this.buffer = new Array(l);
                for (; i; b[l - i] = data.charCodeAt(--i));
                this.bigEndian && b.reverse();
            }
        };

        BinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits(neededBits) {
            return this.buffer.length >= -(-neededBits >> 3);
        };

        BinaryParserBuffer.prototype.checkBuffer = function checkBuffer(neededBits) {
            if (!this.hasNeededBits(neededBits)) {
                throw new Error("checkBuffer::missing bytes");
            }
        };

        BinaryParserBuffer.prototype.readBits = function readBits(start, length) {
            //shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)

            function shl(a, b) {
                for (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
                return a;
            }

            if (start < 0 || length <= 0) {
                return 0;
            }

            this.checkBuffer(start + length);

            var offsetLeft, offsetRight = start % 8,
                curByte = this.buffer.length - (start >> 3) - 1,
                lastByte = this.buffer.length + (-(start + length) >> 3),
                diff = curByte - lastByte,
                sum = ((this.buffer[curByte] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight : 0);

            for (; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));

            return sum;
        };

        /**
         * Expose.
         */
        BinaryParser.Buffer = BinaryParserBuffer;

        exports.BinaryParser = BinaryParser;


    },
    function(require, exports, module, global) {

        var process = require(1);
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                    case '%s':
                        return String(args[i++]);
                    case '%d':
                        return Number(args[i++]);
                    case '%j':
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return '[Circular]';
                        }
                    default:
                        return x;
                }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += ' ' + x;
                } else {
                    str += ' ' + inspect(x);
                }
            }
            return str;
        };


        // Mark that a method should not be used.
        // Returns a modified function which warns once by default.
        // If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }

            if (process.noDeprecation === true) {
                return fn;
            }

            var warned = false;

            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error('%s %d: %s', set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
            } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
        };

        // Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                    '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
                return str;
            }
        }


        function stylizeNoColor(str, styleType) {
            return str;
        }


        function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
                hash[val] = true;
            });

            return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ': ' + value.name : '';
                    return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }

            var base = '',
                array = false,
                braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
                base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                    return ctx.stylize('[Object]', 'special');
                }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
            if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
                return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
                return ctx.stylize('null', 'null');
        }


        function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        String(i), true));
                } else {
                    output.push('');
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        key, true));
                }
            });
            return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
            };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                    str = ctx.stylize('[Getter]', 'special');
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize('[Setter]', 'special');
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf('\n') > -1) {
                        if (array) {
                            str = str.split('\n').map(function(line) {
                                return '  ' + line;
                            }).join('\n').substr(2);
                        } else {
                            str = '\n' + str.split('\n').map(function(line) {
                                return '   ' + line;
                            }).join('\n');
                        }
                    }
                } else {
                    str = ctx.stylize('[Circular]', 'special');
                }
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, 'name');
                } else {
                    name = name.replace(/'/g, "\\'")
                        .replace(/\\"/g, '"')
                        .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, 'string');
                }
            }

            return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
                return braces[0] +
                    (base === '' ? '' : base + '\n ') +
                    ' ' +
                    output.join(',\n  ') +
                    ' ' +
                    braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


        // NOTE: These type checking functions intentionally don't use `instanceof`
        // because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' || // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require(80);

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }


        function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
            'Oct', 'Nov', 'Dec'
        ];

        // 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())
            ].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


        // log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require(7);

        exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }


    },
    function(require, exports, module, global) {

        var Buffer = require(45).Buffer;
        module.exports = function isBuffer(arg) {
            return arg instanceof Buffer;
        }


    },
    function(require, exports, module, global) {

        /**
         * A class representation of the BSON Symbol type.
         *
         * @class Represents the BSON Symbol type.
         * @param {String} value the string representing the symbol.
         * @return {Symbol}
         */
        function Symbol(value) {
            if (!(this instanceof Symbol)) return new Symbol(value);
            this._bsontype = 'Symbol';
            this.value = value;
        }

        /**
         * Access the wrapped string value.
         *
         * @return {String} returns the wrapped string.
         * @api public
         */
        Symbol.prototype.valueOf = function() {
            return this.value;
        };

        /**
         * @ignore
         * @api private
         */
        Symbol.prototype.toString = function() {
            return this.value;
        }

        /**
         * @ignore
         * @api private
         */
        Symbol.prototype.inspect = function() {
            return this.value;
        }

        /**
         * @ignore
         * @api private
         */
        Symbol.prototype.toJSON = function() {
            return this.value;
        }

        exports.Symbol = Symbol;

    },
    function(require, exports, module, global) {

        /**
         * A class representation of the BSON Code type.
         *
         * @class Represents the BSON Code type.
         * @param {String|Function} code a string or function.
         * @param {Object} [scope] an optional scope for the function.
         * @return {Code}
         */
        var Code = function Code(code, scope) {
            if (!(this instanceof Code)) return new Code(code, scope);
            this._bsontype = 'Code';
            this.code = code;
            this.scope = scope == null ? {} : scope;
        };

        /**
         * @ignore
         * @api private
         */
        Code.prototype.toJSON = function() {
            return {
                scope: this.scope,
                code: this.code
            };
        }

        exports.Code = Code;

    },
    function(require, exports, module, global) {

        /**
         * A class representation of the BSON MinKey type.
         *
         * @class Represents the BSON MinKey type.
         * @return {MinKey}
         */
        function MinKey() {
            if (!(this instanceof MinKey)) return new MinKey();

            this._bsontype = 'MinKey';
        }

        exports.MinKey = MinKey;

    },
    function(require, exports, module, global) {

        /**
         * A class representation of the BSON MaxKey type.
         *
         * @class Represents the BSON MaxKey type.
         * @return {MaxKey}
         */
        function MaxKey() {
            if (!(this instanceof MaxKey)) return new MaxKey();

            this._bsontype = 'MaxKey';
        }

        exports.MaxKey = MaxKey;

    },
    function(require, exports, module, global) {

        /**
         * A class representation of the BSON DBRef type.
         *
         * @class Represents the BSON DBRef type.
         * @param {String} namespace the collection name.
         * @param {ObjectID} oid the reference ObjectID.
         * @param {String} [db] optional db name, if omitted the reference is local to the current db.
         * @return {DBRef}
         */
        function DBRef(namespace, oid, db) {
            if (!(this instanceof DBRef)) return new DBRef(namespace, oid, db);

            this._bsontype = 'DBRef';
            this.namespace = namespace;
            this.oid = oid;
            this.db = db;
        };

        /**
         * @ignore
         * @api private
         */
        DBRef.prototype.toJSON = function() {
            return {
                '$ref': this.namespace,
                '$id': this.oid,
                '$db': this.db == null ? '' : this.db
            };
        }

        exports.DBRef = DBRef;

    },
    function(require, exports, module, global) {

        var Buffer = require(45).Buffer;
        /**
         * Module dependencies.
         */
        if (typeof window === 'undefined') {
            var Buffer = require(45).Buffer; // TODO just use global Buffer
        }

        // Binary default subtype
        var BSON_BINARY_SUBTYPE_DEFAULT = 0;

        /**
         * @ignore
         * @api private
         */
        var writeStringToArray = function(data) {
            // Create a buffer
            var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
            // Write the content to the buffer
            for (var i = 0; i < data.length; i++) {
                buffer[i] = data.charCodeAt(i);
            }
            // Write the string to the buffer
            return buffer;
        }

        /**
         * Convert Array ot Uint8Array to Binary String
         *
         * @ignore
         * @api private
         */
        var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
            var result = "";
            for (var i = startIndex; i < endIndex; i++) {
                result = result + String.fromCharCode(byteArray[i]);
            }
            return result;
        };

        /**
         * A class representation of the BSON Binary type.
         *
         * Sub types
         *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
         *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
         *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
         *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
         *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
         *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
         *
         * @class Represents the Binary BSON type.
         * @param {Buffer} buffer a buffer object containing the binary data.
         * @param {Number} [subType] the option binary type.
         * @return {Grid}
         */
        function Binary(buffer, subType) {
            if (!(this instanceof Binary)) return new Binary(buffer, subType);

            this._bsontype = 'Binary';

            if (buffer instanceof Number) {
                this.sub_type = buffer;
                this.position = 0;
            } else {
                this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
                this.position = 0;
            }

            if (buffer != null && !(buffer instanceof Number)) {
                // Only accept Buffer, Uint8Array or Arrays
                if (typeof buffer == 'string') {
                    // Different ways of writing the length of the string for the different types
                    if (typeof Buffer != 'undefined') {
                        this.buffer = new Buffer(buffer);
                    } else if (typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
                        this.buffer = writeStringToArray(buffer);
                    } else {
                        throw new Error("only String, Buffer, Uint8Array or Array accepted");
                    }
                } else {
                    this.buffer = buffer;
                }
                this.position = buffer.length;
            } else {
                if (typeof Buffer != 'undefined') {
                    this.buffer = new Buffer(Binary.BUFFER_SIZE);
                } else if (typeof Uint8Array != 'undefined') {
                    this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
                } else {
                    this.buffer = new Array(Binary.BUFFER_SIZE);
                }
                // Set position to start of buffer
                this.position = 0;
            }
        };

        /**
         * Updates this binary with byte_value.
         *
         * @param {Character} byte_value a single byte we wish to write.
         * @api public
         */
        Binary.prototype.put = function put(byte_value) {
            // If it's a string and a has more than one character throw an error
            if (byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
            if (typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");

            // Decode the byte value once
            var decoded_byte = null;
            if (typeof byte_value == 'string') {
                decoded_byte = byte_value.charCodeAt(0);
            } else if (byte_value['length'] != null) {
                decoded_byte = byte_value[0];
            } else {
                decoded_byte = byte_value;
            }

            if (this.buffer.length > this.position) {
                this.buffer[this.position++] = decoded_byte;
            } else {
                if (typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
                    // Create additional overflow buffer
                    var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
                    // Combine the two buffers together
                    this.buffer.copy(buffer, 0, 0, this.buffer.length);
                    this.buffer = buffer;
                    this.buffer[this.position++] = decoded_byte;
                } else {
                    var buffer = null;
                    // Create a new buffer (typed or normal array)
                    if (Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
                        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
                    } else {
                        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
                    }

                    // We need to copy all the content to the new array
                    for (var i = 0; i < this.buffer.length; i++) {
                        buffer[i] = this.buffer[i];
                    }

                    // Reassign the buffer
                    this.buffer = buffer;
                    // Write the byte
                    this.buffer[this.position++] = decoded_byte;
                }
            }
        };

        /**
         * Writes a buffer or string to the binary.
         *
         * @param {Buffer|String} string a string or buffer to be written to the Binary BSON object.
         * @param {Number} offset specify the binary of where to write the content.
         * @api public
         */
        Binary.prototype.write = function write(string, offset) {
            offset = typeof offset == 'number' ? offset : this.position;

            // If the buffer is to small let's extend the buffer
            if (this.buffer.length < offset + string.length) {
                var buffer = null;
                // If we are in node.js
                if (typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
                    buffer = new Buffer(this.buffer.length + string.length);
                    this.buffer.copy(buffer, 0, 0, this.buffer.length);
                } else if (Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
                    // Create a new buffer
                    buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
                        // Copy the content
                    for (var i = 0; i < this.position; i++) {
                        buffer[i] = this.buffer[i];
                    }
                }

                // Assign the new buffer
                this.buffer = buffer;
            }

            if (typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
                string.copy(this.buffer, offset, 0, string.length);
                this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
                // offset = string.length
            } else if (typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {
                this.buffer.write(string, 'binary', offset);
                this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
                // offset = string.length;
            } else if (Object.prototype.toString.call(string) == '[object Uint8Array]' || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {
                for (var i = 0; i < string.length; i++) {
                    this.buffer[offset++] = string[i];
                }

                this.position = offset > this.position ? offset : this.position;
            } else if (typeof string == 'string') {
                for (var i = 0; i < string.length; i++) {
                    this.buffer[offset++] = string.charCodeAt(i);
                }

                this.position = offset > this.position ? offset : this.position;
            }
        };

        /**
         * Reads **length** bytes starting at **position**.
         *
         * @param {Number} position read from the given position in the Binary.
         * @param {Number} length the number of bytes to read.
         * @return {Buffer}
         * @api public
         */
        Binary.prototype.read = function read(position, length) {
            length = length && length > 0 ? length : this.position;

            // Let's return the data based on the type we have
            if (this.buffer['slice']) {
                return this.buffer.slice(position, position + length);
            } else {
                // Create a buffer to keep the result
                var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
                for (var i = 0; i < length; i++) {
                    buffer[i] = this.buffer[position++];
                }
            }
            // Return the buffer
            return buffer;
        };

        /**
         * Returns the value of this binary as a string.
         *
         * @return {String}
         * @api public
         */
        Binary.prototype.value = function value(asRaw) {
            asRaw = asRaw == null ? false : asRaw;

            // Optimize to serialize for the situation where the data == size of buffer
            if (asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)
                return this.buffer;

            // If it's a node.js buffer object
            if (typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
                return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
            } else {
                if (asRaw) {
                    // we support the slice command use it
                    if (this.buffer['slice'] != null) {
                        return this.buffer.slice(0, this.position);
                    } else {
                        // Create a new buffer to copy content to
                        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
                        // Copy content
                        for (var i = 0; i < this.position; i++) {
                            newBuffer[i] = this.buffer[i];
                        }
                        // Return the buffer
                        return newBuffer;
                    }
                } else {
                    return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
                }
            }
        };

        /**
         * Length.
         *
         * @return {Number} the length of the binary.
         * @api public
         */
        Binary.prototype.length = function length() {
            return this.position;
        };

        /**
         * @ignore
         * @api private
         */
        Binary.prototype.toJSON = function() {
            return this.buffer != null ? this.buffer.toString('base64') : '';
        }

        /**
         * @ignore
         * @api private
         */
        Binary.prototype.toString = function(format) {
            return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
        }

        Binary.BUFFER_SIZE = 256;

        /**
         * Default BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_DEFAULT = 0;
        /**
         * Function BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_FUNCTION = 1;
        /**
         * Byte Array BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_BYTE_ARRAY = 2;
        /**
         * OLD UUID BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_UUID_OLD = 3;
        /**
         * UUID BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_UUID = 4;
        /**
         * MD5 BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_MD5 = 5;
        /**
         * User BSON type
         *
         * @classconstant SUBTYPE_DEFAULT
         **/
        Binary.SUBTYPE_USER_DEFINED = 128;

        /**
         * Expose.
         */
        exports.Binary = Binary;



    },
    function(require, exports, module, global) {

        // Copyright (c) 2008, Fair Oaks Labs, Inc.
        // All rights reserved.
        // 
        // Redistribution and use in source and binary forms, with or without
        // modification, are permitted provided that the following conditions are met:
        // 
        //  * Redistributions of source code must retain the above copyright notice,
        //    this list of conditions and the following disclaimer.
        // 
        //  * Redistributions in binary form must reproduce the above copyright notice,
        //    this list of conditions and the following disclaimer in the documentation
        //    and/or other materials provided with the distribution.
        // 
        //  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
        //    may be used to endorse or promote products derived from this software
        //    without specific prior written permission.
        // 
        // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
        // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
        // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
        // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        // POSSIBILITY OF SUCH DAMAGE.
        //
        //
        // Modifications to writeIEEE754 to support negative zeroes made by Brian White

        var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
            var e, m,
                bBE = (endian === 'big'),
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                nBits = -7,
                i = bBE ? 0 : (nBytes - 1),
                d = bBE ? 1 : -1,
                s = buffer[offset + i];

            i += d;

            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
            var e, m, c,
                bBE = (endian === 'big'),
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
                i = bBE ? (nBytes - 1) : 0,
                d = bBE ? -1 : 1,
                s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }

                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

            buffer[offset + i - d] |= s * 128;
        };

        exports.readIEEE754 = readIEEE754;
        exports.writeIEEE754 = writeIEEE754;

    },
    function(require, exports, module, global) {

        module.exports = {
            "name": "mongodb",
            "description": "A node.js driver for MongoDB",
            "keywords": [
                "mongodb",
                "mongo",
                "driver",
                "db"
            ],
            "version": "1.4.19",
            "author": {
                "name": "Christian Amor Kvalheim",
                "email": "christkv@gmail.com"
            },
            "contributors": [{
                "name": "Aaron Heckmann"
            }, {
                "name": "Christoph Pojer"
            }, {
                "name": "Pau Ramon Revilla"
            }, {
                "name": "Nathan White"
            }, {
                "name": "Emmerman"
            }, {
                "name": "Seth LaForge"
            }, {
                "name": "Boris Filipov"
            }, {
                "name": "Stefan Schärmeli"
            }, {
                "name": "Tedde Lundgren"
            }, {
                "name": "renctan"
            }, {
                "name": "Sergey Ukustov"
            }, {
                "name": "Ciaran Jessup"
            }, {
                "name": "kuno"
            }, {
                "name": "srimonti"
            }, {
                "name": "Erik Abele"
            }, {
                "name": "Pratik Daga"
            }, {
                "name": "Slobodan Utvic"
            }, {
                "name": "Kristina Chodorow"
            }, {
                "name": "Yonathan Randolph"
            }, {
                "name": "Brian Noguchi"
            }, {
                "name": "Sam Epstein"
            }, {
                "name": "James Harrison Fisher"
            }, {
                "name": "Vladimir Dronnikov"
            }, {
                "name": "Ben Hockey"
            }, {
                "name": "Henrik Johansson"
            }, {
                "name": "Simon Weare"
            }, {
                "name": "Alex Gorbatchev"
            }, {
                "name": "Shimon Doodkin"
            }, {
                "name": "Kyle Mueller"
            }, {
                "name": "Eran Hammer-Lahav"
            }, {
                "name": "Marcin Ciszak"
            }, {
                "name": "François de Metz"
            }, {
                "name": "Vinay Pulim"
            }, {
                "name": "nstielau"
            }, {
                "name": "Adam Wiggins"
            }, {
                "name": "entrinzikyl"
            }, {
                "name": "Jeremy Selier"
            }, {
                "name": "Ian Millington"
            }, {
                "name": "Public Keating"
            }, {
                "name": "andrewjstone"
            }, {
                "name": "Christopher Stott"
            }, {
                "name": "Corey Jewett"
            }, {
                "name": "brettkiefer"
            }, {
                "name": "Rob Holland"
            }, {
                "name": "Senmiao Liu"
            }, {
                "name": "heroic"
            }, {
                "name": "gitfy"
            }, {
                "name": "Andrew Stone"
            }, {
                "name": "John Le Drew"
            }, {
                "name": "Lucasfilm Singapore"
            }, {
                "name": "Roman Shtylman"
            }, {
                "name": "Matt Self"
            }, {
                "name": "Gregory Langlais"
            }, {
                "name": "Samantha Ritter"
            }],
            "repository": {
                "type": "git",
                "url": "http://github.com/mongodb/node-mongodb-native.git"
            },
            "bugs": {
                "url": "http://github.com/mongodb/node-mongodb-native/issues"
            },
            "dependencies": {
                "bson": "~0.2",
                "kerberos": "0.0.4",
                "readable-stream": "latest"
            },
            "devDependencies": {
                "dox": "0.4.4",
                "uglify-js": "1.2.5",
                "ejs": "0.6.1",
                "request": "2.12.0",
                "nodeunit": "0.7.3",
                "markdown": "0.3.1",
                "gleak": "0.2.3",
                "step": "0.0.5",
                "async": "0.1.22",
                "integra": "0.0.3",
                "optimist": "latest"
            },
            "optionalDependencies": {
                "kerberos": "0.0.4",
                "readable-stream": "latest"
            },
            "config": {
                "native": false
            },
            "main": "./lib/mongodb/index",
            "homepage": "http://mongodb.github.com/node-mongodb-native/",
            "directories": {
                "lib": "./lib/mongodb"
            },
            "engines": {
                "node": ">=0.6.19"
            },
            "scripts": {
                "test": "make test_functional"
            },
            "licenses": [{
                "type": "Apache License, Version 2.0",
                "url": "http://www.apache.org/licenses/LICENSE-2.0"
            }],
            "_id": "mongodb@1.4.19",
            "_shasum": "dbb47f1899c205b00bfb746db0ed002408b0af71",
            "_from": "mongodb@*",
            "_npmVersion": "1.4.9",
            "_npmUser": {
                "name": "christkv",
                "email": "christkv@gmail.com"
            },
            "maintainers": [{
                "name": "christkv",
                "email": "christkv@gmail.com"
            }],
            "dist": {
                "shasum": "dbb47f1899c205b00bfb746db0ed002408b0af71",
                "tarball": "http://registry.npmjs.org/mongodb/-/mongodb-1.4.19.tgz"
            },
            "_resolved": "https://registry.npmjs.org/mongodb/-/mongodb-1.4.19.tgz",
            "readme": "ERROR: No README data found!"
        }


    },
    function(require, exports, module, global) {

        module.exports = function seed(callback) {
            var collection = require(2),

                User = collection.models.User,
                Cart = collection.models.Cart,
                Item = collection.models.Item,

                length = 0,
                done = false;

            function createCallback() {
                length++;

                return function doneCallback(err) {
                    if (done === true) {
                        return;
                    }
                    if (err || --length <= 0) {
                        done = true;
                        callback(err);
                        console.timeEnd("seed");
                    }
                };
            }

            User.create({
                firstName: "Bob",
                lastName: "Smile",
                age: 64,
                password: "bobsmile",
                email: "bobsmile@bob.com"
            }, createCallback());

            User.create({
                firstName: "Nathan",
                lastName: "Faucett",
                age: 21,
                password: "nathanfaucett",
                email: "nathanfaucett@gmail.com"
            }, createCallback());

            User.create({
                firstName: "Sue",
                lastName: "Frank",
                age: 36,
                password: "suefrank",
                email: "suefrank@yahoo.com"
            }, createCallback());


            Cart.create({
                userId: 1,
                title: "Fun cart",
                content: "nothing like this"
            }, createCallback());

            Cart.create({
                userId: 1,
                title: "Other Fun cart",
                content: "there is something like this"
            }, createCallback());


            Cart.create({
                userId: 2,
                title: "My cart",
                content: "its alright"
            }, createCallback());

            Cart.create({
                userId: 2,
                title: "This Cart is Great!",
                content: "Maybe?"
            }, createCallback());


            Cart.create({
                userId: 3,
                title: "Cart",
                content: "big stuff"
            }, createCallback());

            Cart.create({
                userId: 3,
                title: "Cart of Great",
                content: "has many good times"
            }, createCallback());


            Item.create({
                cartId: 1,
                userId: 2,
                title: "My item",
                content: "its alright",
                json: {
                    name: "bob"
                }
            }, createCallback());

            Item.create({
                cartId: 1,
                userId: 2,
                title: "This Item is Great!",
                content: "Maybe?",
                json: {
                    name: "bob"
                }
            }, createCallback());
        };


    }
], (new Function("return this;"))()));
